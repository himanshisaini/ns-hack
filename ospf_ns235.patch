diff -Naur ns-2.35-orig/classifier/classifier-mtopology.cc ns-2.35/classifier/classifier-mtopology.cc
--- ns-2.35-orig/classifier/classifier-mtopology.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/classifier/classifier-mtopology.cc	2015-01-24 16:57:49.539072615 +0100
@@ -0,0 +1,31 @@
+/*
+ * classifier-mtopology.cc
+ * Copyright (C) 2006 by the University of Extremadura
+ * This program is free software: you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public License as published by 
+ * the Free Software Foundation, either version 3 of the License, or 
+ * (at your option) any later version. This program is distributed in the 
+ * hope that it will be useful, but WITHOUT ANY WARRANTY; without 
+ * even the implied warranty of MERCHANTABILITY or FITNESS FOR 
+ * A PARTICULAR PURPOSE. See the GNU General Public License 
+ * for more details. You should have received a copy of the GNU General 
+ * Public License along with this program. If not, see <http://www.gnu.org/licenses/>. 
+ */
+
+// by Inés María Romero Dávila (inroda04@alumnos.unex.es)
+// and Alfonso Gazo Cervero (agazo@unex.es)
+
+/***********************************************************************************
+ Módulo en el que se crea un nuevo tipo de clasificador que soporta el multitopology
+ routing. Permite direccionar los paquetes en función de su identificador
+ multitopología.
+************************************************************************************/
+
+#include "classifier-mtopology.h"
+
+int  MTopoClassifier::classify(Packet *p) {
+	hdr_ip* iph = hdr_ip::access(p);
+	//printf("\nclassifier mtid: %d",iph->mtid());	
+	return (iph->mtid());
+};
+
diff -Naur ns-2.35-orig/classifier/classifier-mtopology.h ns-2.35/classifier/classifier-mtopology.h
--- ns-2.35-orig/classifier/classifier-mtopology.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/classifier/classifier-mtopology.h	2015-01-24 16:57:49.539072615 +0100
@@ -0,0 +1,52 @@
+/*
+ * classifier-mtopology.h
+ * Copyright (C) 2006 by the University of Extremadura
+ * This program is free software: you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public License as published by 
+ * the Free Software Foundation, either version 3 of the License, or 
+ * (at your option) any later version. This program is distributed in the 
+ * hope that it will be useful, but WITHOUT ANY WARRANTY; without 
+ * even the implied warranty of MERCHANTABILITY or FITNESS FOR 
+ * A PARTICULAR PURPOSE. See the GNU General Public License 
+ * for more details. You should have received a copy of the GNU General 
+ * Public License along with this program. If not, see <http://www.gnu.org/licenses/>. 
+ */
+
+// by Inés María Romero Dávila (inroda04@alumnos.unex.es)
+// and Alfonso Gazo Cervero (agazo@unex.es)
+
+/***********************************************************************************
+ Módulo en el que se crea un nuevo tipo de clasificador que soporta el multitopology
+ routing. Permite direccionar los paquetes en función de su destino y su identificador
+ multitopología.
+************************************************************************************/
+
+#ifndef ns_classifier_mtopo_h
+#define ns_classifier_mtopo_h
+
+#include "classifier.h"
+#include "ip.h"
+#include "config.h"
+#include "packet.h"
+
+
+class MTopoClassifier : public Classifier {
+public:
+	MTopoClassifier (): Classifier() {
+	//printf("constructor mtclassifier");
+	}
+	int classify(Packet * p);
+
+};
+
+static class MTopoClassifierclass : public TclClass {
+public:
+	MTopoClassifierclass() : TclClass("Classifier/MT") {}
+	TclObject* create(int, const char*const*) {
+		return (new MTopoClassifier());
+	}
+} class_MTopoClassifier;
+
+
+
+#endif
diff -Naur ns-2.35-orig/common/agent.cc ns-2.35/common/agent.cc
--- ns-2.35-orig/common/agent.cc	2010-03-08 06:54:49.000000000 +0100
+++ ns-2.35/common/agent.cc	2015-01-24 16:57:49.539072615 +0100
@@ -85,6 +85,9 @@
 	delay_bind_init_one("prio_");
 	delay_bind_init_one("flags_");
 	delay_bind_init_one("ttl_");
+	// MODIFICADO:20-01-07
+	delay_bind_init_one("mtid_");
+	// FIN MODIFICADO:20-01-07
 	delay_bind_init_one("class_");
 	Connector::delay_bind_init_all();
 }
@@ -100,6 +103,9 @@
 	if (delay_bind(varName, localName, "prio_", (int*)&prio_, tracer)) return TCL_OK;
 	if (delay_bind(varName, localName, "flags_", (int*)&flags_, tracer)) return TCL_OK;
 	if (delay_bind(varName, localName, "ttl_", &defttl_, tracer)) return TCL_OK;
+	//MODIFICADO:20-01-07
+	if (delay_bind(varName, localName, "mtid_",&mtid_, tracer)) return TCL_OK;
+	//FIN MODIFICADO:20-01-07
 	if (delay_bind(varName, localName, "class_", (int*)&fid_, tracer)) return TCL_OK;
 	return Connector::delay_bind_dispatch(varName, localName, tracer);
 }
@@ -478,6 +484,9 @@
 	iph->flowid() = fid_;
 	iph->prio() = prio_;
 	iph->ttl() = defttl_;
+	//MODIFICADO:20-01-07
+	iph->mtid() = mtid_;
+	//FIN MODIFICADO:20-01-07
 
 	hdr_flags* hf = hdr_flags::access(p);
 	hf->ecn_capable_ = 0;
diff -Naur ns-2.35-orig/common/agent.h ns-2.35/common/agent.h
--- ns-2.35-orig/common/agent.h	2011-08-26 21:26:39.000000000 +0200
+++ ns-2.35/common/agent.h	2015-01-24 16:57:49.540072651 +0100
@@ -126,6 +126,9 @@
 	int prio_;			// for IPv6 prio field
 	int flags_;			// for experiments (see ip.h)
 	int defttl_;			// default ttl for outgoing pkts
+	//MODIFICADO:20-01-07
+	int mtid_;			//mtid for outgoing pkts
+	//FIN MODIFICADO:20-01-07
 
 #ifdef notdef
 	int seqno_;		/* current seqno */
diff -Naur ns-2.35-orig/common/ip.cc ns-2.35/common/ip.cc
--- ns-2.35-orig/common/ip.cc	1998-08-13 01:41:05.000000000 +0200
+++ ns-2.35/common/ip.cc	2015-01-24 16:57:49.540072651 +0100
@@ -53,6 +53,9 @@
 		field_offset("src_", OFFSET(hdr_ip, src_));
 		field_offset("dst_", OFFSET(hdr_ip, dst_));
 		field_offset("ttl_", OFFSET(hdr_ip, ttl_));
+		//MODIFICADO: 19-09-06
+		field_offset("mtid_", OFFSET(hdr_ip, mtid_));
+		//FIN MODIFICADO: 19-09-06
 		field_offset("fid_", OFFSET(hdr_ip, fid_));
 		field_offset("prio_", OFFSET(hdr_ip, prio_));
 	}
diff -Naur ns-2.35-orig/common/ip.h ns-2.35/common/ip.h
--- ns-2.35-orig/common/ip.h	2006-02-22 14:32:23.000000000 +0100
+++ ns-2.35/common/ip.h	2015-01-24 16:57:49.540072651 +0100
@@ -61,6 +61,11 @@
 	ns_addr_t	dst_;
 	int		ttl_;
 
+	// MODIFICADO: 19-09-06
+	// TOS based routing OSPF 
+	int		mtid_;
+	// FIN MODIFICADO: 19-09-6
+
 	/* Monarch extn */
 // 	u_int16_t	sport_;
 // 	u_int16_t	dport_;
@@ -84,6 +89,11 @@
 	nsaddr_t& daddr() { return (dst_.addr_); }
         int32_t& dport() { return dst_.port_;}
 	int& ttl() { return (ttl_); }
+
+	// MODIFICADO: 19-09-06
+	int& mtid() { return (mtid_); }
+	// FIN MODIFICADO: 19-09-06
+
 	/* ipv6 fields */
 	int& flowid() { return (fid_); }
 	int& prio() { return (prio_); }
diff -Naur ns-2.35-orig/common/packet.h ns-2.35/common/packet.h
--- ns-2.35-orig/common/packet.h	2010-05-10 00:28:41.000000000 +0200
+++ ns-2.35/common/packet.h	2015-01-24 17:01:45.150349491 +0100
@@ -198,9 +198,14 @@
 
         // M-DART packets
 static const packet_t PT_MDART = 72;
+
+	// MODIFICADO: 04-09-06
+	// OSPF Header...
+static const packet_t PT_RTPROTO_OSPF = 73;
+	// FIN MODIFICADO: 04-09-06
 	
         // insert new packet types here
-static packet_t       PT_NTYPE = 73; // This MUST be the LAST one
+static packet_t       PT_NTYPE = 74; // This MUST be the LAST one
 
 enum packetClass
 {
@@ -417,6 +422,11 @@
 		name_[PT_DCCP_CLOSEREQ]="DCCP_CloseReq";
 		name_[PT_DCCP_RESET]="DCCP_Reset";
 
+		// MODIFICADO: 04-09-06
+		// for OSPF
+		name_[PT_RTPROTO_OSPF]="rtProtoOSPF";
+		// FIN MODIFICADO: 04-09-06
+		
 		name_[PT_NTYPE]= "undefined";
 	}
 	static int addPacket(char *name);
diff -Naur ns-2.35-orig/Makefile.in ns-2.35/Makefile.in
--- ns-2.35-orig/Makefile.in	2014-10-18 01:50:36.000000000 +0200
+++ ns-2.35/Makefile.in	2015-01-24 16:57:49.541072687 +0100
@@ -175,6 +175,7 @@
 	classifier/classifier-mac.o \
 	classifier/classifier-qs.o \
 	classifier/classifier-port.o src_rtg/classifier-sr.o \
+	classifier/classifier-mtopology.o \
         src_rtg/sragent.o src_rtg/hdr_src.o adc/ump.o \
 	qs/qsagent.o qs/hdr_qs.o \
 	apps/app.o apps/telnet.o tcp/tcplib-telnet.o \
@@ -295,6 +296,7 @@
 	queue/rio.o queue/semantic-rio.o tcp/tcp-sack-rh.o tcp/scoreboard-rh.o \
 	plm/loss-monitor-plm.o plm/cbr-traffic-PP.o \
 	linkstate/hdr-ls.o \
+	ospf/hdr-ospf.o  ospf/ospf.o ospf/rtProtoOSPF.o\
 	mpls/classifier-addr-mpls.o mpls/ldp.o mpls/mpls-module.o \
 	routing/rtmodule.o classifier/classifier-hier.o \
 	routing/addr-params.o \
@@ -482,7 +484,9 @@
 	tcl/rtglib/route-proto.tcl \
 	tcl/rtglib/algo-route-proto.tcl \
 	tcl/rtglib/ns-rtProtoLS.tcl \
-        tcl/interface/ns-iface.tcl \
+	tcl/rtglib/ns-rtProtoOSPF.tcl \
+	tcl/rtglib/dynamicsCost.tcl \
+	tcl/interface/ns-iface.tcl \
 	tcl/mcast/BST.tcl \
         tcl/mcast/ns-mcast.tcl \
         tcl/mcast/McastProto.tcl \
diff -Naur ns-2.35-orig/ospf/COPYING ns-2.35/ospf/COPYING
--- ns-2.35-orig/ospf/COPYING	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/ospf/COPYING	2015-01-24 16:57:49.553073117 +0100
@@ -0,0 +1,674 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
diff -Naur ns-2.35-orig/ospf/hdr-ospf.cc ns-2.35/ospf/hdr-ospf.cc
--- ns-2.35-orig/ospf/hdr-ospf.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/ospf/hdr-ospf.cc	2015-01-24 16:57:49.553073117 +0100
@@ -0,0 +1,31 @@
+/*
+ * hdp-ospf.cc
+ * Copyright (C) 2006 by the University of Extremadura
+ * This program is free software: you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public License as published by 
+ * the Free Software Foundation, either version 3 of the License, or 
+ * (at your option) any later version. This program is distributed in the 
+ * hope that it will be useful, but WITHOUT ANY WARRANTY; without 
+ * even the implied warranty of MERCHANTABILITY or FITNESS FOR 
+ * A PARTICULAR PURPOSE. See the GNU General Public License 
+ * for more details. You should have received a copy of the GNU General 
+ * Public License along with this program. If not, see <http://www.gnu.org/licenses/>. 
+ */
+
+// by Inés María Romero Dávila (inroda04@alumnos.unex.es)
+// and Alfonso Gazo Cervero (agazo@unex.es)
+
+#include "hdr-ospf.h"
+
+//**********************************************************************************
+// OSPFHeaderClass Constructor
+//**********************************************************************************
+
+int hdr_Ospf::offset_;
+static class OSPFHeaderClass : public PacketHeaderClass {
+public:
+	OSPFHeaderClass() : PacketHeaderClass("PacketHeader/rtProtoOSPF",
+					     sizeof(hdr_Ospf)) {
+		bind_offset(&hdr_Ospf::offset_);
+	}
+} class_ospfhdr;
diff -Naur ns-2.35-orig/ospf/hdr-ospf.h ns-2.35/ospf/hdr-ospf.h
--- ns-2.35-orig/ospf/hdr-ospf.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/ospf/hdr-ospf.h	2015-01-24 16:57:49.553073117 +0100
@@ -0,0 +1,61 @@
+/*
+ * hdp-ospf.h
+ * Copyright (C) 2006 by the University of Extremadura
+ * This program is free software: you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public License as published by 
+ * the Free Software Foundation, either version 3 of the License, or 
+ * (at your option) any later version. This program is distributed in the 
+ * hope that it will be useful, but WITHOUT ANY WARRANTY; without 
+ * even the implied warranty of MERCHANTABILITY or FITNESS FOR 
+ * A PARTICULAR PURPOSE. See the GNU General Public License 
+ * for more details. You should have received a copy of the GNU General 
+ * Public License along with this program. If not, see <http://www.gnu.org/licenses/>. 
+ */
+
+// by Inés María Romero Dávila (inroda04@alumnos.unex.es)
+// and Alfonso Gazo Cervero (agazo@unex.es)
+
+//****************************************************************************************************
+// Módulo en el que se define la estructura de datos que representa la cabecera de los paquetes OSPF.
+//****************************************************************************************************
+
+#ifndef ns_ospf_hdr_h
+#define ns_ospf_hdr_h
+
+#include "config.h"
+#include "packet.h"
+#include "address.h"
+#include "ip.h"
+#include "utils.h"
+
+
+//**********************************************************************************
+// Common packet's header 
+//**********************************************************************************
+
+struct hdr_Ospf {
+	int version_; // version number (2)
+	Ospf_message_type_t type_; // OSPF packet type
+	u_int16_t packet_len_; // packet length in bytes
+	u_int32_t	router_id_; // router ip address
+	u_int32_t	area_id_; // area identifier 	
+
+	int msgId_; 	// message identifier (added to simplify simulation)
+
+	static int offset_; // needed by PacketHeaderManager
+	inline static int& offset() { return offset_; }
+	inline static hdr_Ospf* access(const Packet* p) {
+		return (hdr_Ospf*) p->access(offset_);
+	}
+
+	// Access methods
+	int& version() { return (version_);}
+	Ospf_message_type_t& type() { return (type_);}
+	u_int16_t& packet_len() { return (packet_len_);} 
+	u_int32_t& router_id() { return (router_id_);}
+	u_int32_t& area_id() { return (area_id_);}
+	int& msgId() {return (msgId_);}
+
+};
+
+#endif
diff -Naur ns-2.35-orig/ospf/ospf.cc ns-2.35/ospf/ospf.cc
--- ns-2.35-orig/ospf/ospf.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/ospf/ospf.cc	2015-01-24 16:57:49.558073296 +0100
@@ -0,0 +1,3913 @@
+/*
+ * ospf.cc
+ * Copyright (C) 2006 by the University of Extremadura
+ * This program is free software: you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public License as published by 
+ * the Free Software Foundation, either version 3 of the License, or 
+ * (at your option) any later version. This program is distributed in the 
+ * hope that it will be useful, but WITHOUT ANY WARRANTY; without 
+ * even the implied warranty of MERCHANTABILITY or FITNESS FOR 
+ * A PARTICULAR PURPOSE. See the GNU General Public License 
+ * for more details. You should have received a copy of the GNU General 
+ * Public License along with this program. If not, see <http://www.gnu.org/licenses/>. 
+ */
+
+// by Inés María Romero Dávila (inroda04@alumnos.unex.es)
+// and Alfonso Gazo Cervero (agazo@unex.es)
+
+
+#include "config.h"
+#ifdef HAVE_STL
+
+#include "ospf.h"
+
+// a global variable
+OspfMessageCenter OspfMessageCenter::msgctr_;
+
+int OspfRouting::msgSizes[OSPF_MESSAGE_TYPES];
+static class initRouting {
+public:
+		initRouting(){
+		OspfRouting::msgSizes[OSPF_MSG_HELLO] = OSPF_HELLO_MESSAGE_SIZE;
+		OspfRouting::msgSizes[OSPF_MSG_DD] =  OSPF_DD_MESSAGE_SIZE;
+		OspfRouting::msgSizes[OSPF_MSG_REQUEST] = OSPF_REQUEST_MESSAGE_SIZE;
+		OspfRouting::msgSizes[OSPF_MSG_UPDATE] = OSPF_UPDATE_MESSAGE_SIZE;
+		OspfRouting::msgSizes[OSPF_MSG_ACK] = OSPF_ACK_MESSAGE_SIZE;
+	}	
+} ospfRoutingInitializer;
+
+
+static void ls_error(char* msg) 
+{ 
+	fprintf(stderr, "%s\n", msg);
+	abort();
+}
+
+//**********************************************************************************
+// OspfPaths methods
+//**********************************************************************************
+
+//**********************************************************************************
+// insertPath method: insert a new path into OspfPaths 
+//**********************************************************************************
+
+OspfPaths::iterator OspfPaths::insertPath(int destId, int mtid, int cost, int nextHop) 
+{
+	iterator itr = OspfMTPathsMap::find(destId);
+	// if new path, insert it and return iterator
+	if (itr == end())
+		return insertPathNoChecking(destId,mtid, cost, nextHop);
+	
+	OspfMTRouterPathsMap* pEPM=&(*itr).second;
+	
+	OspfEqualPaths * pEP = pEPM->findPtr(mtid);
+	//if new mtid, insert it and return iterator
+	if (pEP == NULL) {
+		return insertPathNoChecking(destId,mtid, cost, nextHop);
+	}
+
+	// if the old path is better, ignore it, return end() 
+	// to flag the error
+	if (pEP->cost < cost)
+		return end(); 
+
+	// else if the new path is better, erase the old ones and save the new one
+	LsNodeIdList & nhList = pEP->nextHopList;
+	if (pEP->cost > cost) {
+		pEP->cost = cost;
+		nhList.erase(nhList.begin(), nhList.end());
+		nhList.push_back(nextHop);
+		return itr;
+	}
+	// else the old path is the same cost, check for duplicate
+	for (LsNodeIdList::iterator itrList = nhList.begin();
+	     itrList != nhList.end(); itrList++)
+		// if duplicate found, return 0 to flag the error 
+		if ((*itrList) == nextHop)
+			return end(); 
+	// else, the new path is installed indeed, the total number of nextHops
+	// is returned. 
+	nhList.push_back(nextHop);
+	return itr;
+}
+
+//**********************************************************************************
+// insertNextHopList method: insert a next hop list into OspfPaths
+//**********************************************************************************
+
+OspfPaths::iterator 
+OspfPaths::insertNextHopList(int destId, int cost, int mtid,
+			   const LsNodeIdList& nextHopList) 
+{
+	iterator itr = OspfMTPathsMap::find(destId);
+	// if new path, insert it and return iterator 
+	if (itr == end()) {
+		OspfEqualPaths ep(cost, nextHopList);
+		OspfMTRouterPathsMap  pEPM;
+		itr = insert(destId,pEPM);
+		(& (* itr).second)->insert(mtid,ep);
+		itr=find(destId);
+		
+		return itr;
+	}
+	// else if new mtid, insert it and return iterator
+	OspfEqualPaths* ptrOldEp = (&(*itr).second)->findPtr(mtid);
+	// if the old path is better, ignore it, return end() to flag error
+	if ( ptrOldEp  == NULL) {
+		OspfEqualPaths ep(cost, nextHopList);
+		(& (* itr).second)->insert(mtid,ep);
+		itr = find(destId);
+		return itr;
+	}
+	
+	// else get the old ep
+	if (ptrOldEp->cost < cost)
+		return end();
+	// else if the new path is better, replace the old one with the new one
+	if (ptrOldEp->cost > cost) {
+		ptrOldEp->cost = cost;
+		ptrOldEp->nextHopList = nextHopList ; // copy
+		return itr;
+	}
+	// equal cost: append the new next hops with checking for duplicates
+	ptrOldEp->appendNextHopList(nextHopList);
+	return itr;
+}
+
+
+//**********************************************************************************
+// OspfPathsTentative methods
+//**********************************************************************************
+
+//**********************************************************************************
+// popShortestPath method: get and remove min path 
+//**********************************************************************************
+
+
+OspfPath OspfPathsTentative::popShortestPath(int mtid) 
+{
+	findMinEqualPaths(mtid);
+	OspfPath path;
+	if (empty() || (minCostIterator == end()))
+		return path; // an invalid one
+
+	OspfEqualPaths* ep=(*minCostIterator).second.findPtr(mtid);
+
+	LsNodeIdList& nhList = ep->nextHopList;
+
+	if (nhList.empty() && (findMinEqualPaths(mtid) == end()))
+		return path;
+	path.desId_ = (*minCostIterator).first;
+	path.cost_=ep->cost;
+	path.mtId_=mtid;
+
+	// the first 'nextHop'
+	path.nextHop_ = nhList.front();
+	nhList.pop_front();
+
+	// if this pops out the last nextHop in the EqualPaths, find a new one.
+	if (nhList.empty()) {
+		erase(minCostIterator);
+		findMinEqualPaths(mtid);
+	}
+
+	return path;
+}
+
+//**********************************************************************************
+// findMinEqualPaths method: get less cost equal paths 
+//**********************************************************************************
+
+OspfPathsTentative::iterator OspfPathsTentative::findMinEqualPaths(int mtid)
+{
+	minCost = LS_MAX_COST + 1; 
+	minCostIterator = end();
+	for (iterator itr = begin(); itr != end(); itr++){
+		
+		OspfEqualPaths* ep=(*itr).second.findPtr(mtid);
+		 
+		if (ep!=NULL) {
+		  if ((minCost > ep->cost) && 
+		    !ep->nextHopList.empty()) {
+			minCost = ep->cost;
+			minCostIterator = itr;
+		  }
+                }
+	}         
+	return minCostIterator;
+}
+
+//**********************************************************************************
+// OspfTopoMap methods
+//**********************************************************************************
+
+//**********************************************************************************
+// insertLinkState method: insert a link state advertisement into the database 
+//**********************************************************************************
+OspfLinkStateList* OspfTopoMap::insertLinkState (int nodeId, OspfLinkState& link_state)
+{	
+	
+	OspfLinkStateList* lsp = OspfLinkStateMap::findPtr(nodeId);
+	if (lsp != NULL) {
+		// there's a node with other linkState, not checking if there's
+		// duplicate
+		lsp->push_back(link_state);
+		return lsp;
+	}
+
+	// else new node
+	OspfLinkStateList lsl; // an empty one
+	iterator itr = insert(nodeId,lsl);
+	if (itr != end()){
+		// successful
+		(*itr).second.push_back(link_state);
+		return &((*itr).second);
+	}
+	// else something is wrong
+	ls_error("OspfTopoMap::insertLinkState failed\n"); // debug
+	return (OspfLinkStateList *) NULL;
+
+
+}
+
+//**********************************************************************************
+// update method: update the database if necessary and return true if something is 
+//changed 
+//**********************************************************************************
+
+bool OspfTopoMap::update(int nodeId, 
+		       const OspfLinkStateList& linkStateAdvList)
+{
+	printf("OspfTopoMap update\n");
+	OspfLinkStateList * LSLAdvptr = findPtr (nodeId);
+
+	if (LSLAdvptr == NULL) {
+		insert(nodeId, linkStateAdvList);
+		return true;
+	}
+
+	//get the first advertising store in the db: in this implementation is the one used
+	OspfLinkState lsadold = LSLAdvptr->front();
+	RouterLinkStateList lslold= (*lsadold.RouterLinkStateListPtr_);
+	printf("OLD\n");
+	for (RouterLinkStateList::iterator itrList =lslold.begin();
+            itrList != lslold.end(); itrList++){
+
+		printf("Nodo vecino: %d ",(&(*itrList))->Link_ID_);
+		for (MTLinkList::iterator itrList2 = (&(*itrList))->MTLinkList_.begin();
+             itrList2 != (&(*itrList))->MTLinkList_.end(); itrList2++){
+		
+		printf("Mtid: %d Coste: %d\n",(&(*itrList2))->mtId_,(&(*itrList2))->metric_);
+
+		}	
+	}	
+	
+	OspfLinkState lsad = linkStateAdvList.front();
+	RouterLinkStateList* lslPtr_= lsad.RouterLinkStateListPtr_;
+	printf("NEW\n");
+	for (RouterLinkStateList::iterator itrList =lslPtr_->begin();
+            itrList != lslPtr_->end(); itrList++){
+
+		printf("Nodo vecino: %d ",(&(*itrList))->Link_ID_);
+		for (MTLinkList::iterator itrList2 = (&(*itrList))->MTLinkList_.begin();
+             itrList2 != (&(*itrList))->MTLinkList_.end(); itrList2++){
+		
+		printf("Mtid: %d Coste: %d\n",(&(*itrList2))->mtId_,(&(*itrList2))->metric_);
+
+		}	
+	}	
+	
+	bool retCode = false;
+	
+	RouterLinkStateList::iterator itrOld;
+	for (RouterLinkStateList::iterator itrNew = lslPtr_->begin();
+	     itrNew != lslPtr_->end(); itrNew++ ) {
+  
+		for (itrOld = lslold.begin();
+		     itrOld != lslold.end(); itrOld++) {
+			printf("OLD metric %d\n",(*itrOld).MT0_metric_);
+			printf("NEW metric %d\n",(*itrNew).MT0_metric_);
+			if((*itrOld).state_==LS_STATUS_DOWN)
+				continue;
+
+			if ((*itrNew).Link_ID_ == (*itrOld).Link_ID_) {
+				
+				// old link state found
+				if ((*itrNew).MT0_metric_!= (*itrOld).MT0_metric_) {
+					(*itrOld).MT0_metric_ = (*itrNew).MT0_metric_;
+					retCode = true;
+						
+					int nmtids= (*itrNew).Num_MT_;
+					for (int i=0; i<=nmtids; i++) {
+						for (MTLinkList::iterator 
+						itrListNew =(&(*itrNew))->MTLinkList_.begin();
+              					itrListNew != (&(*itrNew))->MTLinkList_.end();
+						itrListNew++){
+						
+						for (MTLinkList::iterator itrListOld = 
+						(&(*itrOld))->MTLinkList_.begin();
+              					itrListOld != (&(*itrOld))->MTLinkList_.end();
+						itrListOld++){
+														
+	        					if((&(*itrListNew))->mtId_==(&(*itrListOld))
+										  ->mtId_) {
+		   					(*itrListOld).metric_ = (*itrListNew).metric_;	
+							break;
+							} //fi
+
+						   }//for MTLinkList Old	
+
+	      					}// for MTLinkList New
+					
+					}// for nmtids
+			
+				    }// if mt0metric
+				
+				break; // no need to search for more old link state;
+			} // end if old link state found
+		} // end for old link states
+		if (itrOld == lslPtr_->end()) {
+			// no old link found
+			lslPtr_->push_back(*itrNew);
+			retCode = true;
+		}
+	}// end for new link states 
+
+	delLSA (nodeId,lsadold.ls_hdr_.LS_type_,
+					lsadold.ls_hdr_.LS_ID_,
+					lsadold.ls_hdr_.advertising_router_);
+	//update LSage and LS sequence number 
+	lsadold.ls_hdr_.LSage_=0;
+	lsadold.ls_hdr_.LS_sequence_num_+=1;
+	printf("seq number %f\n",lsadold.ls_hdr_.LS_sequence_num_);
+	lsadold.RouterLinkStateListPtr_=new RouterLinkStateList(lslold);
+	// insert the updated link state advertisement into the data base
+	insertLinkState(nodeId,lsadold);
+	
+		
+	return retCode;
+}
+
+
+//**********************************************************************************
+// updateRoutingTable method: returns true if it is necessary to calculate the 
+// routing table and false in other case	
+//**********************************************************************************
+
+bool OspfTopoMap::updateRoutingTable (int nodeId, OspfLinkState& linkStateAdv){
+
+
+	OspfLinkStateList * LSLAdvptr = findPtr (nodeId);
+
+	if (LSLAdvptr == NULL) {
+		//the LSA doesn't exist in the database
+		return true;
+	}
+			
+	bool retCode = false;
+	//new LSA
+	LinkStateHeader lshdrnew=linkStateAdv.ls_hdr_;
+
+	//get the LSA copy in the database
+	OspfLinkState lsadold=getLSA (lshdrnew.LS_type_,lshdrnew.LS_ID_,
+	lshdrnew.advertising_router_);
+		
+	//get LSA header in the database	
+	LinkStateHeader lshdrold=lsadold.ls_hdr_;
+
+	//compare LSA headers
+	//options field
+	if((lshdrold.options_.bit_T!=lshdrnew.options_.bit_T)||
+	   (lshdrold.options_.bit_E!=lshdrnew.options_.bit_E))
+		return true;
+	//LSage field
+	if(((lshdrold.LSage_=MAX_AGE)&&(lshdrnew.LSage_!=MAX_AGE))
+	||((lshdrnew.LSage_=MAX_AGE)&&(lshdrold.LSage_!=MAX_AGE)))
+		return true;
+
+	//Length field
+	if(((lshdrold.length_=MAX_AGE)&&(lshdrnew.length_!=MAX_AGE))
+	||((lshdrnew.length_=MAX_AGE)&&(lshdrold.length_!=MAX_AGE)))
+		return true;
+
+	//compare LSA contents
+	RouterLinkStateList* lsloldPtr_= lsadold.RouterLinkStateListPtr_;
+	RouterLinkStateList* lslPtr_= linkStateAdv.RouterLinkStateListPtr_;
+
+		
+	RouterLinkStateList::iterator itrOld;
+	for (RouterLinkStateList::iterator itrNew = lslPtr_->begin();
+	     itrNew != lslPtr_->end(); itrNew++ ) {
+  
+		for (itrOld = lsloldPtr_->begin();
+		     itrOld != lsloldPtr_->end(); itrOld++) {
+
+			if ((*itrNew).Link_ID_ == (*itrOld).Link_ID_) {
+				
+				// old link state found
+				if ((*itrNew).MT0_metric_!= (*itrOld).MT0_metric_) {
+					(*itrOld).MT0_metric_ = (*itrNew).MT0_metric_;
+					return true;
+								
+				    }// if mt0metric
+				
+				break; // no need to search for more old link state;
+			} // end if old link state found
+		} // end for old link states
+		if (itrOld == lslPtr_->end()) 
+			// no old link found
+			return true;
+	}// end for new link states 
+	
+	return retCode;
+}
+
+//***********************************************************************************
+// getLSList method: list all the link state advertisements stored in the database. 
+//***********************************************************************************
+
+OspfLinkStateList OspfTopoMap:: getLSList () {
+
+	OspfLinkStateList lsl;
+	
+	for (OspfLinkStateMap::iterator itrMap = begin();
+            itrMap != end(); itrMap++) {
+		for (OspfLinkStateList::iterator itrList = (*itrMap).second.begin();
+	            itrList!=(*itrMap).second.end(); itrList++) {
+			lsl.push_back(*itrList);	
+			
+		}
+	}
+
+	return lsl;
+}
+
+
+//**********************************************************************************
+// lookupLSA method: return NO_EXIST if the LSA does not exist, EQUALS if two 
+// instances are equal, OLDER if the LSA received is older than the database copy, 
+// and NEWER if is newer. 
+//**********************************************************************************
+
+retCode_t OspfTopoMap::lookupLSA (LinkStateHeader hdr){
+
+	retCode_t retCode=NO_EXIST;
+	LinkStateHeader lshdr;
+
+	for (OspfLinkStateMap::iterator itrMap = begin();
+            itrMap != end(); itrMap++) {
+		for (OspfLinkStateList::iterator itrList = (*itrMap).second.begin();
+	            itrList!=(*itrMap).second.end(); itrList++) {
+
+			lshdr=(*itrList).ls_hdr_;
+			if((hdr.LS_type_==lshdr.LS_type_)&&
+			   (hdr.LS_ID_==lshdr.LS_ID_)&&
+			   (hdr.advertising_router_==lshdr.advertising_router_)){
+			   //exists LSA in the database
+				printf("LSage LSA %f\n",hdr.LSage_);
+				printf("LSage %f\n",lshdr.LSage_);
+				printf("LSseq LSA %f\n",hdr.LS_sequence_num_);
+				printf("LSseq bd %f\n",lshdr.LS_sequence_num_);
+				
+			
+			   	if(hdr.LS_sequence_num_<lshdr.LS_sequence_num_){
+					//LSA received is older
+					printf("LSA received is older\n");
+					return OLDER;
+				}
+				
+				if(hdr.LS_sequence_num_>lshdr.LS_sequence_num_){
+					//LSA received is newer
+					printf("LSA received is newer\n");
+					return NEWER;
+				}
+				if(hdr.LS_sequence_num_==lshdr.LS_sequence_num_){
+		
+					if(hdr.LSage_==MAX_AGE)
+						return NEWER;
+					if(lshdr.LSage_==MAX_AGE)
+						return OLDER;
+					if((lshdr.LSage_-hdr.LSage_)>MAX_AGE_DIFF){
+						
+						if(hdr.LSage_<lshdr.LSage_)
+							return NEWER;
+						if(hdr.LSage_>lshdr.LSage_)
+							return OLDER;
+					}
+						
+					return EQUALS;				
+				}
+
+
+							
+			} 	 	
+		}
+	}
+
+	return retCode;
+}
+
+
+//**********************************************************************************
+// lookupLSA method: return true if the LSA exists and false if not 
+//**********************************************************************************
+
+bool OspfTopoMap::lookupLSA (LS_type_t ls_type, u_int32_t ls_id, u_int32_t advertising_router){
+
+	LinkStateHeader lshdr;
+	for (OspfLinkStateMap::iterator itrMap = begin();
+            itrMap != end(); itrMap++) {
+		for (OspfLinkStateList::iterator itrList = (*itrMap).second.begin();
+	            itrList!=(*itrMap).second.end(); itrList++) {
+
+			lshdr=(*itrList).ls_hdr_;
+			if((ls_type==lshdr.LS_type_)&&
+			   (ls_id==lshdr.LS_ID_)&&
+			   (advertising_router==lshdr.advertising_router_))
+			   //exists LSA in the database
+			   		return true;
+			
+			}
+		}
+	
+	return false;
+}
+
+
+//**********************************************************************************
+// getLSA method: get the link state advertisment indexed by the parameters
+//**********************************************************************************
+
+OspfLinkState OspfTopoMap::getLSA (LS_type_t ls_type, u_int32_t ls_id, u_int32_t advertising_router){
+
+	LinkStateHeader lshdr;
+	for (OspfLinkStateMap::iterator itrMap = begin();
+            itrMap != end(); itrMap++) {
+		for (OspfLinkStateList::iterator itrList = (*itrMap).second.begin();
+	            itrList!=(*itrMap).second.end(); itrList++) {
+
+			lshdr=(*itrList).ls_hdr_;
+			if((ls_type==lshdr.LS_type_)&&
+			   (ls_id==lshdr.LS_ID_)&&
+			   (advertising_router==lshdr.advertising_router_)){
+			   //exists LSA in the database
+				return (*itrList);
+		 }//end if	
+	     }
+	}
+	
+	return (OspfLinkState ());
+}
+
+
+//**********************************************************************************
+// incLSage method: increments LSA's LSage field for nodeId
+//**********************************************************************************
+
+void OspfTopoMap::incLSage (int nodeId){
+ 	
+	//OspfLinkStateMap::iterator itr= find(nodeId);
+	OspfLinkStateList * ptrLSLAd = findPtr(nodeId);
+
+	//get the first advertising: in this implementation is the one used
+	if (ptrLSLAd==NULL)
+		ls_error("OspfTopoMap::incLSage.\n");
+		
+
+	for (OspfLinkStateList::iterator itrList = ptrLSLAd->begin();
+	            itrList!=ptrLSLAd->end(); itrList++) {
+			printf("LSage: %f\n",(*itrList).ls_hdr_.LSage_);
+			(*itrList).ls_hdr_.LSage_+=1;
+			printf("LSage: %f\n",(*itrList).ls_hdr_.LSage_);
+			return;
+	}
+
+	
+}
+
+
+//**********************************************************************************
+// delLSA method: delete the LSA from the database 
+//**********************************************************************************
+
+void OspfTopoMap::delLSA (int nodeId, LS_type_t ls_type, u_int32_t ls_id, u_int32_t advertising_router){
+
+
+	OspfLinkStateList* lsl = OspfLinkStateMap::findPtr(nodeId);
+	LinkStateHeader lshdr;
+	
+	if (lsl!=NULL) {
+		for (OspfLinkStateList::iterator itrList = lsl->begin();
+	            itrList!=lsl->end(); itrList++) {
+
+			lshdr=(*itrList).ls_hdr_;
+			if((ls_type==lshdr.LS_type_)&&
+			   (ls_id==lshdr.LS_ID_)&&
+			   (advertising_router==lshdr.advertising_router_)){
+			   //exists LSA in the database: remove it
+				lsl->erase(itrList);
+				return;
+			}
+			   		
+			
+			}
+		}
+	
+}
+
+
+
+//**********************************************************************************
+// OspfMessageCenter methods
+//**********************************************************************************
+
+
+void OspfMessageCenter::init() 
+{
+	// only when nothing is provided by tcl code
+	max_size = 300;
+}
+
+//*********************************************************************************
+// newMessage method: create a new message of the type indicated as parameter
+//**********************************************************************************
+
+OspfMessage* OspfMessageCenter::newMessage (int senderNodeId, Ospf_message_type_t type)
+{
+	// check if max_message_number is invalid, call init ()
+	if (max_size == 0)
+		init(); 
+
+	message_storage* storagePtr;
+	u_int32_t currentId;
+	
+	//check the type to use a different storage
+	switch (type) {
+	case OSPF_MSG_INVALID:
+		ls_error("OSPF_MSG_INVALID "
+			 "OspfMessageCenter::newMessage.\n");
+		break;
+	case OSPF_MSG_HELLO:
+		storagePtr = & hello_messages;
+		if(current_hello_id==OSPF_WRAPAROUND_THRESHOLD)
+			current_hello_id=LS_INVALID_MESSAGE_ID;	
+		current_hello_id+=1;
+		printf("current_hello_id:%d\n",current_hello_id);
+		currentId = current_hello_id;
+		break;
+
+	case OSPF_MSG_DD:
+		storagePtr = & dd_messages;
+		if(current_dd_id==OSPF_WRAPAROUND_THRESHOLD)
+			current_dd_id=LS_INVALID_MESSAGE_ID;	
+		current_dd_id+=1;
+		printf("current_dd_id:%d\n",current_dd_id);
+		currentId = current_dd_id;
+		break;
+
+	case OSPF_MSG_REQUEST:
+		storagePtr = & request_messages;
+		if(current_request_id==OSPF_WRAPAROUND_THRESHOLD)
+			current_request_id=LS_INVALID_MESSAGE_ID;	
+		current_request_id+=1;
+		printf("current_request_id:%d\n",current_request_id);
+		currentId = current_request_id;
+		break;
+
+	case OSPF_MSG_UPDATE:
+		storagePtr = & update_messages;
+		if(current_update_id==OSPF_WRAPAROUND_THRESHOLD)
+			current_update_id=LS_INVALID_MESSAGE_ID;	
+		current_update_id+=1;
+		printf("current_update_id:%d\n",current_update_id);
+		currentId = current_update_id;
+		break;
+
+	case OSPF_MSG_ACK:
+		storagePtr = & ack_messages;
+		if(current_ack_id==OSPF_WRAPAROUND_THRESHOLD)
+			current_ack_id=LS_INVALID_MESSAGE_ID;	
+		current_ack_id+=1;
+		printf("current_ack_id:%d\n",current_ack_id);
+		currentId = current_ack_id;
+		break;
+
+	default:
+		// nothing, just to avoid compiler warning
+		break;
+	}
+	
+	// if max_size reached, recycle
+	if (storagePtr->size() >= max_size)
+		storagePtr->erase(storagePtr->begin());
+	
+	OspfMessage msg;
+	OspfMessage* msgPtr;
+	msg.messageId_=(u_int32_t)currentId;
+	msg.originNodeId_=senderNodeId;
+	
+	//insert the new message if could
+	message_storage::iterator itr = 
+		storagePtr->insert(currentId,msg); 
+				   	
+	if (itr == storagePtr->end())
+		ls_error("Can't insert new message in "
+			 "LsMessageCenter::newMessage.\n");
+	else
+		msgPtr = &((*itr).second);
+
+	//return the message address
+	return msgPtr;
+}
+
+
+//*********************************************************************************
+// deleteMessage method: delete the message of the type indicated as parameter
+//**********************************************************************************
+
+bool OspfMessageCenter::deleteMessage(u_int32_t msgId, Ospf_message_type_t type)
+{
+	
+	message_storage* storagePtr;
+	switch (type) {
+	case OSPF_MSG_INVALID:
+		ls_error("OSPF_MSG_INVALID "
+			 "OspfMessageCenter::deleteMessage.\n");
+		break;
+	case OSPF_MSG_HELLO:
+		storagePtr = &hello_messages;
+		break;
+
+	case OSPF_MSG_DD:
+		storagePtr = &dd_messages;
+		break;
+
+	case OSPF_MSG_REQUEST:
+		storagePtr = & request_messages;
+		break;
+
+	case OSPF_MSG_UPDATE:
+		storagePtr = & update_messages;
+		break;
+
+	case OSPF_MSG_ACK:
+		storagePtr = & ack_messages;
+		break;
+
+	default:
+		// nothing, just to avoid compiler warning
+		break;
+	}
+
+	message_storage::iterator itr = storagePtr->find (msgId); 
+	
+	if (itr == storagePtr->end())
+		return false;
+	storagePtr->erase(itr);
+		return true;
+
+}
+
+
+//*********************************************************************************
+// retrieveMessagePtr method: retreive message of the type indicated as parameter
+//**********************************************************************************
+
+OspfMessage* OspfMessageCenter::retrieveMessagePtr(u_int32_t msgId, Ospf_message_type_t type)
+{
+	OspfMessage * ospfmsgPtr;
+	
+	switch (type) {
+	case OSPF_MSG_INVALID:
+		ls_error("OSPF_MSG_INVALID "
+			 "OspfMessageCenter::retrieveMessage.\n");
+		break;
+	case OSPF_MSG_HELLO:
+		ospfmsgPtr=hello_messages.findPtr(msgId);
+		break;
+
+	case OSPF_MSG_DD:
+		ospfmsgPtr=dd_messages.findPtr(msgId);
+		break;
+
+	case OSPF_MSG_REQUEST:
+		ospfmsgPtr=request_messages.findPtr(msgId);
+		break;
+
+	case OSPF_MSG_UPDATE:
+		ospfmsgPtr=update_messages.findPtr(msgId);
+		break;
+
+	case OSPF_MSG_ACK:
+		ospfmsgPtr=ack_messages.findPtr(msgId);
+		break;
+
+	default:
+		ospfmsgPtr=NULL; // nothing, just to avoid compiler warning
+		break;
+	}	
+	
+	
+	return ospfmsgPtr;
+}
+
+
+//**********************************************************************************
+// OspfRetransmissionManager methods
+//**********************************************************************************
+
+//**********************************************************************************
+// initTimeout method: gets the delay time compute for each neighbour 
+//**********************************************************************************
+
+void OspfRetransmissionManager::initTimeout(LsDelayMap * delayMapPtr) 
+{
+	if (delayMapPtr == NULL)
+		return;
+	
+	for (LsDelayMap::iterator itr = delayMapPtr->begin();
+	     itr != delayMapPtr->end(); itr++)
+		// timeout is LS_TIMEOUT_FACTOR*one-way-delay estimate
+		insert((*itr).first, 
+		       OspfUnackPeer(this, (*itr).first, 
+				   OSPF_TIMEOUT_FACTOR*(*itr).second));
+}
+
+
+//**********************************************************************************
+// messageOut method: called by OspfRouting when a message is sent out
+//**********************************************************************************
+
+int OspfRetransmissionManager::messageOut(int peerId, const OspfMessage& msg,
+					Ospf_message_type_t type)
+{ 
+	OspfUnackPeer* peerPtr = findPtr(peerId);
+	
+	if (peerPtr == NULL) {
+		iterator itr = insert(peerId, OspfUnackPeer(this, peerId));
+		if (itr == end()) { 
+			ls_error ("Can't insert."); 
+		}
+		peerPtr = &((*itr).second);
+	}
+	
+	switch (type) {
+	case OSPF_MSG_DD:
+	{
+			printf("Message out: Peerid: %d send dd\n",peerId);
+			peerPtr->DdSeq_.msgId_=msg.messageId_;
+			peerPtr->DdSeq_.seq_=msg.DDPacketPtr_->DDSeqNumber_;
+			printf("Seq %f\n",peerPtr->DdSeq_.seq_);
+			
+	 		// reschedule timer to allow account for this latest message
+			printf("RxmTimeout:%f\n",peerPtr->rtxTimeout_);
+			peerPtr->ackTimer_.resched(peerPtr->rtxTimeout_);
+			
+	}
+			break;
+		
+	case OSPF_MSG_REQUEST:
+	{
+			printf("Message out: Peerid: %d send request\n",peerId);
+			peerPtr->ReqSeq_=msg.messageId_;
+			// reschedule timer to allow account for this latest message
+			peerPtr->ackTimer_.resched(peerPtr->rtxTimeout_);
+	}
+	    		break;
+
+	case OSPF_MSG_UPDATE:
+	{
+			printf("Message out: Peerid: %d send update\n",peerId);
+			u_int32_t* msgId = peerPtr->UpdateMap_.findPtr(msg.originNodeId_);
+			if (msgId == NULL){
+				peerPtr->UpdateMap_.insert(msg.originNodeId_,msg.messageId_);
+			}
+			else {
+				*msgId= msg.messageId_;
+			}
+			// reschedule timer to allow account for this latest message
+			peerPtr->updateTimer_.resched(peerPtr->rtxTimeout_);
+	}			
+			break;
+
+	case OSPF_MSG_INVALID:
+	case OSPF_MSG_HELLO:
+	case OSPF_MSG_ACK:
+	default:
+		// nothing, just to avoid compiler warning
+		break;
+	}
+ 
+	
+	return 0;
+}
+
+
+//**********************************************************************************
+// messageIn: Called by OspfRouting,  when a message that serves as ack is received
+//**********************************************************************************
+
+int OspfRetransmissionManager::messageIn(int peerId, const OspfMessage& msg,Ospf_message_type_t type)
+{
+	
+	OspfUnackPeer* peerPtr = findPtr(peerId);
+	if (peerPtr == NULL) {
+		printf("perrPtr NULL\n");
+		// no pending ack for this neighbor 
+		return 0;
+	}
+
+	int retCode=1; // 1--> ack incorrect: the message must be in the messageCenter
+		       // 0--> ack correct: the message should be removed from the messageCenter
+  
+	LsMap<int, u_int32_t>::iterator itr;
+
+	switch (type) {
+	case OSPF_MSG_DD:
+			printf("Message DD %d in: Peerid: %d\n",msg.messageId_,peerId);
+			printf("seq store %f seq pkt %f\n",peerPtr->DdSeq_.seq_,
+			msg.DDPacketPtr_->DDSeqNumber_);
+			printf("Message id %d\n",peerPtr->DdSeq_.msgId_);
+			
+			if (peerPtr->DdSeq_.seq_ == msg.DDPacketPtr_->DDSeqNumber_){
+			// We've got the right ack, so erase the unack record
+			printf("dd received ok\n");
+			peerPtr->DdSeq_.msgId_= LS_INVALID_MESSAGE_ID;
+			peerPtr->DdSeq_.seq_= LS_INVALID_MESSAGE_ID;
+			retCode=0;
+			}
+
+		if ((peerPtr->DdSeq_.seq_ == LS_INVALID_MESSAGE_ID) &&
+	    	(peerPtr->DdSeq_.msgId_ == LS_INVALID_MESSAGE_ID)&&	
+	    	(peerPtr->ReqSeq_== LS_INVALID_MESSAGE_ID)){
+		// No more pending ack, cancel timer
+		  peerPtr->ackTimer_.cancel();
+		}
+			
+			break;
+
+	case OSPF_MSG_UPDATE:
+			printf("Message update in: Peerid: %d\n",peerId);
+			peerPtr->ReqSeq_=LS_INVALID_MESSAGE_ID;
+			retCode=0;
+
+		if ((peerPtr->DdSeq_.seq_ == LS_INVALID_MESSAGE_ID) &&
+	    	(peerPtr->DdSeq_.msgId_ == LS_INVALID_MESSAGE_ID)&&	
+	    	(peerPtr->ReqSeq_== LS_INVALID_MESSAGE_ID)){
+		// No more pending ack, cancel timer
+		peerPtr->ackTimer_.cancel();
+		}
+	    		break;
+	
+	case OSPF_MSG_ACK:
+			printf("Message ack in: Peerid: %d\n",peerId);
+			itr = peerPtr->UpdateMap_.find(msg.originNodeId_);
+	
+			for (LsMap<int, u_int32_t>::iterator itr = peerPtr->UpdateMap_.begin();
+			itr != peerPtr->UpdateMap_.end(); ++itr) {
+				peerPtr->UpdateMap_.erase(itr);
+			}
+
+			if(peerPtr->UpdateMap_.empty()){
+				printf("cancel update timer\n");	
+				peerPtr->updateTimer_.cancel();
+			}
+			break;
+	
+	default:
+		break;
+	}
+	
+
+	return retCode;
+}
+
+
+//**********************************************************************************
+// cancelTimer: cancel ackTimer
+//**********************************************************************************
+
+void OspfRetransmissionManager::cancelTimer (int nbrId) 
+{
+	OspfUnackPeer* peerPtr = findPtr(nbrId);
+	if (peerPtr == NULL) 
+		return;
+	
+	peerPtr->DdSeq_.seq_ = LS_INVALID_MESSAGE_ID;
+	peerPtr->DdSeq_.msgId_ = LS_INVALID_MESSAGE_ID;
+	peerPtr->ReqSeq_= LS_INVALID_MESSAGE_ID;	 
+	peerPtr->UpdateMap_.eraseAll();
+	if(peerPtr->UpdateMap_.empty())
+		printf("UpdateMap empty\n");	
+	peerPtr->ackTimer_.force_cancel();
+	peerPtr->updateTimer_.force_cancel();
+	
+}
+
+
+//**********************************************************************************
+// resendMessages: resend all unack messages to the peer peerId
+//**********************************************************************************
+
+int OspfRetransmissionManager::resendMessages (int peerId) 
+{	
+	int nodo=OspfRouting_.getnodeid();
+	printf("[%f] NODO: %d\n",NOW,nodo);
+	printf("PeerId: %d RESEND MESSAGE\n",peerId);
+	bool updTimer=false;
+	
+	
+	OspfUnackPeer* peerPtr = findPtr (peerId);
+	if (peerPtr == NULL) 
+		// That's funny, We should never get in here
+		ls_error ("Wait a minute, nothing to send for this neighbor");
+	
+	// resend DD map
+	if (peerPtr->DdSeq_.seq_ != LS_INVALID_MESSAGE_ID){
+	
+	//get the ospf header	
+	hdr_Ospf hdrOspf =OspfRouting_.getOspfHeader (OSPF_MSG_DD,peerPtr->DdSeq_.msgId_);
+	OspfRouting_.resendMessage(peerId,hdrOspf);
+	
+	// reschedule retransmit timer
+	peerPtr->ackTimer_.resched(peerPtr->rtxTimeout_);
+	return 0;
+	}
+  	
+	//resend request
+	if (peerPtr->ReqSeq_!= LS_INVALID_MESSAGE_ID){
+	printf("resend Request\n");
+		
+	//get the ospf header	
+	hdr_Ospf hdrOspf =OspfRouting_.getOspfHeader (OSPF_MSG_REQUEST,peerPtr->ReqSeq_);
+	OspfRouting_.resendMessage(peerId,hdrOspf);
+	
+	// reschedule retransmit timer
+	peerPtr->ackTimer_.resched(peerPtr->rtxTimeout_);
+	return 0;
+	}
+  		
+	//resend update
+	// resend all other unack'ed LSA
+	for (LsMap<int, u_int32_t>::iterator itr = peerPtr->UpdateMap_.begin();
+		
+	     itr != peerPtr->UpdateMap_.end(); ++itr) {
+		hdr_Ospf hdrOspf =OspfRouting_.getOspfHeader (OSPF_MSG_UPDATE,(*itr).second);
+		printf("resend update \n");
+		OspfRouting_.resendMessage(peerId,hdrOspf);
+		updTimer=true;
+	}
+	
+	// reschedule retransmit timer if needed
+	if(updTimer){
+		
+		peerPtr->updateTimer_.resched(peerPtr->rtxTimeout_);
+	}
+	
+	return 0;
+}
+ 
+
+ 
+
+//**********************************************************************************
+// OspfInactivityManager methods
+//**********************************************************************************
+
+//**********************************************************************************
+// initTimeout method: set the delay time for each neighbour 
+//**********************************************************************************
+
+void OspfInactivityManager::initTimeout(LsNodeIdList* peerIdListPtr, double router_dead_interval) 
+{
+	if (peerIdListPtr== NULL)
+		return; 
+
+	for (LsNodeIdList::iterator itr = peerIdListPtr->begin();
+	     itr != peerIdListPtr->end(); itr++)
+		
+		insert(*itr,OspfHelloPeer(this,*itr,router_dead_interval));
+}
+
+
+//**********************************************************************************
+// messageOut method: called by OspfRouting when a hello message is sent out
+//**********************************************************************************
+
+int OspfInactivityManager::messageOut(int peerId, Ospf_message_type_t type)
+{ 
+	OspfHelloPeer* peerPtr = findPtr(peerId);
+
+	//init the timer the first time
+	if (peerPtr == NULL) {
+		
+		iterator itr = insert(peerId, OspfHelloPeer(this, peerId));
+		if (itr == end()) { 
+			ls_error ("Can't insert."); 
+		}
+		peerPtr = &((*itr).second);
+	
+	
+	printf("OspfInactivityTimer MessageOut peerId %d\n",peerId);
+	switch (type) {
+	case OSPF_MSG_HELLO:
+			peerPtr->inactivityTimer_.resched(peerPtr->routerDeadInterval_);
+			
+		break;
+		
+	default:
+		// nothing, just to avoid compiler warning
+		break;
+		}
+ 	}
+	return 0;
+}
+
+
+//**********************************************************************************
+// messageIn: Called by OspfRouting,  when a hello message is received
+//**********************************************************************************
+
+int OspfInactivityManager::messageIn(int peerId, Ospf_message_type_t type)
+{
+	
+	OspfHelloPeer* peerPtr = findPtr(peerId);
+	if (peerPtr == NULL) {
+		printf("perrPtr NULL\n");
+		return 0;
+	}
+	
+	printf("OspfInactivityTimer Messagein peerId %d\n",peerId);
+
+	switch (type) {
+	case OSPF_MSG_HELLO:	
+			peerPtr->inactivityTimer_.resched(peerPtr->routerDeadInterval_);
+			
+			break;
+	default:
+		break;
+	}
+	
+	return 0;
+}
+
+
+//**********************************************************************************
+// cancelTimer: cancel ackTimer
+//**********************************************************************************
+
+void OspfInactivityManager::cancelTimer (int nbrId) 
+{
+	OspfHelloPeer* peerPtr = findPtr(nbrId);
+
+	if (peerPtr == NULL)
+		return;
+	
+	
+	peerPtr->inactivityTimer_.force_cancel();
+	
+}
+
+
+//**********************************************************************************
+// setNeighbourDown: call to inactivityTimer event
+//**********************************************************************************
+
+int OspfInactivityManager::setNeighbourDown (int peerId) 
+{
+	int nodo=OspfRouting_.getnodeid();
+	
+	printf("NODO: %d\n",nodo);
+	printf("PeerId: %d EXPIRE INACTIVITY TIMER\n",peerId);
+	
+	//the inactivity timer for peerId is fired
+	OspfRouting_.inactivityTimerEvent(peerId);
+	
+	return 0;
+}
+ 
+
+
+//**********************************************************************************
+// LsAgingManager  methods
+//**********************************************************************************
+
+//**********************************************************************************
+// initTimeout method: set the delay time for the node 
+//**********************************************************************************
+
+void LsAgingManager ::initTimeout(int nodeId) 
+{
+		
+	insert(nodeId,LSAPeer(this,nodeId,1));
+}
+
+
+//**********************************************************************************
+// createLSA method: called by OspfRouting when a LSA is create or inserted in the
+// database
+//**********************************************************************************
+
+int LsAgingManager ::createLSA (int peerId)
+{ 
+	LSAPeer* peerPtr = findPtr(peerId);
+	
+	if (peerPtr == NULL) {
+		iterator itr = insert(peerId, LSAPeer(this, peerId));
+		if (itr == end()) { 
+			ls_error ("Can't insert."); 
+		}
+		peerPtr = &((*itr).second);
+	}
+	//schedule the timer
+	peerPtr->LsTimer_.resched(peerPtr->LsAgingInterval_);
+			 	
+	return 0;
+}
+
+//**********************************************************************************
+// cancelTimer method: cancel LsAging Timer
+//**********************************************************************************
+
+void LsAgingManager::cancelTimer (int nbrId) 
+{
+	LSAPeer* peerPtr = findPtr(nbrId);
+	if (peerPtr == NULL) 
+		return;
+
+	peerPtr->LsTimer_.force_cancel();
+	
+}
+
+
+//**********************************************************************************
+// ageLSA method: do the LSA aging
+//**********************************************************************************
+
+int LsAgingManager::ageLSA (int nodeId) 
+{
+	int nodo=OspfRouting_.getnodeid();
+
+	printf("[%f]Nodo:%d peerId: %d EXPIRE LSAGING TIMER\n",NOW,nodo,nodeId);
+	
+	
+	LSAPeer* peerPtr = findPtr(nodeId);
+	if (peerPtr == NULL) 
+		return 0;
+	
+	//the lsAging timer for peerId is fired
+	if(OspfRouting_.ageLSA (nodeId)){
+		//reschedule the timer
+		peerPtr->LsTimer_.resched(peerPtr->LsAgingInterval_);
+	}	
+	return 0;
+}
+ 
+
+//**********************************************************************************
+// OspfNeighbourMap methods 
+//**********************************************************************************
+
+//**********************************************************************************
+// initNeighbour method: initialize the structure 
+//**********************************************************************************
+
+void OspfNeighbourMap:: initNeighbour (LsNodeIdList* peerIdListPtr)
+{
+	OspfNeighbour ndata;
+	
+	for (LsNodeIdList::iterator itrList = peerIdListPtr->begin();
+            itrList != peerIdListPtr->end(); itrList++){
+		
+		insert(*itrList,ndata);
+	}
+
+}
+
+
+//**********************************************************************************
+// isState method: returns true if the neighbour nbId has the same state passed as 
+// parameter or false in other case 
+//**********************************************************************************
+
+bool OspfNeighbourMap::isState (int nbId,StateN_type_t state)
+{
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::isState?: nbPtr null\n");
+	
+	if (nbPtr->state_==state) 
+		return true;
+	
+	return false;
+}
+
+
+//**********************************************************************************
+// setState method: set the state of the neighbour nbId to newState 
+//**********************************************************************************
+
+void OspfNeighbourMap::setState (int nbId, StateN_type_t newState)
+
+{
+	
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::setState: nbPtr null\n");
+	
+	nbPtr->state_=newState; 
+}
+
+//**********************************************************************************
+// getState method: returns neighbour nbId state 
+//**********************************************************************************
+
+StateN_type_t OspfNeighbourMap::getState (int nbId)
+{
+
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::isState?: nbPtr null\n");
+	
+	return (nbPtr->state_); 
+		
+}
+
+
+//**********************************************************************************
+// setNeighbourId method: set the neighbour id of the neighbour nbId 
+//**********************************************************************************
+
+void OspfNeighbourMap::setNeighbourId (int nbId)
+{
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::setNeighbourId: nbPtr null\n");
+	
+	nbPtr->neighbourId_=nbId; 
+	
+}
+
+
+//**********************************************************************************
+// getNeighbourId method: returns neighbour nbId 
+//**********************************************************************************
+
+int OspfNeighbourMap::getNeighbourId (int nbId)
+{
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::getNeighbourId: nbPtr null\n");
+	
+	return (nbPtr->neighbourId_); 
+	
+}
+
+
+//**********************************************************************************
+// setOptions method: set neighbour nbId options 
+//**********************************************************************************
+
+void OspfNeighbourMap::setOptions(options_t op,int nbId)
+{
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::setOptions: nbPtr null\n");
+	
+	nbPtr->options_=op; 
+	
+}
+
+
+//**********************************************************************************
+// getOptions method: returns neighbour nbId options 
+//**********************************************************************************
+
+options_t OspfNeighbourMap::getOptions(int nbId)
+{
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::getOptions: nbPtr null\n");
+	
+	return(nbPtr->options_); 
+	
+}
+  
+//**********************************************************************************
+// setDDseq method:  set neighbour nbId DDseq to seq
+//**********************************************************************************
+
+void OspfNeighbourMap::setDDseq (int nbId, double seq){
+	
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::setDDseq: nbPtr null\n");
+	
+	nbPtr->ddSeq_=seq; 
+}
+  
+//**********************************************************************************
+// incDDseq method:  increment neighbour nbId DDseq
+//**********************************************************************************
+
+void OspfNeighbourMap::incDDseq (int nbId){
+
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::setDDseq: nbPtr null\n");
+	
+	if(nbPtr->ddSeq_==LS_INVALID_MESSAGE_ID) {
+		//the first time set a new value never seen before (time of simulation)
+		nbPtr->ddSeq_=NOW;
+	} 
+
+	nbPtr->ddSeq_+=1;
+	printf("DDseq %f\n",nbPtr->ddSeq_);
+}
+
+//**********************************************************************************
+// getDDseq method: returns neighbour nbId DDseq 
+//**********************************************************************************
+
+double OspfNeighbourMap::getDDseq(int nbId){
+
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::getDDseq: nbPtr null\n");
+
+	return (nbPtr->ddSeq_);
+}
+  
+//**********************************************************************************
+// setMaster method: set neighbour nbId masterSlave bit to master 
+//**********************************************************************************
+
+void OspfNeighbourMap::setMaster (int nbId){
+
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::setMaster: nbPtr null\n");
+	
+	//set the master/slave bit to Master
+	nbPtr->masterSlave_=1;
+}
+
+//**********************************************************************************
+// setSlave method: set neighbour nbId masterSlave bit to slave 
+//**********************************************************************************
+
+void OspfNeighbourMap::setSlave (int nbId) {
+
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::setMaster: nbPtr null\n");
+	
+	//set the master/slave bit to Slave
+	nbPtr->masterSlave_=0;
+
+
+}
+
+//**********************************************************************************
+// getMasterSlave method: returns neighbour nbId masterSlave bit 
+//**********************************************************************************
+
+char OspfNeighbourMap::getMasterSlave (int nbId){
+
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::setMaster: nbPtr null\n");
+	
+	return(nbPtr->masterSlave_);	
+}
+
+
+//**********************************************************************************
+// delAllLists method: delete all neighbour's lists 
+//**********************************************************************************
+
+void OspfNeighbourMap::delAllLists (int nbId){
+
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::delallLists: nbPtr null\n");
+
+	
+	if(!nbPtr->lsHeaderList_.empty())
+		nbPtr->lsHeaderList_.eraseAll();
+
+	if(nbPtr->lsRetransmissionList_.empty()) {
+	nbPtr->lsRetransmissionList_.eraseAll();
+	}
+
+	if(!nbPtr->lsRequestList_.empty()) {
+	nbPtr->lsRequestList_.eraseAll();
+	}
+
+}
+
+
+//**********************************************************************************
+// setLinkStateHeaderList method: set the link state header list in the neighbour
+// structure for the neighbour nbId
+//**********************************************************************************
+
+void OspfNeighbourMap::setLinkStateHeaderList (int nbId,LinkStateHeaderList& lshdrl){
+
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::setLinkStateHeaderList: nbPtr null\n");
+	nbPtr->lsHeaderList_=lshdrl;
+}
+
+//**********************************************************************************
+// getLinkStateHeaderList method: returns the link state header list in the neighbour
+// structure for the neighbour nbId
+//**********************************************************************************
+
+LinkStateHeaderList OspfNeighbourMap::getLinkStateHeaderList (int nbId){
+
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::getLinkStateHeaderList: nbPtr null\n");
+	
+	return nbPtr->lsHeaderList_;
+}
+
+
+//**********************************************************************************
+// setLinkStateRetransList method: set the link state summary list in the neighbour
+// structure for the neighbour nbId
+//**********************************************************************************
+
+void OspfNeighbourMap::setLinkStateRetransList (int nbId,OspfLinkStateList& lsl) {
+	
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::setLinkStateRetransList: nbPtr null\n");
+	
+	nbPtr->lsRetransmissionList_=lsl;
+}
+
+
+//**********************************************************************************
+// getLinkStateRetransList method: returns  the link state summary list in the neighbour
+// structure for the neighbour nbId
+//**********************************************************************************
+
+OspfLinkStateList OspfNeighbourMap::getLinkStateRetransList (int nbId){
+	
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::setLinkStateRetransList: nbPtr null\n");
+	
+	return (nbPtr->lsRetransmissionList_);
+}
+
+//**********************************************************************************
+// lookupLSARetrans method: returns true if the LSA is in the retransmission list
+// and false in other case
+//**********************************************************************************
+
+bool OspfNeighbourMap::lookupLSARetrans (int nbId,LinkStateHeader& lshdr){
+
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::lookupLSARetrans: nbPtr null\n");
+
+	for(OspfLinkStateList::iterator itr=nbPtr->lsRetransmissionList_.begin();
+	itr!=nbPtr->lsRetransmissionList_.end();itr++) {
+		if((lshdr.LS_type_==(*itr).ls_hdr_.LS_type_)
+		&&(lshdr.LS_ID_==(*itr).ls_hdr_.LS_ID_)
+		&&(lshdr.advertising_router_==(*itr).ls_hdr_.advertising_router_)){
+			return true;
+		}		
+	}
+	return false;
+}
+
+
+//**********************************************************************************
+// delLSARetrans method: remove LSA from Retransmission list
+//**********************************************************************************
+
+bool OspfNeighbourMap::delLSARetrans (int nbId, LinkStateHeader& lshdr){
+OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::delLSARetrans: nbPtr null\n");
+
+	if(!nbPtr->lsRetransmissionList_.empty()){
+	
+	for(OspfLinkStateList::iterator itr=nbPtr->lsRetransmissionList_.begin();
+	itr!=nbPtr->lsRetransmissionList_.end();itr++) {
+		if((lshdr.LS_type_==(*itr).ls_hdr_.LS_type_)
+		&&(lshdr.LS_ID_==(*itr).ls_hdr_.LS_ID_)
+		&&(lshdr.advertising_router_==(*itr).ls_hdr_.advertising_router_)){
+			nbPtr->lsRetransmissionList_.erase(itr);	
+			return true;		
+		}		
+	}
+	
+	}
+
+	return false;
+}
+
+//**********************************************************************************
+// addLSARetrans method: add LSA to Retransmission list
+//**********************************************************************************
+
+void OspfNeighbourMap::addLSARetrans (int nbId, OspfLinkState& ls){
+
+
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::addLSARetrans: nbPtr null\n");
+
+	nbPtr->lsRetransmissionList_.push_back(ls);
+
+}
+
+//**********************************************************************************
+// setRequestList method: set the link state request list in the neighbour
+// structure for the neighbour nbId
+//**********************************************************************************
+
+void OspfNeighbourMap::setRequestList (int nbId, LinkStateRecordIdList& lsr) {
+
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::setRequestList: nbPtr null\n");
+	
+	nbPtr->lsRequestList_=lsr;
+}
+
+
+//**********************************************************************************
+// getRequestList method: returns the link state request list in the neighbour
+// structure for the neighbour nbId
+//**********************************************************************************
+
+LinkStateRecordIdList OspfNeighbourMap::getRequestList (int nbId){
+
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::getRequestList: nbPtr null\n");
+	
+	return nbPtr->lsRequestList_;
+}
+
+
+//**********************************************************************************
+// delLSARequest method: returns true if the LSA is in the request list
+// and false in other case
+//**********************************************************************************
+
+void OspfNeighbourMap::delLSARequest (int nbId, LinkStateHeader& lshdr){
+
+	OspfNeighbour* nbPtr=findPtr(nbId);
+
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::delLSARetrans: nbPtr null\n");
+
+		
+	if(!nbPtr->lsRequestList_.empty()){
+		
+		for(LinkStateRecordIdList::iterator itr=nbPtr->lsRequestList_.begin();
+		itr!=nbPtr->lsRequestList_.end();itr++) {
+				
+			if((lshdr.LS_type_==(*itr).type_)
+			&&(lshdr.LS_ID_==(*itr).lsID_)
+			&&(lshdr.advertising_router_==(*itr).advertisingRouter_)){
+				nbPtr->lsRequestList_.erase(itr);
+				return;
+					
+			}		
+		}
+	}
+
+}
+
+
+//**********************************************************************************
+// lookupLSAReq method: remove LSA from Request list
+//**********************************************************************************
+
+bool OspfNeighbourMap::lookupLSAReq (int nbId, LinkStateHeader& lshdr){
+
+	OspfNeighbour* nbPtr=findPtr(nbId);
+	if (nbPtr==NULL)
+		ls_error("OspfNeighbourMap::lookupLSAReq: nbPtr null\n");
+
+	for(LinkStateRecordIdList::iterator itr=nbPtr->lsRequestList_.begin();
+	itr!=nbPtr->lsRequestList_.end();itr++) {
+		if((lshdr.LS_type_==(*itr).type_)
+		&&(lshdr.LS_ID_==(*itr).lsID_)
+		&&(lshdr.advertising_router_==(*itr).advertisingRouter_)){
+			return true;
+		}		
+	}
+	return false;
+
+}
+
+//**********************************************************************************
+// OspfRouting methods
+//**********************************************************************************
+
+//**********************************************************************************
+// init method: initialize the routing structure
+//**********************************************************************************
+
+bool OspfRouting::init(OspfNode * nodePtr) 
+{
+	
+	if (nodePtr == NULL) 
+		return false;
+	
+	myNodePtr_ = nodePtr;
+	myNodeId_ = myNodePtr_->getNodeId();
+
+	//my peers
+	peerIdListPtr_ = myNodePtr_->getPeerIdListPtr();
+	//my link states
+	linkStateListPtr_ = myNodePtr_->getLinkStateListPtr();
+	//hello interval: defined in tcl
+	helloInterval_=myNodePtr_->getHelloInterval();
+	//router dead interval: defined in tcl
+	routerDeadInterval_=myNodePtr_->getRouterDeadInterval();
+	//create my own link state
+	OspfLinkState ls;
+	ls.ls_hdr_.LSage_=0;
+	ls.ls_hdr_.options_=options_t(1,0);
+	ls.ls_hdr_.LS_type_=LS_ROUTER;
+	ls.ls_hdr_.LS_ID_=myNodeId_;
+	ls.ls_hdr_.LS_sequence_num_=0;
+	ls.ls_hdr_.advertising_router_=myNodeId_;	
+	ls.RouterLinkStateListPtr_=linkStateListPtr_;
+	
+	linkStateDatabase_.setNodeId(myNodeId_);
+	//at first, the topo data base only has my own links' states
+	if (linkStateListPtr_ != NULL) 
+		linkStateListAdvPtr_=linkStateDatabase_.insertLinkState(myNodeId_,ls);
+	
+	
+	//initialize delay map:
+	delayMapPtr_ = myNodePtr_->getDelayMapPtr();
+	if (delayMapPtr_ != NULL) {
+		//initialize ack timer length
+		AckManager_.initTimeout(delayMapPtr_);
+	 }
+	
+	//initialize neighbour's structure
+	neighbourData_.initNeighbour (peerIdListPtr_);
+	//initialize inactivity timer length
+	InactivityManager_.initTimeout(peerIdListPtr_,routerDeadInterval_);
+	//initialize lsAging timer
+	AgingManager_.initTimeout(myNodeId_);
+	//active lsAging timer
+	AgingManager_.createLSA (myNodeId_);
+			
+	return true;
+}  
+
+//**********************************************************************************
+// linkStateChanged method: check and update the link state database  
+//**********************************************************************************
+
+void OspfRouting::linkStateChanged () 
+{
+	if (linkStateListPtr_ == NULL)
+		ls_error("OspfRouting::linkStateChanged: linkStateListPtr null\n");
+   	
+	OspfLinkStateList* oldLsAdvPtr = linkStateDatabase_.findPtr(myNodeId_);
+	
+	if (oldLsAdvPtr == NULL) 
+		// Should never happen,something's wrong, we didn't 
+		// initialize properly
+		ls_error("OpfRouting::linkStateChanged: oldLsAdvPtr null!!\n");
+
+	OspfLinkState lsad = oldLsAdvPtr->front();
+	
+	//get the new linkStateList
+	linkStateListPtr_=myNodePtr_->getLinkStateListPtr();
+	
+	printf("LINKSTATECHANGED\n");
+	OspfLinkState ls;
+	ls.ls_hdr_.LSage_=0;
+	ls.ls_hdr_.options_=options_t(1,0);
+	ls.ls_hdr_.LS_type_=LS_ROUTER;
+	ls.ls_hdr_.LS_ID_=myNodeId_;
+	ls.ls_hdr_.LS_sequence_num_=lsad.ls_hdr_.LS_sequence_num_;
+	ls.ls_hdr_.advertising_router_=myNodeId_;	
+	ls.RouterLinkStateListPtr_=linkStateListPtr_;
+	//erase my old link state advertisement
+	linkStateListAdvPtr_->eraseAll();
+	linkStateListAdvPtr_->push_back(ls);
+	
+	
+	// if there's any changes, compute new routes and send link states
+	linkStateDatabase_.update(myNodeId_, *linkStateListAdvPtr_);
+	 computeRoutes(); //a changed has happened: compute routes
+	//send LSA changed
+	sendLSAToAdyacents(LS_ROUTER ,myNodeId_,myNodeId_,myNodeId_);
+
+		
+}
+
+//**********************************************************************************
+// interfaceChanged method: update the active interfaces list  
+//**********************************************************************************
+
+void OspfRouting::interfaceChanged (){
+
+	peerIdListPtr_ = myNodePtr_->getPeerIdListPtr();
+}
+
+
+//**********************************************************************************
+// sendHellos method: send hello packets to every peer node  
+//**********************************************************************************
+
+bool OspfRouting::sendHellos() 
+{
+	
+	if (myNodePtr_ == NULL)
+		return false;
+	if ((peerIdListPtr_ == NULL) || peerIdListPtr_->empty())
+		return false;
+
+	printf("[%f] SEND HELLOS:Node:%d\n",NOW,myNodeId_);
+	
+	//create and store a new hello message
+	OspfMessage* msgPtr = msgctr().newMessage(myNodeId_, OSPF_MSG_HELLO);
+	
+	if (msgPtr == NULL) 
+		return false; // can't get new message
+		
+	u_int32_t msgId = msgPtr->messageId_;
+	HelloPacket hellopkt = getHelloPkt();
+	
+	HelloPacket* packetPtr = new HelloPacket(hellopkt);
+	if (packetPtr == NULL) {
+		ls_error ("Can't get new hello packet, in OspfRouting::sendHellos\n");
+		// can't get new link state list
+		msgctr().deleteMessage(msgId,OSPF_MSG_HELLO);
+		return false;
+	}
+
+	msgPtr->HelloPacketPtr_ = packetPtr;
+
+	
+	printf("Send hellos: LISTA VECINOS Nodo %d:\n",myNodeId_);
+	for (LsNodeIdList::iterator itrList = hellopkt.neighbourListPtr_->begin();
+	     itrList != hellopkt.neighbourListPtr_->end(); itrList++) {
+		printf("Nodo vecino: %d\n",*itrList);
+	}
+	
+	//get the ospf header	
+	hdr_Ospf hdrOspf =getOspfHeader (OSPF_MSG_HELLO,msgId);
+	
+	for (LsNodeIdList::iterator itr = peerIdListPtr_->begin();
+	     itr != peerIdListPtr_->end(); itr++) {
+
+		if(neighbourData_.isState((*itr),DOWN)) {
+			neighbourData_.setState((*itr),ATTEMPT);
+			InactivityManager_.messageOut((*itr),hdrOspf.type_);
+		        
+		}
+		
+		  myNodePtr_->sendMessage((*itr), hdrOspf);	
+		
+	}
+
+	return true;
+}
+
+
+//**********************************************************************************
+// sendDD method: send dd packets to neihgbourId  
+//**********************************************************************************
+
+void OspfRouting::sendDD (int neighbourId){
+
+	printf("[%f] SEND DD Node:%d\n",NOW,myNodeId_);
+	
+	//create and store a new dd message
+	OspfMessage* msgPtr = msgctr().newMessage(myNodeId_, OSPF_MSG_DD);
+	
+	if (msgPtr == NULL) 
+		return; // can't get new message
+		
+	u_int32_t msgId = msgPtr->messageId_;
+	DDPacket ddpkt = getDdPkt(neighbourId);
+	
+
+	DDPacket* packetPtr = new DDPacket(ddpkt);
+	if (packetPtr == NULL) {
+		ls_error ("Can't get new dd packet, in OspfRouting::sendDD\n");
+		// can't get new link state list
+		msgctr().deleteMessage(msgId,OSPF_MSG_DD);
+		return;
+	}
+	
+	msgPtr->DDPacketPtr_ = packetPtr;
+
+	if(ddpkt.lsHeaderListPtr_!=NULL){
+	//printf("Send DD: Ls sequence number DEL PAQUETE enviado por  Nodo %d:\n",myNodeId_);
+	//printf("Ls secuence number: %f \n",ddpkt.DDSeqNumber_);
+	for (LinkStateHeaderList::iterator itrList = ddpkt.lsHeaderListPtr_->begin();
+	     itrList != ddpkt.lsHeaderListPtr_->end(); itrList++) {
+		printf("Ls advertising: %d \n",(*itrList).advertising_router_);
+	}
+	}
+	
+	//get the ospf header	
+	hdr_Ospf hdrOspf =getOspfHeader (OSPF_MSG_DD,msgId);
+	if((neighbourData_.getMasterSlave (neighbourId))&&
+	(!neighbourData_.isState(neighbourId,EX_START))){
+ 	//I'm the master and my neighbour is not EX_START: active ack retransmission timer for the
+	// neighbour
+	
+	AckManager_.messageOut(neighbourId,*msgPtr,hdrOspf.type_);
+	}
+
+	//send DD message
+	myNodePtr_->sendMessage(neighbourId, hdrOspf);	
+	
+
+}
+
+
+//**********************************************************************************
+// sendRequest method: send request packets to neihgbourId  
+//**********************************************************************************
+
+void OspfRouting::sendRequest (int neighbourId) {
+
+	printf("[%f] SEND Request Node:%d\n",NOW,myNodeId_);
+	
+	//create and store a new request message
+	OspfMessage* msgPtr = msgctr().newMessage(myNodeId_, OSPF_MSG_REQUEST);
+	
+	if (msgPtr == NULL) 
+		return; // can't get new message
+		
+	u_int32_t msgId = msgPtr->messageId_;
+	RequestPacket reqpkt = getRequestPkt(neighbourId);
+	
+
+	RequestPacket* packetPtr = new RequestPacket(reqpkt);
+	if (packetPtr == NULL) {
+		ls_error ("Can't get new request packet, in OspfRouting::sendRequest\n");
+		// can't get new link state list
+		msgctr().deleteMessage(msgId,OSPF_MSG_REQUEST);
+		return;
+	}
+
+        //
+	/*if(reqpkt.linkStateRecordIdListPtr_!=NULL){
+	printf("Send Request: enviado por nodo:%d:\n",myNodeId_);
+	for (LinkStateRecordIdList::iterator itrList = reqpkt.linkStateRecordIdListPtr_->begin();
+	     itrList != reqpkt.linkStateRecordIdListPtr_->end(); itrList++) {
+		printf("Ls type:%d Lsid:%d advertising router:%d \n",(*itrList).type_,(*itrList).lsID_,
+		(*itrList).advertisingRouter_);
+		}
+	}*/
+	//
+
+	msgPtr->RequestPacketPtr_ = packetPtr;
+	hdr_Ospf hdrOspf =getOspfHeader (OSPF_MSG_REQUEST,msgId);
+	
+	//Active ack retransmission timer for the neighbour
+	AckManager_.messageOut(neighbourId,*msgPtr,hdrOspf.type_);
+	
+
+	//send REQUEST message
+	myNodePtr_->sendMessage(neighbourId, hdrOspf);	
+}
+
+
+//**********************************************************************************
+// sendUpdate method: send update packet to neihgbourId  
+//**********************************************************************************
+
+void OspfRouting::sendUpdate(int originNodeId, int neighbourId,UpdatePacket& updpkt){
+
+	printf("[%f] SEND Update Node:%d\n",NOW,myNodeId_);
+	
+	//create and store a new update message
+	OspfMessage* msgPtr = msgctr().newMessage(originNodeId, OSPF_MSG_UPDATE);
+	
+	if (msgPtr == NULL) 
+		return; // can't get new message
+		
+	u_int32_t msgId = msgPtr->messageId_;
+	
+	UpdatePacket* packetPtr = new UpdatePacket(updpkt);
+	if (packetPtr == NULL) {
+		ls_error ("Can't get new request packet, in OspfRouting::sendUpdate\n");
+		// can't get new link state list
+		msgctr().deleteMessage(msgId,OSPF_MSG_UPDATE);
+		return;
+	}
+
+        //PRUEBA
+	/*
+	if(updpkt.LsListAdvertPtr_!=NULL){
+	printf("Send Update: enviado por nodo:%d:\n",myNodeId_);
+	printf("Numero de advertisement:%d:\n",updpkt.numberAdvert_);
+
+	for (OspfLinkStateList::iterator itrList = updpkt.LsListAdvertPtr_->begin();
+	     itrList != updpkt.LsListAdvertPtr_->end(); itrList++) {
+		printf("advertising router:%d \n",(*itrList).ls_hdr_.advertising_router_);
+		printf("lsage: %f\n",(*itrList).ls_hdr_.LSage_);
+			
+		for (RouterLinkStateList::iterator itrList2 = (*itrList).RouterLinkStateListPtr_->begin();
+	     	itrList2 != (*itrList).RouterLinkStateListPtr_->end(); itrList2++) {
+		printf("Link id:%d \n",(*itrList2).Link_ID_);
+		printf("State: %d\n",(*itrList2).state_);
+
+			for (MTLinkList::iterator itrList3 = (*itrList2).MTLinkList_.begin();
+             itrList3 != (*itrList2).MTLinkList_.end(); itrList3++){
+		
+		printf("Mtid: %d Coste: %d\n",(*itrList3).mtId_,(*itrList3).metric_);
+			}
+		}
+
+		}
+	}*/
+	//
+
+	msgPtr->UpdatePacketPtr_ = packetPtr;
+	hdr_Ospf hdrOspf =getOspfHeader (OSPF_MSG_UPDATE,msgId);
+
+	//Active ack retransmission timer for the neighbour
+	AckManager_.messageOut(neighbourId,*msgPtr,hdrOspf.type_);
+	
+
+	//send UPDATE message
+	myNodePtr_->sendMessage(neighbourId, hdrOspf);	
+	
+}
+
+//**********************************************************************************
+// sendAck method: send acknowledge packet to neihgbourId  
+//**********************************************************************************
+
+void OspfRouting::sendAck (int neighbourId, int originNodeIdAck, LinkStateHeaderList& lshdrl){
+
+	printf("[%f] SEND Ack Node:%d\n",NOW,myNodeId_);
+	
+	//create and store a new dd message
+	OspfMessage* msgPtr = msgctr().newMessage(originNodeIdAck, OSPF_MSG_ACK);
+	
+	if (msgPtr == NULL) 
+		return; // can't get new message
+	
+	AckPacket ackpkt;	
+	u_int32_t msgId = msgPtr->messageId_;
+	
+	LinkStateHeaderList* lshdrlPtr= new LinkStateHeaderList (lshdrl);
+	ackpkt.lsHeaderListPtr_=lshdrlPtr;
+	AckPacket* packetPtr = new AckPacket(ackpkt);
+	if (packetPtr == NULL) {
+		ls_error ("Can't get new request packet, in OspfRouting::sendUpdate\n");
+		// can't get new link state list
+		msgctr().deleteMessage(msgId,OSPF_MSG_ACK);
+		return;
+	}
+
+	msgPtr->AckPacketPtr_ = packetPtr;
+	hdr_Ospf hdrOspf =getOspfHeader (OSPF_MSG_ACK,msgId);
+
+	
+	//send UPDATE message
+	myNodePtr_->sendMessage(neighbourId, hdrOspf);	
+}
+
+//**********************************************************************************
+// getHelloPkt method: get the especific hello packet's fields 
+//**********************************************************************************
+
+HelloPacket OspfRouting:: getHelloPkt()
+{
+	HelloPacket pkt;
+	pkt.networkMask_=NETWORK_MASK_DEFAULT;
+	pkt.helloInterval_=helloInterval_;
+	pkt.options_= options_t(1,0); // set tos routing capability
+	pkt.deadInterval_=routerDeadInterval_;
+	pkt.neighbourListPtr_=&neighbourIdList; 
+	return pkt;
+	
+}
+
+
+//**********************************************************************************
+// getDdPkt method: get the especific dd packet's fields for neighbour nbId 
+//**********************************************************************************
+
+DDPacket OspfRouting::getDdPkt(int nbId) {
+
+	DDPacket pkt;
+	StateN_type_t state= neighbourData_.getState (nbId);
+	
+	if(state==EX_START) {
+	// get an empty DDpacket with I,M,MS bits activados
+	pkt.options_=neighbourData_.getOptions (nbId);
+	char bitMS=neighbourData_.getMasterSlave (nbId);
+	pkt.IMMSbits_=IMMS_t(1,1,bitMS);
+	pkt.DDSeqNumber_=neighbourData_.getDDseq (nbId);
+	pkt.lsHeaderListPtr_=NULL;
+	
+        }
+	if(state==EXCHANGE) {
+	printf("getddpkt EXCHANGE\n");
+	pkt.options_=neighbourData_.getOptions (nbId);
+	char bitMS=neighbourData_.getMasterSlave (nbId);
+	pkt.IMMSbits_=IMMS_t(0,0,bitMS);
+	pkt.DDSeqNumber_=neighbourData_.getDDseq (nbId);
+	LinkStateHeaderList lshrdl = neighbourData_.getLinkStateHeaderList (nbId);
+		
+	LinkStateHeaderList* lshdrptr = new LinkStateHeaderList(lshrdl);
+	pkt.lsHeaderListPtr_=lshdrptr;
+	
+	}
+
+	return pkt;
+}
+
+
+//**********************************************************************************
+// getRequestPkt method: get the especific request packet's fields for neighbour nbId 
+//**********************************************************************************
+
+RequestPacket OspfRouting::getRequestPkt (int nbId) {
+
+	RequestPacket pkt;
+	StateN_type_t state= neighbourData_.getState (nbId);
+
+	if((state==EXCHANGE)||(state==LOADING)){
+	//get the  link state advertisment to request
+
+	LinkStateRecordIdList lsr= neighbourData_.getRequestList (nbId);
+	LinkStateRecordIdList* lsrptr = new LinkStateRecordIdList(lsr);
+	pkt.linkStateRecordIdListPtr_=lsrptr;
+			
+	}
+	
+	else	//We should never get in here
+	     ls_error ("No packet to request\n");
+	
+	return pkt;
+
+}
+
+//**********************************************************************************
+// getOspfHeader method: create an ospf header for a new packet of the type 
+// indicated as parameter  
+//**********************************************************************************
+
+hdr_Ospf OspfRouting::getOspfHeader ( Ospf_message_type_t type, int msgId){
+
+	hdr_Ospf hdr;
+	hdr.version_=2;
+	hdr.type_=type;
+	hdr.packet_len_=getLength(type);
+	hdr.router_id_=myNodeId_;
+	hdr.msgId_=msgId;
+	return hdr;
+}
+
+//**********************************************************************************
+// getLength method: returns packet's length taking into account the type  
+//**********************************************************************************
+
+int OspfRouting::getLength (Ospf_message_type_t type) {
+	
+	int len;
+switch (type) {
+
+	case OSPF_MSG_INVALID:
+		ls_error("OSPF_MSG_INVALID "
+			 "OspfRouting::getLength.\n");
+		break;
+	case OSPF_MSG_HELLO:
+		len= OSPF_HEADER_SIZE+OSPF_HELLO_MESSAGE_SIZE;
+		break;
+
+	case OSPF_MSG_DD:
+		len= OSPF_HEADER_SIZE+OSPF_DD_MESSAGE_SIZE;
+		break;
+
+	case OSPF_MSG_REQUEST:
+		len= OSPF_HEADER_SIZE+OSPF_REQUEST_MESSAGE_SIZE;
+		break;
+
+	case OSPF_MSG_UPDATE:
+		len= OSPF_HEADER_SIZE+OSPF_UPDATE_MESSAGE_SIZE;
+		break;
+
+	case OSPF_MSG_ACK:
+		len= OSPF_HEADER_SIZE+OSPF_ACK_MESSAGE_SIZE;
+		break;
+
+	default: 
+		len=OSPF_DEFAULT_MESSAGE_SIZE;
+		break;
+	}
+	
+	return len;
+}
+
+
+//**********************************************************************************
+// receiveMessage method: returns true if there's a need to re-compute routes  
+//**********************************************************************************
+
+bool OspfRouting::receiveMessage (int senderId, u_int32_t msgId,Ospf_message_type_t type)
+{
+	if (senderId == LS_INVALID_NODE_ID)
+		return false;
+
+	OspfMessage* msgPtr = msgctr().retrieveMessagePtr(msgId,type);
+	
+	if (msgPtr == NULL)
+		return false;
+	
+	bool retCode = false;
+	
+	
+	// A switch statement to see the type.
+	// and handle differently
+	switch (type){
+	case OSPF_MSG_HELLO:
+		retCode = receiveHello(senderId,msgPtr);
+		break;
+	
+	case OSPF_MSG_DD:
+		retCode = receiveDD (senderId, msgPtr);
+		break;
+	case OSPF_MSG_REQUEST: 
+		retCode = receiveRequest (senderId, msgPtr);
+		break;
+	case OSPF_MSG_UPDATE:
+		retCode = receiveUpdate (senderId, msgPtr); 
+		break;
+	case OSPF_MSG_ACK: 
+		receiveAck(senderId, msgPtr);
+		msgctr().deleteMessage(msgId,OSPF_MSG_ACK);
+		break;
+	default:
+		break;
+	}
+	return retCode;
+}
+
+//**********************************************************************************
+// receiveHello method: returns true if there's a need to re-compute routes  
+//**********************************************************************************
+
+bool OspfRouting::receiveHello (int neighbourId, OspfMessage* msgPtr)
+{
+	
+	printf(" [%f] Node: %d RECEIVE Hello from node:%d\n",NOW,myNodeId_,neighbourId);
+	
+	if (msgPtr == NULL)
+		return false;
+	
+	bool retCode = false;
+		
+	
+	// check routerDeadInterval and HelloInterval values
+	 double hello_interval=msgPtr->HelloPacketPtr_->helloInterval_;
+	 double router_dead_interval=msgPtr->HelloPacketPtr_->deadInterval_;
+	if((hello_interval!=helloInterval_)||(router_dead_interval!=routerDeadInterval_))
+		return false;
+	
+	//STORE NEIGHBOUR's DATA
+	//set neighbourid
+	neighbourData_.setNeighbourId(neighbourId);
+	//set options
+	options_t op=msgPtr->HelloPacketPtr_->options_;
+	neighbourData_.setOptions(op,neighbourId);
+	op=neighbourData_.getOptions(neighbourId);
+	printf("OPTIONS NEIGHBOUR T:%d E:%d\n",op.bit_T,op.bit_E); 
+ 
+		
+	//add neighbour to the neighbours list if necessary
+	addNeighbourToList(neighbourId);
+	
+	printf("LISTA VECINOS DEL NODO:%d:\n",myNodeId_);
+		for (LsNodeIdList::iterator itrList = neighbourIdList.begin();
+	     	itrList != neighbourIdList.end(); itrList++) {
+		printf("Nodo vecino: %d\n",*itrList);
+		}
+
+	// change the Router LSA state to up
+	printf("NEIGHBOURID :%d\n",neighbourId);
+	changeRouterLSAState(myNodeId_,neighbourId,LS_STATUS_UP);
+	
+	//GENERATING EVENTS
+	//hello received event
+	retCode=helloReceivedEvent(neighbourId);
+ 	
+	//check if 2-way conectivity
+	if(isTwoWayConectivity(msgPtr)) {
+
+	//we are simulating point to point networks so the router seen is already adyacent
+	//add the new adyacent router to the adyacentsIdList_
+		addAdyacentToList(neighbourId);
+		
+		printf("LISTA ADYACENTES DEL NODO:%d\n",myNodeId_);
+		for (LsNodeIdList::iterator itrList = adyacentsIdList.begin();
+	     		itrList != adyacentsIdList.end(); itrList++) {
+			printf("Nodo vecino: %d\n",*itrList);
+			
+		}
+	// 2way conectivity event
+		retCode=twoWayReceivedEvent (neighbourId);
+
+	}
+	//there's not 2 way conectivity
+	else 
+		//1-wayReceived event  
+		retCode=oneWayReceivedEvent (neighbourId);
+	
+	return retCode;
+}
+
+//**********************************************************************************
+// receiveDD method: returns true if there's a need to re-compute routes  
+//**********************************************************************************
+
+
+bool OspfRouting::receiveDD (int neighbourId, OspfMessage* msgPtr){
+	
+	
+	printf("RECEIVE DD from node:%d\n",neighbourId);
+	
+	if (msgPtr == NULL)
+		return false;
+		
+	bool retCode = false;
+		
+	if((neighbourData_.getMasterSlave(neighbourId))
+	&&(!neighbourData_.isState(neighbourId,EX_START))){
+ 	//I'm the master:
+		
+		AckManager_.messageIn(neighbourId,*msgPtr,OSPF_MSG_DD);
+	}
+
+	StateN_type_t state= neighbourData_.getState (neighbourId);
+	
+	if ((state==ATTEMPT)||(state==DOWN)) {
+		
+		return false;
+	}
+
+	if (state==INIT) {
+	
+	// 2way conectivity event
+	retCode=twoWayReceivedEvent (neighbourId);
+	//add neighbour to adyacent list
+	addAdyacentToList (neighbourId);
+	state=neighbourData_.getState (neighbourId);
+	}
+	
+	if(state==TWO_WAY){
+		
+		return false;	
+			
+	}
+	
+	if(state==EX_START){
+			
+		if(rolesDistributed(neighbourId,msgPtr)){
+			return NegDoneEvent(neighbourId);		
+		}
+		
+		return false;
+	}
+	
+	if(state==EXCHANGE) {
+		printf("EXCHANGE\n");
+						
+		if(isSeqNumberMismatch (neighbourId,msgPtr)){
+			printf("Seq Number Mismatch\n");
+			
+			retCode=SeqNumberMismatchEvent (neighbourId);
+			return retCode;
+		}
+
+		if(isPacketDuplicated (neighbourId,msgPtr)){
+		//deprecate the packet or resend
+			printf("Packet duplicated\n");
+			return managePacketDuplicated(neighbourId,msgPtr);
+		}
+
+		if(isNextPacketSeq(neighbourId,msgPtr))
+			return processPacket(neighbourId,msgPtr);
+				
+	}
+	
+	//else: SeqNumberMismatchEvent
+		return SeqNumberMismatchEvent (neighbourId);
+	
+	return retCode;	
+}
+
+//**********************************************************************************
+// receiveRequest method: returns true if there's a need to re-compute routes  
+//**********************************************************************************
+
+bool OspfRouting::receiveRequest (int neighbourId, OspfMessage* msgPtr){
+	
+	printf("Node: %d RECEIVE REQUEST from node:%d\n",myNodeId_,neighbourId);
+	if (msgPtr == NULL)
+		return false;
+		
+	bool retCode = false;
+	StateN_type_t state= neighbourData_.getState (neighbourId);
+	OspfLinkState ls;
+	OspfLinkStateList lsl;
+	UpdatePacket updpkt;
+	int numadv=0;
+
+	if((state==EXCHANGE)||(state==LOADING)||(state==FULL)){
+		RequestPacket* reqpkt=msgPtr->RequestPacketPtr_;
+		 
+		for (LinkStateRecordIdList::iterator itrList = reqpkt->linkStateRecordIdListPtr_->begin();
+	     itrList != reqpkt->linkStateRecordIdListPtr_->end(); itrList++) {
+		printf("Ls type:%d Lsid:%d advertising router:%d \n",(*itrList).type_,(*itrList).lsID_,
+		(*itrList).advertisingRouter_);
+			//for each link state record Id
+			if(linkStateDatabase_.lookupLSA((*itrList).type_,(*itrList).lsID_,
+			(*itrList).advertisingRouter_)) {
+				//exists the link state advertisement in the database
+			 	ls=linkStateDatabase_.getLSA((*itrList).type_,(*itrList).lsID_,
+				(*itrList).advertisingRouter_);
+				//get the link state advertisement
+				lsl.push_back(ls);
+				//push into link state list
+				neighbourData_.addLSARetrans (neighbourId,ls);
+				//add new LSA to retransmission list
+				
+				
+			}
+			else {
+				printf("ERROR:El LSA no esta en la base de datos\n");
+			        return BadLSReqEvent(neighbourId);	
+				
+			}
+	
+		  	numadv++;	
+		}    
+	
+	updpkt.numberAdvert_=numadv; 
+	OspfLinkStateList* ladvPtr_ = new OspfLinkStateList(lsl); 
+	updpkt.LsListAdvertPtr_=ladvPtr_;
+	sendUpdate(myNodeId_,neighbourId,updpkt);
+	
+	}
+
+	else {
+		//deprecate the packet
+	}
+	
+	return retCode;
+}
+
+
+//**********************************************************************************
+// receiveUpdate method: returns true if there's a need to re-compute routes  
+//**********************************************************************************
+
+bool OspfRouting::receiveUpdate (int neighbourId, OspfMessage* msgPtr){
+
+	printf("Node: %d RECEIVE UPDATE from node:%d\n",myNodeId_,neighbourId);
+	if (msgPtr == NULL)
+		return false;
+
+	bool retCode=false;
+	
+	retCode_t res;
+	
+	UpdatePacket* updpkt= msgPtr->UpdatePacketPtr_;
+	StateN_type_t state= neighbourData_.getState (neighbourId);
+	int originNodeId=msgPtr->originNodeId_;
+	if(state<EXCHANGE) {
+		return false;
+	}
+	
+	//for each LSA
+	for (OspfLinkStateList::iterator itrList = updpkt->LsListAdvertPtr_->begin();
+	     	itrList != updpkt->LsListAdvertPtr_->end(); itrList++) {
+		if(!isLsTypeValid((*itrList).ls_hdr_.LS_type_)){
+			//LStype is not valid: discard the LSA, get the next	
+			continue;
+		}
+		//lookup the LSA in the database
+		res=linkStateDatabase_.lookupLSA((*itrList).ls_hdr_);
+		
+		//PRUEBA
+		/*printf("LS TYPE: %d\n",(*itrList).ls_hdr_.LS_type_);
+		printf("LS ID: %d\n",(*itrList).ls_hdr_.LS_ID_);
+		printf("advertising router: %d\n",(*itrList).ls_hdr_.advertising_router_);
+	
+	for (RouterLinkStateList::iterator itrList3 =(*itrList).RouterLinkStateListPtr_->begin();
+            itrList3 != (*itrList).RouterLinkStateListPtr_->end(); itrList3++){
+
+		printf("Nodo vecino: %d ",(&(*itrList3))->Link_ID_);
+
+		printf("State %d\n",(*itrList3).state_);
+		for (MTLinkList::iterator itrList2 = (&(*itrList3))->MTLinkList_.begin();
+             itrList2 != (&(*itrList3))->MTLinkList_.end(); itrList2++){
+		
+		printf("Mtid: %d Coste: %d\n",(&(*itrList2))->mtId_,(&(*itrList2))->metric_);
+
+		}	
+	}*/	
+		//	
+
+		if(((*itrList).ls_hdr_.LSage_==MAX_AGE)&&(res==NO_EXIST)){
+			printf("lsage=MAX AGE or no exist\n");
+			//send ack:
+			LinkStateHeaderList lshdrl;
+			lshdrl.push_back((*itrList).ls_hdr_);
+			sendAck(neighbourId,originNodeId,lshdrl);
+			
+			//remove outstanding request for equal o previous instances of LSA from
+			// neighbour request list
+			neighbourData_.delLSARequest(neighbourId,(*itrList).ls_hdr_);	
+			if((state==EXCHANGE)||(state==LOADING)){
+				//insert lsa in the database
+				u_int32_t adv_router=(*itrList).ls_hdr_.advertising_router_;
+
+				linkStateDatabase_.insertLinkState(adv_router,
+				(*itrList));
+	
+				//active Lsaging timer
+				AgingManager_.createLSA(adv_router);
+				continue;
+			}
+			//else
+			//deprecate the LSA
+
+				continue;
+		}
+		//else
+		//find the instance of LSA in the database
+		
+		LS_type_t lstypeN=(*itrList).ls_hdr_.LS_type_;
+		u_int32_t lsidN=(*itrList).ls_hdr_.LS_ID_;
+		u_int32_t adv_routerN=(*itrList).ls_hdr_.advertising_router_;
+		//get LSA copy in the database
+		OspfLinkState ls=linkStateDatabase_.getLSA (lstypeN,lsidN,adv_routerN);
+			
+		if((res==NO_EXIST)||(res==NEWER)){
+			printf("No exist or newer\n");	
+	
+			// flood the new LSA out of router's interfaces
+			sendFlooding(neighbourId,(*itrList));
+			
+			//install the new LSA
+			if(res==NO_EXIST){
+				printf(" NO EXIST\n");
+				//insert the new LSA
+				linkStateDatabase_.insertLinkState
+				(adv_routerN,(*itrList));
+				
+				//activate Lsaging timer
+				AgingManager_.createLSA(adv_routerN);
+				
+				// compute the routing table
+				computeRoutes();
+				retCode=true;
+
+			}
+
+			else {
+			printf("EXIST\n");
+			//the LSA exists in the database
+			//check if routing table must be recalculated
+			retCode=linkStateDatabase_.updateRoutingTable
+			(adv_routerN,(*itrList));
+			//remove LSA copy from the database
+			linkStateDatabase_.delLSA(ls.ls_hdr_.advertising_router_,
+						   ls.ls_hdr_.LS_type_,
+					           ls.ls_hdr_.LS_ID_,
+					           ls.ls_hdr_.advertising_router_);	
+			
+			
+			//insert new LSA into the database
+			linkStateDatabase_.insertLinkState(
+			adv_routerN,(*itrList));
+			//activate LSaging timer
+			AgingManager_.createLSA(adv_routerN);
+
+				if(retCode){
+					//routing table must be recalculated
+					computeRoutes();
+				}
+
+			}//end else NO EXIST
+			
+			//send ack to node sender
+			LinkStateHeaderList lshdrl;
+			lshdrl.push_back((*itrList).ls_hdr_);
+			sendAck(neighbourId,originNodeId,lshdrl);
+			
+			//check if self-originated LSA
+			//in this case, no special action is required
+						
+			continue;				
+		}//no exist or newer
+		
+		//there is an instance in of the LSA on the sending
+		// neighbor’s Link state request list
+		if(neighbourData_.lookupLSAReq (neighbourId,
+							(*itrList).ls_hdr_)){				
+			//an error has occurred
+			return BadLSReqEvent(neighbourId);
+		}
+
+		//LSA received = LSA in database
+		if(res==EQUALS){
+			
+			printf("[%f] EQUALS\n",NOW);
+			//PRUEBA
+		/*	printf("RETRANSMISSION LIST\n");
+			OspfLinkStateList lsl=neighbourData_.getLinkStateRetransList(neighbourId);
+		
+		for (OspfLinkStateList::iterator itrList4 = lsl.begin();
+	     	itrList4 != lsl.end(); itrList4++) {
+			printf("LS TYPE: %d\n",(*itrList4).ls_hdr_.LS_type_);
+			printf("LS ID: %d\n",(*itrList4).ls_hdr_.LS_ID_);
+			printf("advertising router: %d\n",(*itrList4).ls_hdr_.advertising_router_);
+		}*/
+		//
+			if(neighbourData_.lookupLSARetrans (neighbourId,(*itrList).ls_hdr_)){
+								
+				//the LSA is consider as implicit ack
+				bool del=neighbourData_.delLSARetrans (neighbourId,(*itrList).ls_hdr_);
+				//OspfLinkStateList lsRetran=neighbourData_.getLinkStateRetransList 
+				//(neighbourId);
+				UpdatePacket* upd=msgPtr->UpdatePacketPtr_;
+				AckPacket ack=UpdateToAck(*upd);
+				(*msgPtr).AckPacketPtr_=&ack;
+				
+				OspfLinkStateList lsl=neighbourData_.getLinkStateRetransList(neighbourId);
+		
+				if((del)&&(lsl.empty())){
+				//some item is removed from the retransmission list
+				// and this list is empty
+				AckManager_.messageIn(neighbourId,*msgPtr,OSPF_MSG_ACK);
+				}					
+			}
+			//send ack to node sender
+			LinkStateHeaderList lshdrl;
+			lshdrl.push_back((*itrList).ls_hdr_);
+			sendAck(neighbourId,originNodeId,lshdrl);
+				
+			continue;
+		}
+
+		// LSA received is older than LSA in the database
+		printf("the LSA received is older than LSA in the database\n");
+		
+		if((ls.ls_hdr_.LSage_==MAX_AGE)&&
+		(ls.ls_hdr_. LS_sequence_num_==OSPF_WRAPAROUND_THRESHOLD)){
+			//discard LSA without acknowledging
+						
+			printf("discard LSA\n");
+			continue;
+		}
+			
+		//add new LSA to retransmission list
+		neighbourData_.addLSARetrans (neighbourId,ls);
+
+		//Send LSA in the database to the neighbour
+		OspfLinkStateList lsl;
+		UpdatePacket updpktN;
+		//ls.ls_hdr_.LSage_=(*itrList).ls_hdr_.LSage_;
+		//ls.ls_hdr_. LS_sequence_num_=(*itrList).ls_hdr_.LS_sequence_num_;
+		lsl.push_back(ls);
+		updpktN.numberAdvert_=1;		 
+		OspfLinkStateList* ladvPtr_ = new OspfLinkStateList(lsl); 
+		updpktN.LsListAdvertPtr_=ladvPtr_;
+		sendUpdate(myNodeId_,neighbourId,updpktN);
+		
+	
+	}//end for
+	
+	//check if there is some LSA to request
+	LinkStateRecordIdList reql=neighbourData_.getRequestList(neighbourId); 
+	if((reql.empty())&&(state==LOADING)){
+			printf("Node: %d PeerId: %d\n",myNodeId_,neighbourId);
+			AckManager_.messageIn(neighbourId,*msgPtr,OSPF_MSG_UPDATE);
+			LoadingDoneEvent(neighbourId);
+	}	
+	
+	
+	return retCode;
+	
+}
+
+//**********************************************************************************
+// receiveAck method: returns true if there's a need to re-compute routes  
+//**********************************************************************************
+
+bool OspfRouting::receiveAck (int neighbourId, OspfMessage* msgPtr){
+
+	printf("Node: %d RECEIVE ACK from node:%d\n",myNodeId_,neighbourId);
+	if (msgPtr == NULL)
+		return false;
+
+	bool retCode=true;
+	AckPacket* ackpkt= msgPtr->AckPacketPtr_;
+	StateN_type_t state= neighbourData_.getState (neighbourId);
+	
+	if(state<EXCHANGE){
+		return false;
+	}
+	//PRUEBA
+	/*printf("RETRANSMISSION LIST\n");
+	OspfLinkStateList lsl=neighbourData_.getLinkStateRetransList(neighbourId);
+	for (OspfLinkStateList::iterator itrList = lsl.begin();
+	     	itrList != lsl.end(); itrList++) {
+		printf("LS TYPE: %d\n",(*itrList).ls_hdr_.LS_type_);
+		printf("LS ID: %d\n",(*itrList).ls_hdr_.LS_ID_);
+		printf("advertising router: %d\n",(*itrList).ls_hdr_.advertising_router_);
+	}*/
+	//
+	printf("ACK PACKET \n");
+	
+	//for each ack
+	for (LinkStateHeaderList::iterator itrList = ackpkt->lsHeaderListPtr_->begin();
+	     	itrList != ackpkt->lsHeaderListPtr_->end(); itrList++) {
+		//PRUEBA	
+		/*printf("LS TYPE: %d\n",(*itrList).LS_type_);
+		printf("LS ID: %d\n",(*itrList).LS_ID_);
+		printf("advertising router: %d\n",(*itrList).advertising_router_);*/
+		//
+	
+		if(! neighbourData_.lookupLSARetrans (neighbourId,(*itrList))){
+			//no exist the lsa in link state retransmission list for neighbourId
+			printf("No exist lsa in retransmission list\n");
+			
+			continue;
+		}
+		//else
+		bool del=neighbourData_.delLSARetrans (neighbourId,(*itrList));
+		OspfLinkStateList lsl=neighbourData_.getLinkStateRetransList(neighbourId);
+		
+		if((del)&&(lsl.empty())){			
+			//some item is removed from the retransmission list
+			// and the retransmission list is empty	
+			AckManager_.messageIn(neighbourId,*msgPtr,OSPF_MSG_ACK);
+		}
+		continue;	
+	}
+	
+	return retCode;
+}
+
+//**********************************************************************************
+// UpdateToAck method: converts an Update packet into a Ack packet  
+//**********************************************************************************
+
+AckPacket OspfRouting::UpdateToAck (UpdatePacket& updpkt){
+	
+	AckPacket ackpkt;
+	LinkStateHeaderList lsHeaderList;
+	
+	for (OspfLinkStateList::iterator itrList = updpkt.LsListAdvertPtr_->begin();
+	     itrList != updpkt.LsListAdvertPtr_->end(); itrList++){
+		lsHeaderList.push_back((*itrList).ls_hdr_);
+	}
+
+	ackpkt.lsHeaderListPtr_=&lsHeaderList;
+	return ackpkt;
+}
+//**********************************************************************************
+// addNeighbourToList method: add neighbour to neighbours list if necessary  
+//**********************************************************************************
+
+void OspfRouting::addNeighbourToList (int nbId)
+{
+	
+	for (LsNodeIdList::iterator itrList = neighbourIdList.begin();
+	     itrList != neighbourIdList.end(); itrList++) {
+		if (*itrList==nbId){
+			return;
+		}
+	}
+
+	neighbourIdList.push_back(nbId);
+}
+
+//**********************************************************************************
+// delNeighbourFromList method: delete neighbour from neighbours list if exists  
+//**********************************************************************************
+
+void OspfRouting::delNeighbourFromList (int nbId){
+
+	for (LsNodeIdList::iterator itrList = neighbourIdList.begin();
+	     itrList != neighbourIdList.end(); itrList++) {
+		if (*itrList==nbId) {
+			 neighbourIdList.erase(itrList);
+			return;
+		}
+	}
+	
+}	
+
+//**********************************************************************************
+// addAdyacentToList method: add adyacency to adyacent neighbours list if necessary  
+//**********************************************************************************
+
+void OspfRouting::addAdyacentToList (int nbId){
+
+	for (LsNodeIdList::iterator itrList = adyacentsIdList.begin();
+	     itrList != adyacentsIdList.end(); itrList++) {
+		if (*itrList==nbId){
+			return;
+		}
+	}
+
+	adyacentsIdList.push_back(nbId);
+
+}
+
+//**********************************************************************************
+// delAdyacentFromList method: delete and adyacency from adyacent neighbours list 
+// if exists  
+//**********************************************************************************
+
+void OspfRouting::delAdyacentFromList (int nbId) {
+
+	for (LsNodeIdList::iterator itrList = adyacentsIdList.begin();
+	     itrList != adyacentsIdList.end(); itrList++) {
+		if (*itrList==nbId) {
+			 adyacentsIdList.erase(itrList);
+			return;
+		}
+	}
+	
+  printf("No existe el adyacente:%d\n",nbId);
+}
+
+//**********************************************************************************
+// helloReceivedEvent method: representing hello received event  
+//**********************************************************************************
+bool OspfRouting::helloReceivedEvent (int nbId)
+{
+	printf("Hello Received Event from Node:%d\n",nbId);
+	bool retCode = false;
+	StateN_type_t state= neighbourData_.getState (nbId);
+	
+	//set the new neighbour state and reactive 
+	if ((state==ATTEMPT)||(state==DOWN)) {
+		printf("ATTEMPT or DOWN\n");
+		neighbourData_.setState(nbId,INIT);
+		InactivityManager_.messageIn(nbId, OSPF_MSG_HELLO);	
+		retCode=false;
+	}
+	
+	if(state>=INIT) {
+		printf("INIT or grater\n");
+		InactivityManager_.messageIn(nbId,OSPF_MSG_HELLO);
+		retCode=false;	
+	}
+
+	return retCode;
+}
+
+
+//**********************************************************************************
+// isTwoWayConectivity method: returns true if two way conectivity and false in
+// other case  
+//**********************************************************************************
+
+bool OspfRouting::isTwoWayConectivity (OspfMessage* msgPtr)
+{ 
+	HelloPacket* helloPktPtr=msgPtr->HelloPacketPtr_;
+	LsNodeIdList* nbIdListPtr=helloPktPtr->neighbourListPtr_;
+	for (LsNodeIdList::iterator itrList = nbIdListPtr->begin();
+	     itrList != nbIdListPtr->end(); itrList++) {
+		if (*itrList==myNodeId_){
+			printf("hay doble conectividad\n");
+			return true;
+		}
+	}
+	
+	return false;
+}
+
+
+//**********************************************************************************
+// twoWayReceivedEvent method: representing 2-way received event  
+//**********************************************************************************
+
+bool OspfRouting::twoWayReceivedEvent (int nbId)
+{
+	printf("2-WayReceived Event from Node:%d\n",nbId);
+	StateN_type_t state= neighbourData_.getState (nbId);
+	
+	if(state==INIT) {
+		printf("INIT\n");
+		
+		//set the new neighbour state
+		neighbourData_.setState(nbId,EX_START);
+		//increment DDsequence
+		neighbourData_.incDDseq (nbId);
+		//set bit MasterSlave to master
+		neighbourData_.setMaster (nbId);
+		//send DD packets
+		sendDD(nbId);
+		return false;	
+	}
+
+	if (state>=TWO_WAY) {
+		printf("2-WAY or grater\n");
+		return false;
+	}
+	
+	return false;
+	
+}
+
+//**********************************************************************************
+// oneWayReceivedEvent method: representing 1-way received event  
+//**********************************************************************************
+
+bool OspfRouting::oneWayReceivedEvent (int nbId) {
+
+
+	printf("1-WayReceived Event from Node:%d\n",nbId);
+	StateN_type_t state= neighbourData_.getState (nbId);
+	
+	if(state>=TWO_WAY) {
+		printf("TWO_WAY\n");
+		//set the new neighbour state
+		neighbourData_.setState(nbId,INIT);
+		//delete all lists for this neighbour
+		neighbourData_.delAllLists(nbId);
+		//delete nbId from adyacentsIdList
+		delAdyacentFromList (nbId);
+		return false;	
+	}
+
+	return false;
+
+}
+
+//**********************************************************************************
+// inactivityTimerEvent method: representing inactivityTimer event  
+//**********************************************************************************
+
+void OspfRouting::inactivityTimerEvent (int nbId) {
+
+		
+	printf("[%f] NODE: %d INACTIVITY TIMER EVENT\n",NOW,myNodeId_);
+		
+	//set the new neighbour state
+	neighbourData_.setState(nbId,DOWN);
+	//delete all lists for this neighbour
+	neighbourData_.delAllLists(nbId);
+	//set the node role to slave
+	neighbourData_.setSlave (nbId);
+	//init DDseq for nbId
+	neighbourData_.setDDseq(nbId, LS_INVALID_MESSAGE_ID);
+	
+	//delete nbId from adyacentsIdList
+	delAdyacentFromList (nbId);
+	//delete nbId from neighbourIdList
+	delNeighbourFromList (nbId);
+
+	//Cancel the ack timer for nbId
+	AckManager_.cancelTimer(nbId);
+
+	//change the Router LSA state to down
+	changeRouterLSAState (myNodeId_,nbId,LS_STATUS_DOWN);
+	
+	// recompute routing table
+	computeRoutes();
+	
+	
+}
+
+//**********************************************************************************
+// sendLSAToAdyacents method: sends the database copy of the LSA indexed by the 
+// parameters to all adyacents neighbours  except to no_dest_node
+//**********************************************************************************
+
+void OspfRouting::sendLSAToAdyacents(LS_type_t type ,int adv_router,int link_id, int no_dest_node){
+
+	for (LsNodeIdList::iterator itrList =adyacentsIdList.begin();
+	            itrList!= adyacentsIdList.end(); itrList++) {
+		
+	   if ((*itrList)==no_dest_node){
+		continue;
+	    }	
+	    //get the linkstate advertisement whose link id= myNodeId
+	    OspfLinkState ls=linkStateDatabase_.getLSA(LS_ROUTER,adv_router,link_id);
+	    //add new LSA to retransmission list
+	    neighbourData_.addLSARetrans ((*itrList),ls);
+	    //increment LSage and sequence number
+	    double* DelayPtr=delayMapPtr_->findPtr((*itrList));
+	    double infTransDelay=*DelayPtr;
+	    printf("LSAGE %f\n",ls.ls_hdr_.LSage_);
+	    ls.ls_hdr_.LSage_+=infTransDelay;
+	    printf("infTransDelay %f\n",infTransDelay);
+	    printf("LSAGE %f\n",ls.ls_hdr_.LSage_);
+	    //send update packet
+	    UpdatePacket updpkt;
+	    OspfLinkStateList lsl;
+	    lsl.push_back(ls);
+	    updpkt.numberAdvert_=1;		 
+	    OspfLinkStateList* ladvPtr_ = new OspfLinkStateList(lsl); 
+	    updpkt.LsListAdvertPtr_=ladvPtr_;
+	    sendUpdate(myNodeId_,(*itrList),updpkt);
+	}
+
+}
+
+//**********************************************************************************
+// rolesDistributed method: returns true if roles master/slave have been 
+// distributed and false in other case.  
+//**********************************************************************************
+
+bool OspfRouting::rolesDistributed(int nbId,OspfMessage* msgPtr){
+		
+	if(isSlave(nbId,msgPtr)||isMaster(nbId,msgPtr)){
+		
+		return true;
+	}
+	else
+		return false;
+}
+
+//**********************************************************************************
+// isSlave method: returns true if the router is the slave    
+//**********************************************************************************
+
+bool OspfRouting::isSlave(int nbId, OspfMessage* msgPtr){
+
+	DDPacket* ddpkt=msgPtr->DDPacketPtr_;
+	char bitI,bitM,bitMS;
+	bitI=ddpkt->IMMSbits_.bit_I;
+	bitM=ddpkt->IMMSbits_.bit_M;
+	bitMS=ddpkt->IMMSbits_.bit_MS;
+	LinkStateHeaderList* lsl=ddpkt->lsHeaderListPtr_;
+	if((bitI==1)&&(bitM==1)&&(bitMS==1)&&(lsl==NULL)&&(nbId>myNodeId_)){
+		neighbourData_.setSlave(nbId);
+		neighbourData_.setDDseq(nbId,ddpkt->DDSeqNumber_);
+		return true;
+	}
+	
+	return false;
+}
+
+//**********************************************************************************
+// isMaster method: returns true if the router is the master    
+//**********************************************************************************
+
+bool OspfRouting::isMaster(int nbId, OspfMessage* msgPtr){
+
+	DDPacket* ddpkt=msgPtr->DDPacketPtr_;
+	char bitI,bitMS;
+	bitI=ddpkt->IMMSbits_.bit_I;
+	bitMS=ddpkt->IMMSbits_.bit_MS;
+	double ddseqpkt=ddpkt->DDSeqNumber_;
+	double ddseqnb=neighbourData_.getDDseq(nbId);
+		
+	if((bitI==0)&&(bitMS==0)&&(nbId<myNodeId_)&&(ddseqpkt==ddseqnb)){
+		neighbourData_.setMaster(nbId);
+		neighbourData_.incDDseq (nbId);
+		return true;
+	}
+	
+	return false;
+}
+
+
+//**********************************************************************************
+// NegDoneEvent method: representing NegotiationDone event  
+//**********************************************************************************
+
+bool OspfRouting::NegDoneEvent(int nbId){
+	
+	printf("NegDone Event from Node:%d\n",nbId);
+	StateN_type_t state= neighbourData_.getState (nbId);
+	
+
+	if(state==EX_START) {
+		printf("EX_START\n");
+		//set the new neighbour state
+		neighbourData_.setState(nbId,EXCHANGE);
+		// list the contents of its link state database in the 
+		//neighbor Database summary list
+		OspfLinkStateList lsl;
+		lsl=linkStateDatabase_.getLSList();
+		OspfLinkStateList lslret;
+		LinkStateHeaderList lshdrl; 
+		
+		
+		for (OspfLinkStateList::iterator itrList =lsl.begin();
+	            itrList!= lsl.end(); itrList++) {
+			printf("Link id %d\n",(*itrList).ls_hdr_.LS_ID_);
+				
+			if((*itrList).ls_hdr_.LSage_==MAX_AGE){
+				//add the ls advertisement to retransmission list
+				lslret.push_back(*itrList);
+			}
+			else	{
+				
+				//add the ls header advertisment to summary list	
+				lshdrl.push_back((*itrList).ls_hdr_);
+			}
+		}
+		
+		neighbourData_.setLinkStateHeaderList(nbId,lshdrl);
+		neighbourData_.setLinkStateRetransList(nbId,lslret);
+		sendDD(nbId);
+			
+	}
+
+	return false;
+
+	
+}	
+
+//**********************************************************************************
+//  isSeqNumberMismatch method: returns false if every field match between the
+// packet's fields and the values stored in the router, and false in other case  
+//**********************************************************************************
+
+bool OspfRouting::isSeqNumberMismatch (int neighbourId, OspfMessage* msgPtr){
+	
+	DDPacket* ddpktPtr=msgPtr->DDPacketPtr_;
+	options_t op=neighbourData_.getOptions(neighbourId);
+	char MS=neighbourData_.getMasterSlave(neighbourId);
+	//if MSbit=1 in the packet, is because the sender neighbour is the master, so the MS bit
+	//for that neighbour in the neighbour structure must be 0: I'm the slave.
+	//
+	
+	//printf("isSeqNumberMismatch Nodo:%d Vecino:%d\n",myNodeId_,neighbourId);
+	//printf("PACKETE: ms:%d\n, bit_t:%d, bit_e:%d, bit_I:%d\n",ddpktPtr->IMMSbits_.bit_MS,
+	//ddpktPtr->options_.bit_T,ddpktPtr->options_.bit_E,ddpktPtr->IMMSbits_.bit_I);
+	//printf("VECINO: ms:%d\n, bit_t:%d, bit_e:%d\n",MS,
+	//op.bit_T,op.bit_E);
+	
+	
+	if((ddpktPtr->IMMSbits_.bit_MS!=MS)&&
+	(ddpktPtr->IMMSbits_.bit_I==0)){
+		if((op.bit_T==ddpktPtr->options_.bit_T)&&(op.bit_E==ddpktPtr->options_.bit_E))
+			return false;
+		//else
+			return true;
+	}	
+	return true;
+
+}
+
+//**********************************************************************************
+// SeqNumberMismatchEvent: representing SeqNumberMismatch event  
+//**********************************************************************************
+
+bool OspfRouting::SeqNumberMismatchEvent (int nbId) {
+
+
+	printf("SeqNumberMismatch Event from Node:%d\n",nbId);
+	StateN_type_t state= neighbourData_.getState (nbId);
+	
+	
+	if(state>=EXCHANGE) {
+		printf("EXCHANGE or grater\n");
+		//set the new neighbour state
+		neighbourData_.setState(nbId,EX_START);
+		//adjacency is torn down
+		delAdyacentFromList (nbId);
+		//cancel ack timer
+		AckManager_.cancelTimer(nbId);
+		//clear the lists:retransmission list, Database summary list and Link
+                // state request list 
+		neighbourData_.delAllLists(nbId);
+		//increments the DD sequence number in the
+                // neighbor data structure,
+		neighbourData_.incDDseq(nbId);
+		//declares itself master
+		neighbourData_.setMaster(nbId);
+                //starts sending Database Description Packets	
+		sendDD(nbId);
+		
+	}
+	
+	return false;
+}
+
+
+//**********************************************************************************
+//  isPacketDuplicated method: returns true if the packet arrived is duplicated
+// and false in other case.  
+//**********************************************************************************
+
+bool OspfRouting::isPacketDuplicated (int nbId,OspfMessage* msgPtr){
+
+
+	DDPacket* ddpktPtr=msgPtr->DDPacketPtr_;
+	char MS=neighbourData_.getMasterSlave(nbId);
+	double ddseq=neighbourData_.getDDseq (nbId);
+	double ddseqpkt=ddpktPtr->DDSeqNumber_;
+
+
+	printf("isPacketDuplicated Nodo:%d Vecino:%d\n",myNodeId_,nbId);
+		
+	//I'm the master
+	if((MS==1)&&(ddseqpkt<ddseq)){
+		return true;
+	}
+	//I'm the slave
+		
+	if((MS==0)&&(ddseqpkt==ddseq)){
+		return true;
+	}
+	return false; 
+}
+
+
+//**********************************************************************************
+//  managePacketDuplicated method: resend the packet if the router is the slave or
+// deprecate it if the router is the master.  
+//**********************************************************************************
+
+bool OspfRouting::managePacketDuplicated(int neighbourId, OspfMessage* msgPtr){
+	
+	
+	printf("managePacketDuplicated Nodo:%d Vecino:%d\n",myNodeId_,neighbourId);
+		
+	bool retCode=false;
+	char MS=neighbourData_.getMasterSlave(neighbourId);
+	//I'm the master
+	if(MS==1){
+		//deprecate the packet
+		
+	}
+	//I'm the slave
+	if(MS==0){
+		
+		//resend the old packet
+		hdr_Ospf hdrOspf =getOspfHeader (OSPF_MSG_DD,msgPtr->messageId_);
+		resendMessage(neighbourId,hdrOspf);
+	}
+	
+	return retCode;	
+}
+
+
+//**********************************************************************************
+//  isNextPacketSeq method: returns true if the packet arrived is the next in the
+// sequence and false in other case.  
+//**********************************************************************************
+
+bool OspfRouting::isNextPacketSeq (int nbId,OspfMessage* msgPtr){
+
+	DDPacket* ddpktPtr=msgPtr->DDPacketPtr_;
+	char MS=neighbourData_.getMasterSlave(nbId);
+	double ddseq=neighbourData_.getDDseq (nbId);
+	double ddseqpkt=ddpktPtr->DDSeqNumber_;
+
+
+	//I'm the master
+	if((MS==1)&&(ddseqpkt==ddseq)){
+		//
+		//printf("Nodo actual master:%d, Nodo vecino:%d esclavo\n",myNodeId_,nbId); 
+		//printf("PACKET: ddseq:%f\n",ddseqpkt);
+		//printf("VECINO:%d ddseq:%f MS:%d\n",nbId,ddseq,MS);
+		//
+		return true;
+	}
+	//I'm the slave
+	if((MS==0)&&(ddseqpkt>ddseq)){
+		//
+		//printf("Nodo actual esclavo:%d, Nodo vecino:%d master\n",myNodeId_,nbId); 
+		//printf("PACKET: ddseq:%f\n",ddseqpkt);
+		//printf("VECINO:%d ddseq:%f MS:%d\n",nbId,ddseq,MS);
+		
+		//
+		return true;
+	}
+	return false; 
+	
+	
+}
+
+//**********************************************************************************
+//  processPacket method: representing processing of the next sequence packet  
+//**********************************************************************************
+
+bool OspfRouting::processPacket(int neighbourId, OspfMessage* msgPtr) {
+	
+	printf("processPacket Nodo:%d Vecino:%d\n",myNodeId_,neighbourId);
+	DDPacket* ddpktPtr=msgPtr->DDPacketPtr_; 
+	LinkStateHeaderList* lslhdrPtr=ddpktPtr->lsHeaderListPtr_;
+	bool retCode=false;
+	LinkStateRecordIdList lsrecordl;
+	retCode_t res;
+	
+	//I'm the slave: get link state to request
+	for (LinkStateHeaderList::iterator itrList =lslhdrPtr->begin();
+	            itrList!= lslhdrPtr->end(); itrList++) {
+			
+			//check the LStype for each LSA
+			if(!isLsTypeValid((*itrList).LS_type_)){
+				printf("El tipo LS type es incorrecto\n");
+				return SeqNumberMismatchEvent(neighbourId);		
+			}
+			//else: Ls type valid
+			// looks up the LSA in its database
+			res=linkStateDatabase_.lookupLSA(*itrList);
+			printf("RES %d\n",res);
+			printf("LS ID %d\n",(*itrList).LS_ID_);
+			if((res==NO_EXIST)||(res==NEWER)) {
+					
+			// it does not exist, or the LSA received is more recent
+				LS_type_t type=(*itrList).LS_type_; // record type
+				u_int32_t lsID=(*itrList).LS_ID_; //link state record id
+				u_int32_t advertisingRouter=(*itrList).advertising_router_; //advertising 												router identifier
+ 				lsrecordl.push_back(LinkStateRecordId(type,lsID,advertisingRouter));
+			}
+			
+		}
+	
+
+	if(!lsrecordl.empty()){
+	neighbourData_.setRequestList(neighbourId,lsrecordl);
+	}
+	
+	//if I'm the master
+	if(neighbourData_.getMasterSlave(neighbourId)){
+		printf("I'm the master\n");
+		//increment DDsequence
+		neighbourData_.incDDseq(neighbourId);
+		if(ddpktPtr->IMMSbits_.bit_M==0){
+			//the exchange has finished
+			retCode=ExchangeDoneEvent(neighbourId);
+			
+		}
+		else {
+			sendDD(neighbourId);
+		}
+		
+	}
+	else {//I'm the slave
+		printf("I'm the slave\n");
+		//set DDsequence number to the DD sequence number appearing 
+		//in the received packet
+		neighbourData_.setDDseq(neighbourId,ddpktPtr->DDSeqNumber_); 
+		//send the reply
+		sendDD(neighbourId);
+			
+		if(ddpktPtr->IMMSbits_.bit_M==0){
+			printf("bit M=0\n");
+			//the exchange has finished
+			retCode=ExchangeDoneEvent(neighbourId);
+		}
+	}
+	
+	return retCode;
+}
+
+
+//**********************************************************************************
+//  isLsTypeValid method: returns true if the type is valid and false in other case
+//**********************************************************************************
+
+bool OspfRouting::isLsTypeValid (LS_type_t type){
+
+	switch(type){
+		case LS_ROUTER: return true;
+		case LS_NETWORK: return true;
+		case LS_SUMMARY: return true;
+		default:	
+			return false;
+	};
+}
+
+//**********************************************************************************
+// ExchangeDoneEvent: representing ExchangeDone event  
+//**********************************************************************************
+
+bool OspfRouting::ExchangeDoneEvent(int nbId){
+
+
+	printf("ExchangeDone Event from Node:%d\n",nbId);
+	StateN_type_t state= neighbourData_.getState (nbId);
+	
+	if(state==EXCHANGE) {
+		// link state request list empty
+		LinkStateRecordIdList reql=neighbourData_.getRequestList (nbId);
+		if(reql.empty()){
+		//set the new neighbour state: final state
+		neighbourData_.setState(nbId,FULL);
+		}
+		else {
+		//set the new neighbour state: LOADING
+		neighbourData_.setState(nbId,LOADING);
+		sendRequest(nbId);
+		}	
+	}
+	
+	return false;		
+}
+
+
+//**********************************************************************************
+// BadLSReqEvent: representing BadLSReqEvent event  
+//**********************************************************************************
+
+bool OspfRouting::BadLSReqEvent(int nbId){
+
+	printf("BadLSReqEvent Event from Node:%d\n",nbId);
+	StateN_type_t state= neighbourData_.getState (nbId);
+	
+	if(state>=EXCHANGE) {
+		printf("EXCHANGE or grater\n");
+		//set the new neighbour state
+		neighbourData_.setState(nbId,EX_START);
+		//adjacency is torn down
+		delAdyacentFromList (nbId);
+		//clear the lists:retransmission list, Database summary list and Link
+                // state request list 
+		neighbourData_.delAllLists(nbId);
+		//cancel ack timer
+		AckManager_.cancelTimer(nbId);
+				
+		//increments the DD sequence number in the
+                // neighbor data structure,
+		neighbourData_.incDDseq(nbId);
+		//declares itself master
+		neighbourData_.setMaster(nbId);
+                //starts sending Database Description Packets
+		sendDD(nbId);
+	}
+	
+	return false;
+}
+
+
+//**********************************************************************************
+// ageLSA method: increments LSA LSage field
+//**********************************************************************************
+
+int OspfRouting::ageLSA (int peerId){
+
+	//get the LSA
+	OspfLinkState ls=linkStateDatabase_.getLSA(LS_ROUTER,peerId,peerId);
+	
+	//reflooding self-originated LSA if LSage field reaches LSRefreshTime
+	if((ls.ls_hdr_.LSage_==LS_REFRESH_TIME)&&(peerId==myNodeId_)){
+		printf("[%f] ls refresh time myNodeId= %d\n",NOW,myNodeId_);
+		
+		//create new instance 
+		OspfLinkState ls;
+		ls.ls_hdr_.LSage_=0;
+		ls.ls_hdr_.options_=options_t(1,0);
+		ls.ls_hdr_.LS_type_=LS_ROUTER;
+		ls.ls_hdr_.LS_ID_=myNodeId_;
+		ls.ls_hdr_.LS_sequence_num_=ls.ls_hdr_.LS_sequence_num_;
+		ls.ls_hdr_.advertising_router_=myNodeId_;
+		
+		//get the first advertising: in this implementation is the one used
+		OspfLinkState lsad = linkStateListAdvPtr_->front();
+		linkStateListPtr_= lsad.RouterLinkStateListPtr_;	
+		ls.RouterLinkStateListPtr_=linkStateListPtr_;
+	
+	//update database
+	
+		linkStateDatabase_.delLSA (myNodeId_,ls.ls_hdr_.LS_type_,
+					ls.ls_hdr_.LS_ID_,
+					ls.ls_hdr_.advertising_router_);
+		
+		linkStateListAdvPtr_=linkStateDatabase_.insertLinkState(myNodeId_,ls);
+		linkStateListPtr_=linkStateListAdvPtr_->front().RouterLinkStateListPtr_;
+	
+	        //send the LSA in an update packet to all adyacents neighbours
+		sendFlooding(myNodeId_,ls);
+		
+	return 1;
+	}
+
+	//check if it is necessary to flush the LSA from the routing domain		
+	if(ls.ls_hdr_.LSage_==MAX_AGE){
+		
+		for (LsNodeIdList::iterator itrList =neighbourIdList.begin();
+	            itrList!= neighbourIdList.end(); itrList++) {
+			//for each neighbour
+			StateN_type_t state=neighbourData_.getState ((*itrList)); 
+			if((!neighbourData_.lookupLSARetrans ((*itrList),ls.ls_hdr_))
+			&&(state!=EXCHANGE)&&(state!=LOADING)){
+				continue;
+			}
+			else
+			 	return 0;
+		}	
+	 
+	//remove max age LSA	
+	linkStateDatabase_.delLSA (peerId,ls.ls_hdr_.LS_type_,
+					ls.ls_hdr_.LS_ID_,
+					ls.ls_hdr_.advertising_router_);
+	 return 0;	
+	}
+	else {
+
+	//call to OspfTopoMap method: incLSage
+	linkStateDatabase_.incLSage (peerId);
+	return 1;
+	} 
+	
+}
+
+//**********************************************************************************
+// LoadingDoneEvent: representing LoadingDone Event event  
+//**********************************************************************************
+
+void OspfRouting::LoadingDoneEvent (int nbId){
+
+	printf("LoadingDoneEvent Event from Node:%d\n",nbId);
+	StateN_type_t state= neighbourData_.getState (nbId);
+	
+	if(state==LOADING) {
+	//set the new neighbour state: final state
+		neighbourData_.setState(nbId,FULL);
+	
+	}
+
+}
+
+//**********************************************************************************
+// sendFlooding method: representing the flood of LSA to all adyacencies  
+//**********************************************************************************
+void OspfRouting::sendFlooding (int senderId,OspfLinkState& linkState){
+
+	printf("Node:%d sendFlooding\n",myNodeId_);
+	//for each adyacency
+	
+	double lsage_ini=linkState.ls_hdr_.LSage_;
+	//double seqnum_ini=linkState.ls_hdr_.LS_sequence_num_;
+
+	for (LsNodeIdList::iterator itrList =adyacentsIdList.begin();
+	            itrList!= adyacentsIdList.end(); itrList++) {
+
+	StateN_type_t state= neighbourData_.getState ((*itrList));
+		
+		if(state<EXCHANGE){
+			//this neighbour doesn't  participate in the flooding
+			//get the next neighbour
+			continue;
+		}
+		
+		if (senderId==(*itrList)){
+			//the LSA was received from this neighbour
+			printf("neighbourId=sender\n");
+		
+			if(neighbourData_.lookupLSAReq((*itrList),linkState.ls_hdr_)){
+			 //the two LSA copies are the same instance
+				//remove LSA from request list
+				neighbourData_.delLSARequest((*itrList),linkState.ls_hdr_);
+			}
+			//get the next neighbour
+			continue;
+		}
+
+		if((state==EXCHANGE)||(state==LOADING)){
+			printf("neighbourId %d state %d\n",(*itrList),state);
+			if(neighbourData_.lookupLSAReq((*itrList),linkState.ls_hdr_)){
+			 //the two LSA copies are the same instance
+				//remove LSA from request list
+				neighbourData_.delLSARequest((*itrList),linkState.ls_hdr_);
+				//get the next neighbour
+				continue;	
+			}
+		}
+		//at this point: we are not positive that the neighbour
+		//has up-to-date instance of LSA.
+		
+		//add new LSA to retransmission list
+		neighbourData_.addLSARetrans ((*itrList),linkState);
+		
+		//PRUEBA
+		/*printf("RETRANSMISSION LIST\n");
+		OspfLinkStateList lslp=neighbourData_.getLinkStateRetransList((*itrList));
+		
+		for (OspfLinkStateList::iterator itrList4 = lslp.begin();
+	     	itrList4 != lslp.end(); itrList4++) {
+			printf("LS TYPE: %d\n",(*itrList4).ls_hdr_.LS_type_);
+			printf("LS ID: %d\n",(*itrList4).ls_hdr_.LS_ID_);
+			printf("advertising router: %d\n",(*itrList4).ls_hdr_.advertising_router_);
+		}*/
+		//
+
+		//send update packet
+		UpdatePacket updpkt;
+		OspfLinkStateList lsl;
+		 
+		//get originator node
+		int origNode=linkState.ls_hdr_.advertising_router_;
+		//getUpdatePkt((*itrList),linkstate)=updpkt
+		//LSage must be incremented by InfTransDelay
+		
+		double* DelayPtr=delayMapPtr_->findPtr((*itrList));
+		double infTransDelay=*DelayPtr;
+		linkState.ls_hdr_.LSage_=lsage_ini+infTransDelay;
+		printf("infTransDelay %f\n",infTransDelay);
+		printf("LSAGE %f\n",linkState.ls_hdr_.LSage_);
+		//linkState.ls_hdr_. LS_sequence_num_=seqnum_ini+1;
+		lsl.push_back(linkState);
+		updpkt.numberAdvert_=1;		 
+		OspfLinkStateList* ladvPtr_ = new OspfLinkStateList(lsl); 
+		updpkt.LsListAdvertPtr_=ladvPtr_;
+		sendUpdate(origNode,(*itrList),updpkt);
+		
+	}//for adyacents
+
+	
+}
+
+//**********************************************************************************
+// changeRouterLSAState method: changes the router LSA state  
+//**********************************************************************************
+
+
+void OspfRouting::changeRouterLSAState (int adv_router, int link_id, ls_status_t st){
+
+	bool change=false;
+	// update my linkstate database
+	//get the linkstate advertisement whose link id= myNodeId
+	OspfLinkState ls=linkStateDatabase_.getLSA(LS_ROUTER,adv_router,adv_router);
+	
+	if((int)ls.ls_hdr_.advertising_router_!=LS_INVALID_NODE_ID) {
+	
+	printf(" link id %d advrouter %d \n",ls.ls_hdr_.LS_ID_,ls.ls_hdr_.advertising_router_);
+		
+	RouterLinkStateList routerlsl=(*ls.RouterLinkStateListPtr_);
+		
+	for (RouterLinkStateList::iterator itrList = routerlsl.begin();
+            itrList != routerlsl.end(); itrList++){
+		if((int)(*itrList).Link_ID_==link_id){
+			
+			if((*itrList).state_!=st){
+					printf("state!=st\n");
+					(*itrList).state_=st;
+					change=true;
+					break;
+			}
+		}
+	 }		
+	
+	if(change){
+	//the database has changed
+	
+	//remove link sate advertisement from the database
+	linkStateDatabase_.delLSA (myNodeId_,ls.ls_hdr_.LS_type_,
+					ls.ls_hdr_.LS_ID_,
+					ls.ls_hdr_.advertising_router_);
+	//update LSage and LS sequence number 
+	ls.ls_hdr_.LSage_=0;
+	ls.ls_hdr_.LS_sequence_num_+=1;
+	printf("seq number %f\n",ls.ls_hdr_.LS_sequence_num_);
+	ls.RouterLinkStateListPtr_=new RouterLinkStateList(routerlsl);
+	// insert the updated link state advertisement into the data base
+	linkStateListAdvPtr_=linkStateDatabase_.insertLinkState(myNodeId_,ls);
+	linkStateListPtr_=linkStateListAdvPtr_->front().RouterLinkStateListPtr_;
+	
+		if(st==LS_STATUS_UP){
+			//active the ls aging timer
+			AgingManager_.createLSA(link_id);
+	
+		}
+		else{	
+		//LS_STATUS_DOWN
+		//cancel lsAging timer
+			AgingManager_.cancelTimer(link_id);
+		
+		}
+	//recompute routes
+	computeRoutes();
+	//send the database copy LSA in an update packet to all adyacents neighbours
+	// except to link_id
+	sendLSAToAdyacents(LS_ROUTER,myNodeId_,myNodeId_,link_id);
+
+	}// if change
+    }
+}
+
+//**********************************************************************************
+// _computeRoutes method: private method called by computeRoutes  
+//**********************************************************************************
+
+OspfPaths* OspfRouting::_computeRoutes () 
+{
+	printf("Compute routes\n");
+	OspfPathsTentative* pTentativePaths = new OspfPathsTentative();
+	OspfPaths* pPaths = new OspfPaths() ; // to be returned; 
+ 	int nmtids = myNodePtr_->getNumMtIds();
+	int path_cost;
+	// step 1. put myself in path for each mtid
+	for (int i=0; i<=nmtids;i++) {
+	  pPaths->insertPathNoChecking(myNodeId_,i,0,myNodeId_);
+	}
+	
+	//PRUEBA
+	/*for (OspfLinkStateMap::iterator itrMap = linkStateDatabase_.begin();
+            itrMap != linkStateDatabase_.end(); itrMap++) {
+		for (OspfLinkStateList::iterator itrList = (*itrMap).second.begin();
+	            itrList!=(*itrMap).second.end(); itrList++) {			
+			
+			printf("Node %d LS_sequence_num_: %f\n",myNodeId_,
+			(*itrList).ls_hdr_.LS_sequence_num_);
+			printf("Advertising router: %d\n",(*itrMap).first);
+			
+	for (RouterLinkStateList::iterator itrList2 = (*itrList).RouterLinkStateListPtr_->begin();
+            itrList2 != (*itrList).RouterLinkStateListPtr_->end(); itrList2++){
+
+		printf("Nodo vecino: %d ",(&(*itrList2))->Link_ID_);
+		printf("State: %d\n",(*itrList2).state_);
+		for (MTLinkList::iterator itrList3 = (&(*itrList2))->MTLinkList_.begin();
+             itrList3 != (&(*itrList2))->MTLinkList_.end(); itrList3++){
+		
+		printf("Mtid: %d Coste: %d\n",(&(*itrList3))->mtId_,(&(*itrList3))->metric_);
+
+		}	
+	      }
+			
+	   }
+	}*/
+	//
+
+	for (int i=0; i<=nmtids;i++){ // calculate the routes for each Mtid
+
+	OspfLinkStateList * ptrLSLAd = linkStateDatabase_.findPtr(myNodeId_);
+	
+	if(ptrLSLAd->empty())
+		return pPaths;
+
+	//get the first advertising: in this implementation is the one used
+	OspfLinkState lsad = ptrLSLAd->front();
+
+	//LSA whose LSage field is equal to MaxAge, is not used in computing routing table
+	if(lsad.ls_hdr_.LSage_==MAX_AGE)
+		return pPaths;
+
+	RouterLinkStateList* lslPtr_= lsad.RouterLinkStateListPtr_;
+	int newNodeId = myNodeId_;
+	bool done = false;
+
+	  while (!done) {
+	    
+	    printf(" myNodeId: %d\n",newNodeId);
+	    // Step 2. for the new node just put in path
+	    // find the next hop to the new node
+	    LsNodeIdList nhl;
+	    LsNodeIdList *nhlp = &nhl; // nextHopeList pointer
+    	    
+	    if (newNodeId != myNodeId_) {
+						
+			// if not looking at my own links, find the next hop 
+			// to new node for the mti
+			nhlp = pPaths->lookupNextHopListPtr(newNodeId,i);
+			if (nhlp == NULL)
+				ls_error("computeRoutes: nhlp == NULL \n");
+	    }
+
+   	    // for each of it's links
+ 	    for (RouterLinkStateList::iterator itrList = lslPtr_->begin();
+              itrList != lslPtr_->end(); itrList++){
+
+	      printf("Nodo vecino: %d\n",(*itrList).Link_ID_);
+	      int dest=	(*itrList).Link_ID_;
+
+	      if((*itrList).state_==LS_STATUS_DOWN){
+		  continue;
+	      }		
+	      //look for the cost attach to the mtid=i
+	      for (MTLinkList::iterator itrList2 = (&(*itrList))->MTLinkList_.begin();
+              itrList2 != (&(*itrList))->MTLinkList_.end(); itrList2++){
+		
+	        if((&(*itrList2))->mtId_==i) {
+		   path_cost = (*itrList2).metric_+
+			pPaths->lookupCost(newNodeId,i);	
+		printf("Mtid: %d Coste: %d\n",i,path_cost);
+		 break;
+		} //fi
+	      } //for mtids
+			
+		
+ 	     if (pPaths->lookupCost(dest,i) < path_cost){
+		printf("better path already in paths\n");
+		// better path already in paths, 
+		// move on to next link
+		continue;
+		}
+		
+
+	     else {
+		 // else we have a new or equally good path, 
+		 // OspfPathsTentative::insertPath(...) will 
+		 // take care of checking if the new path is
+		 // a better or equally good one, etc.
+		  LsNodeIdList nextHopList;
+		    if (newNodeId == myNodeId_) {
+		      // destination is directly connected, 
+		      // nextHop is itself
+		      printf("newNodeId==myNodeId\n");	
+		      nextHopList.push_back(dest);
+		      nhlp = &nextHopList;
+		      
+		    }
+		
+                  pTentativePaths->insertNextHopList(dest,						   					path_cost,i, *nhlp);
+		  } //else
+	   }// for -RouterLinks
+  
+	    done = true;
+           	
+		// if tentatives empty, terminate;
+		while (!pTentativePaths->empty()) {
+			// else pop shortest path  from tentatives
+			OspfPath sp = pTentativePaths->popShortestPath(i);
+			if (!sp.isValid())
+				ls_error (" popShortestPath() failed\n");
+			// install the newly found shortest path among 
+			// tentatives
+			printf("Destino:%d, mtid:%d, coste:%d nextHop:%d\n",
+			sp.desId_,sp.mtId_,sp.cost_,sp.nextHop_);
+			pPaths->insertPath(sp);
+			newNodeId = sp.desId_;
+			ptrLSLAd = linkStateDatabase_.findPtr(newNodeId);
+			
+			if (ptrLSLAd!=NULL) {
+				printf("ptrLSAd !=empty\n");
+				//if we have the link state for the new node
+				// break out of inner do loop to continue 
+				// computing routes
+				//get the first advertising: in this implementation is the one used
+				//OspfLinkState lsad = ptrLSLAd->front();
+				lsad = ptrLSLAd->front();
+				
+				//LSA whose LSage field is equal to MaxAge, is not used in computing 					routing table
+				if(lsad.ls_hdr_.LSage_==MAX_AGE){
+					continue;
+				}
+				//RouterLinkStateList* lslPtr_= lsad.RouterLinkStateListPtr_;
+				lslPtr_= lsad.RouterLinkStateListPtr_;
+				done = false;
+				break;
+			} 
+			// else  we don't have linkstate for this new node, 
+		// we need to keep popping shortest paths
+
+		} //while
+	   }//while done    
+	 } //for -mtids	
+	
+	//PRUEBA
+	printf("CONTENIDO TABLA ROUITNG\n");
+	printf("Nodo actual: %d\n",myNodeId_);
+	
+	for (OspfMTPathsMap::iterator itrMap = pPaths->begin();
+            itrMap != pPaths->end(); itrMap++) {
+ 	    printf("Nodo destino: %d\n",(*itrMap).first);	
+	    OspfMTRouterPathsMap * pEPM =&(*itrMap).second;
+		for (OspfMTRouterPathsMap::iterator itrMap2 = pEPM->begin();
+	            itrMap2!= pEPM->end(); itrMap2++) {
+			printf("Mtid: %d\n",(*itrMap2).first);
+			printf("Coste: %d\n",(*itrMap2).second.cost);
+			LsNodeIdList* nextHopListPtr_=&((*itrMap2).second.nextHopList);
+			for (LsNodeIdList::iterator itrList = nextHopListPtr_->begin();
+	            	itrList!= nextHopListPtr_->end(); itrList++) {
+			printf("Next hop %d\n",*itrList);
+			}
+			
+		}
+	    		
+	}
+
+	
+	//is neccesary to re-calculate routes in tcl
+	myNodePtr_-> routeChanged();
+	
+	return pPaths;
+}
+
+
+int OspfRouting::getnodeid()
+{
+	return myNodeId_;
+}
+
+#endif
diff -Naur ns-2.35-orig/ospf/ospf.h ns-2.35/ospf/ospf.h
--- ns-2.35-orig/ospf/ospf.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/ospf/ospf.h	2015-01-24 16:57:49.559073332 +0100
@@ -0,0 +1,1220 @@
+/*
+ * ospf.h
+ * Copyright (C) 2006 by the University of Extremadura
+ * This program is free software: you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public License as published by 
+ * the Free Software Foundation, either version 3 of the License, or 
+ * (at your option) any later version. This program is distributed in the 
+ * hope that it will be useful, but WITHOUT ANY WARRANTY; without 
+ * even the implied warranty of MERCHANTABILITY or FITNESS FOR 
+ * A PARTICULAR PURPOSE. See the GNU General Public License 
+ * for more details. You should have received a copy of the GNU General 
+ * Public License along with this program. If not, see <http://www.gnu.org/licenses/>. 
+ */
+
+// by Inés María Romero Dávila (inroda04@alumnos.unex.es)
+// and Alfonso Gazo Cervero (agazo@unex.es)
+
+/***********************************************************************************
+ Módulo en el que se crean las estructuras y procedimientos necesarios para la 
+ simulación del  protocolo OSPF. Contiene: definiciones de las estructuras del 
+ protocolo: paquetes OSPF, registros de estado de enlace, base de datos de estado de 
+ enlace, tabla de routing, manejador de ack's y 
+ retransmisiones, manejador de paquetes hello, definición de estructuras de almacenamiento 
+ de mensajes. Muchas de estas estructuras ya existían en el modulo linkstate, y han 
+ sido redefinidas para adecuarlas a este protocolo de estado de enlace especifico.
+************************************************************************************/
+
+#ifndef ns_ospf_h
+#define ns_ospf_h
+
+#include "linkstate/ls.h"
+#include "hdr-ospf.h"
+#include "utils.h"
+
+//**********************************************************************************
+// LinkStateHeader: representing the link state advertisement header
+//**********************************************************************************
+
+struct LinkStateHeader {
+
+// public data
+	double 	LSage_;	//link state advertisement age
+	options_t options_; 
+	LS_type_t	LS_type_; //advertisement type
+	u_int32_t	LS_ID_; // advertisement identification
+	u_int32_t	advertising_router_; // OSPF advertising router identification; 
+	double	        LS_sequence_num_;   
+	u_int16_t	length_;  
+
+//public methods
+	LinkStateHeader() : LSage_(LS_BIG_NUMBER), options_(options_t(0,0)), LS_type_(LS_INVALID),
+	LS_ID_(LS_INVALID_NODE_ID), advertising_router_(LS_INVALID_NODE_ID),LS_sequence_num_(0),length_(0) {}
+
+	LinkStateHeader(double lsage, options_t op, LS_type_t ls_type, u_int32_t ls_id, u_int32_t 		adv_router,double seq_num, u_int16_t len): LSage_(lsage), options_(op),LS_type_(ls_type), LS_ID_(ls_id), advertising_router_(adv_router),
+	LS_sequence_num_(seq_num),length_(len) {}
+
+	void init (double lsage, options_t op, LS_type_t ls_type, u_int32_t ls_id, u_int32_t adv_router,double seq_num, u_int16_t len){
+
+	  LSage_= lsage;
+	  options_= op;
+ 	  LS_type_= ls_type;
+	  LS_ID_= ls_id;
+	  advertising_router_= adv_router;
+	  LS_sequence_num_= seq_num;
+          length_= len;
+
+	}
+
+};
+
+//**********************************************************************************
+// MTLink: representing MultiTopology id and metric attached to a link
+//**********************************************************************************
+
+struct MTLink {
+
+//public data
+	int	mtId_; // MultiTopology id
+	int 	metric_; // metric used for routing
+
+//public methods
+	MTLink (): mtId_(0), metric_(0) {}
+	MTLink (int MtId, int m): mtId_(MtId), metric_(m) {}
+	void init (int MtId, int m){
+	mtId_= MtId;
+	metric_= m;
+	}
+};
+
+//**********************************************************************************
+// MTLinkList: List of MTLink attached to a link
+//**********************************************************************************
+
+typedef LsList<MTLink> MTLinkList;
+
+
+//**********************************************************************************
+// RouterLinkState: representing a router link state advertisement
+//**********************************************************************************
+
+struct RouterLinkState {
+
+//public data
+	ls_status_t	state_; // UP or DOWN
+	
+	u_int32_t	Link_ID_; // neighbour IP address
+	u_int32_t 	Link_data_; // depend on the link's type field
+	RouterLink_type_t Type_; //description of the router link
+	int 	Num_MT_; //number of different MT id's .
+	int 	MT0_metric_; //cost of using this router link for MT 0
+	MTLinkList MTLinkList_; //MT id's and metrics attached to the link
+
+//public methods
+	RouterLinkState (): state_(LS_STATUS_UP), Link_ID_(LS_INVALID_NODE_ID), Link_data_(LS_INVALID_NODE_ID), Type_(routerLink_type_default), Num_MT_(0), MT0_metric_(0) {}
+
+	RouterLinkState (ls_status_t st,u_int32_t link_id, u_int32_t link_data, RouterLink_type_t type, int nmt, int  mt0_m): state_(st),Link_ID_(link_id), Link_data_(link_data), Type_(type), Num_MT_(nmt), MT0_metric_(mt0_m) {}
+	
+	void init (ls_status_t st, u_int32_t link_id, u_int32_t link_data, RouterLink_type_t type, int nmt, int mt0_m){
+	state_=st;
+	Link_ID_=link_id;
+	Link_data_=link_data;
+	Type_=type;
+	Num_MT_=nmt;
+	MT0_metric_=mt0_m;
+	}	
+};
+
+
+//**********************************************************************************
+// RouterLinkStateList: representing the router links state
+//**********************************************************************************
+
+typedef LsList<RouterLinkState> RouterLinkStateList;
+
+//****************************************************************************
+// RouterLinksState: representing a router links state advertisment 
+//****************************************************************************
+
+struct RouterLinksState {
+	
+//public data
+	VEB_t VEB_; // V=virtual, E=external, B=border 
+	int links_; //number of router links described by this advertisment
+	RouterLinkStateList RouterLinkStateList_;
+
+//public methods
+	RouterLinksState ():VEB_(VEB_t(0,0,0)),links_(0){}
+	RouterLinksState (VEB_t veb, int links): VEB_(veb),links_(links){}
+	void init (VEB_t veb, int links){
+        VEB_=veb;
+	links_=links;
+        }
+
+};
+
+//**********************************************************************************
+// NetworkLinksState: representing a network links state advertisment
+//**********************************************************************************
+
+struct NetworkLinksState {
+
+//public data
+	u_int32_t network_mask_; 
+	LsNodeIdList attachedRouterList_; 
+
+//public methods
+	NetworkLinksState (): network_mask_(0){}
+	NetworkLinksState (u_int32_t network_mask): network_mask_(network_mask){}
+
+	void init (u_int32_t network_mask) {
+	//ls_hdr_.LS_type_=LS_NETWORK;
+	network_mask_=network_mask;
+	}
+};
+
+
+//**********************************************************************************
+// SummaryLinkState: representing a summary link state advertisment
+//**********************************************************************************
+
+struct SummaryLinkState{
+
+//public data
+
+	u_int32_t network_mask_; 
+	MTLinkList MTLinkList_;//MT id's and metrics attached to the link
+
+//public methods
+	SummaryLinkState (): network_mask_(0){}
+	SummaryLinkState (u_int32_t network_mask): network_mask_(network_mask){}
+
+	void init (u_int32_t network_mask) {
+	network_mask_=network_mask;
+	}
+
+};
+
+//**********************************************************************************
+// OspfLinkState
+//**********************************************************************************
+
+struct OspfLinkState {
+//public data
+LinkStateHeader ls_hdr_; // link state header
+
+	OspfLinkState():ls_hdr_(){}
+
+ union {
+	RouterLinkStateList* RouterLinkStateListPtr_;
+	SummaryLinkState* SummaryLinkState_;
+	NetworkLinksState* NetworkLinksState_;
+  	};
+};
+
+//**********************************************************************************
+// OspfLinkStateList: representing a ospf link state list
+//**********************************************************************************
+
+typedef LsList<OspfLinkState> OspfLinkStateList;
+
+//**********************************************************************************
+// OspfTopoMap: the Link State Database, the representation of the
+//  topology within the protocol 
+//**********************************************************************************
+
+typedef LsMap<int, OspfLinkStateList> OspfLinkStateMap;
+
+class OspfTopoMap : public OspfLinkStateMap{
+public:
+
+//public methods
+	
+	//constructor
+	OspfTopoMap() : OspfLinkStateMap() {}
+  
+	// map operation
+	iterator begin() { return OspfLinkStateMap::begin();}
+	iterator end() { return OspfLinkStateMap::end();}
+	
+	
+	// insert the LSA
+	OspfLinkStateList* insertLinkState (int nodeId, OspfLinkState& link_state);
+	
+	// update the database and returns true if there's change
+	bool update(int nodeId, const OspfLinkStateList& linkStateAdvList);
+
+	//get the content of THE link state database
+	OspfLinkStateList getLSList ();
+
+	//delete the LSA
+	void delLSA (int nodeId, LS_type_t ls_type, u_int32_t ls_id, u_int32_t advertising_router);
+
+	
+	//get the link state advertisment indexed by the parameters
+	OspfLinkState getLSA (LS_type_t ls_type, u_int32_t ls_id, u_int32_t advertising_router);
+	
+	// return NO_EXIST if the LSA does not exist, EQUALS if the two instances are 
+	// equal, OLDER if the LSA received is older than the database copy, and NEWER if 
+	// it is newer 
+	retCode_t lookupLSA (LinkStateHeader hdr);
+	
+	// reloaded funtion: called by OspfRouting when receive a request packet
+	bool lookupLSA (LS_type_t ls_type, u_int32_t ls_id, u_int32_t advertising_router); 
+	
+	//increments LSA's LSage field for nodeId if possible 
+	void incLSage (int nodeId);
+
+	//returns true if it is necessary to calculate the routing table and false in other case
+	bool updateRoutingTable (int nodeId, OspfLinkState& linkStateAdv);
+	
+	//   friend ostream & operator << ( ostream & os, LsTopoMap & x) ;
+	void setNodeId(int id) { myNodeId_ = id ;}
+
+private:
+//private data
+	int myNodeId_; // for update()
+};
+
+
+typedef OspfTopoMap OspfTopology;
+typedef OspfTopoMap* OspfTopoMapPtr;
+
+//**********************************************************************************
+// OspfPath: representing ospf path data
+//**********************************************************************************
+
+struct OspfPath {
+
+	int desId_; // destination id
+	int cost_; //path cost
+	int nextHop_; // next hop in the path
+	int mtId_; // multiTopology id
+
+	// constructors
+	OspfPath() : desId_ (LS_INVALID_NODE_ID) {}
+	OspfPath(int dest, int c, int nh, int Mtid)
+		: desId_ (dest), cost_(c), nextHop_(nh),mtId_(Mtid) {}
+	
+	bool isValid() { 
+		return ((desId_ != LS_INVALID_NODE_ID) && 
+			(cost_ != LS_INVALID_COST) && 
+			(nextHop_ != LS_INVALID_COST) &&
+			(mtId_!= LS_INVALID_COST));
+	}
+
+};
+
+
+//**********************************************************************************
+// OspfEqualPaths: A struct with the cost and a list of multiple next hops used by 
+// OspfPaths. 
+//**********************************************************************************
+
+struct OspfEqualPaths {
+public:
+	int  cost; //path cost
+	LsNodeIdList nextHopList; // next hop list
+
+	// constructors
+	OspfEqualPaths() : cost(LS_INVALID_COST) {}
+	OspfEqualPaths(int c, int nh) : cost(c), nextHopList() {
+		nextHopList.push_back(nh);
+	}
+	OspfEqualPaths(const OspfPath & path) : cost (path.cost_), nextHopList() {
+		nextHopList.push_back(path.nextHop_);
+	}
+	OspfEqualPaths(int c, const LsNodeIdList & nhList) 
+		: cost(c), nextHopList(nhList) {}
+  
+	OspfEqualPaths& operator = (const OspfEqualPaths & x ) {
+		cost = x.cost;
+		nextHopList = x.nextHopList;
+		return *this;
+	}
+
+	// copy 
+	OspfEqualPaths& copy(const OspfEqualPaths & x) { return operator = (x) ;}
+
+	// appendNextHopList 
+	int appendNextHopList(const LsNodeIdList & nhl) {
+		return nextHopList.appendUnique (nhl);
+	}
+};
+
+//**********************************************************************************
+// OspfMTRouterPathsMap: store paths for each mt id.
+//**********************************************************************************
+
+typedef LsMap<int,OspfEqualPaths > OspfMTRouterPathsMap;
+
+//**********************************************************************************
+// OspfMTPathsMap: store paths for each node and for each mt id
+//**********************************************************************************
+
+typedef LsMap<int,OspfMTRouterPathsMap> OspfMTPathsMap;
+
+
+//**********************************************************************************
+//  OspfPaths -- enhanced OspfMTPathsMap, used in OspfRouting
+//**********************************************************************************
+class OspfPaths : public OspfMTPathsMap {
+public:
+	//publid methods
+	OspfPaths(): OspfMTPathsMap() {}
+  
+	// -- map operations 
+	iterator begin() { return OspfMTPathsMap::begin();}
+	iterator end() { return OspfMTPathsMap::end();}
+
+	// -- specical methods that make easier computeRoutes of OspfRouting
+	
+	// lookup the path's cost for the destId and Mtid
+	int lookupCost(int destId, int Mtid) {
+		OspfMTRouterPathsMap * pEPM = findPtr (destId);
+	if (pEPM == NULL ) return LS_MAX_COST + 1;
+	else {	
+		OspfEqualPaths * pEP = pEPM->findPtr(Mtid);
+	
+	if ( pEP == NULL ) return LS_MAX_COST + 1;
+		 else
+		return pEP->cost;
+	     }		
+	}
+
+	// lookup next hop list for the destId and Mtid
+	LsNodeIdList* lookupNextHopListPtr(int destId,int Mtid) {
+		OspfMTRouterPathsMap * pEPM = findPtr (destId);
+		if (pEPM == NULL) 
+			return (LsNodeIdList *) NULL;
+		else {
+		OspfEqualPaths * pEP = pEPM->findPtr(Mtid);
+		if (pEP == NULL ) 
+			return (LsNodeIdList *) NULL;
+		 else
+		return &(pEP->nextHopList);
+		}
+	}
+  
+	// insert Path without checking validity
+	iterator insertPathNoChecking(int destId, int Mtid, int cost, int nextHop) {
+		
+		OspfMTRouterPathsMap * pEPM = findPtr (destId);
+		iterator itr;
+		if (pEPM == NULL) {
+
+		  OspfEqualPaths ep(cost, nextHop);
+ 		  OspfMTRouterPathsMap  pEPM;
+		  itr = insert(destId,pEPM);
+		  (& (* itr).second)->insert(Mtid,ep);
+		  itr=find(destId);
+		  return itr; // for clarity
+		  }
+		
+		//else
+		OspfEqualPaths * pEP = pEPM->findPtr(Mtid);
+		if (pEP == NULL ) {
+		  OspfEqualPaths ep(cost, nextHop);
+		  pEPM->insert(Mtid,ep);
+		  itr=find(destId);
+		  return itr;	  
+		  }
+		
+ 		return itr;
+	}     
+
+	// insert Path without checking validity
+	iterator insertPathNoChecking (const OspfPath & path) {
+		return insertPathNoChecking(path.desId_, path.mtId_,path.cost_, 
+					    path.nextHop_);
+	}
+
+	// insert Path  checking validity. Returns end() if error, else returns iterator
+	iterator insertPath(int destId, int mtid, int cost, int nextHop);
+	// insert Path  checking validity. Returns end() if error, else returns iterator
+	iterator insertPath(const OspfPath& path) {
+		return insertPath(path.desId_, path.mtId_,path.cost_, path.nextHop_);
+	}
+	
+	// insert next hop list for destId and mtid
+	iterator insertNextHopList(int destId, int cost, int mtid,
+				   const LsNodeIdList& nextHopList);
+};
+
+//**********************************************************************************
+//  OspfPathsTentative:  Used in OspfRouting, remembers min cost and location 
+//**********************************************************************************
+
+class OspfPathsTentative : public OspfPaths {
+public:
+	//public methods
+	OspfPathsTentative() : OspfPaths(), minCost(LS_MAX_COST+1) {
+		minCostIterator = end();
+	}
+  
+	// combining get and remove min path
+	OspfPath popShortestPath(int mtid);
+  
+private:
+	//private data
+	int minCost; // remembers the min cost
+	iterator minCostIterator; // remembers where it's stored
+	//private methods
+	// returns the iterator for the less cost path for mtid
+	iterator findMinEqualPaths(int mtid); 
+};
+
+//******************************************************************************
+// HelloPacket: Packets sent within the Hello protocol
+//****************************************************************************** 
+
+struct HelloPacket {
+//public data
+
+	u_int32_t networkMask_; // network mask associated with this interface
+	double helloInterval_; // number of seconds between this router's Hello packets
+	options_t options_; //optional captabilites supported by the router
+	double deadInterval_; // number of seconds before declaring a silent router down
+	LsNodeIdList* neighbourListPtr_; // Router IDs of each router from whom valid Hello packets 
+				      // have been seen in the last deadInterval seconds.
+//public methods
+
+	HelloPacket (): networkMask_(0),options_(options_t(0,0)){}
+
+	HelloPacket (u_int32_t network_mask, double hello_interval, options_t opt,double 		dead_interval):
+	networkMask_(network_mask),helloInterval_(hello_interval),
+	options_(opt),deadInterval_(dead_interval){}
+ 
+	void init (u_int32_t network_mask, double hello_interval, options_t opt,double 		dead_interval){
+
+	networkMask_=network_mask;
+	helloInterval_=hello_interval;
+	options_=opt;
+	deadInterval_=dead_interval;
+	}
+
+};		
+	
+
+//******************************************************************************
+// Link State Header List
+//****************************************************************************** 
+typedef LsList<LinkStateHeader> LinkStateHeaderList;
+
+
+//******************************************************************************
+// Database Description Packet: Packet sent within exchange protocol
+//****************************************************************************** 
+
+struct DDPacket {
+//public data
+
+	options_t options_; //optional captabilites supported by the router
+	IMMS_t IMMSbits_; // I=initialize M=more MS=master/slave
+	double DDSeqNumber_; // sequence number
+	LinkStateHeaderList* lsHeaderListPtr_; // link state advertisment header list
+
+//public methods
+	 
+	DDPacket():options_(options_t(0,0)),IMMSbits_(IMMS_t(0,0,0)),DDSeqNumber_(LS_INVALID_NODE_ID){}
+
+	DDPacket (options_t opt,IMMS_t imms_bits, double seq_num):options_(opt),IMMSbits_(imms_bits),DDSeqNumber_(seq_num){}
+ 
+	void init (options_t opt, IMMS_t imms_bits, double seq_num){
+
+	options_=opt;
+	IMMSbits_=imms_bits;
+	DDSeqNumber_=seq_num;
+	}
+
+};		
+
+//******************************************************************************
+// Link State Record Identifier
+//****************************************************************************** 
+
+struct LinkStateRecordId {
+	
+	LS_type_t type_; // record type
+	u_int32_t lsID_; //link state record identifier
+	u_int32_t advertisingRouter_; //advertising router identifier
+LinkStateRecordId (LS_type_t type,u_int32_t lsId, u_int32_t advRouter):type_(type),lsID_(lsId),advertisingRouter_(advRouter){}
+ 
+};
+
+
+//******************************************************************************
+// Link State Record Identifier List
+//****************************************************************************** 
+
+typedef LsList<LinkStateRecordId> LinkStateRecordIdList;
+ 
+//******************************************************************************
+// Request Packet: Packet sent within exchange protocol
+//****************************************************************************** 
+
+struct RequestPacket {
+//public data
+	LinkStateRecordIdList* linkStateRecordIdListPtr_;
+	
+//public methods
+	 
+	void init (void){
+	}
+};		
+
+//******************************************************************************
+// Update Packet: Packet sent within exchange and flooding protocol
+//****************************************************************************** 
+
+struct UpdatePacket {
+//public data
+
+	int numberAdvert_; //The number of link state advertisements 
+	OspfLinkStateList* LsListAdvertPtr_; // link state advertisment list
+	
+//public methods
+	 
+	UpdatePacket(): numberAdvert_(0), LsListAdvertPtr_(NULL){}
+	UpdatePacket(int num_advert): numberAdvert_(num_advert){}
+	void init (int num_advert){
+	numberAdvert_=num_advert;	
+	}
+
+};		
+
+//******************************************************************************
+// Ack Packet: Packet sent to ack update packets
+//****************************************************************************** 
+
+
+struct AckPacket {
+//public data
+
+	LinkStateHeaderList* lsHeaderListPtr_; // link state advertisment header list
+	
+//public methods
+	 void init (void){
+	}
+
+};		
+
+
+
+//******************************************************************************
+// OspfMessage : store the message's information 
+//****************************************************************************** 
+
+struct OspfMessage {
+
+//public data
+
+u_int32_t messageId_; // ospf message id 
+int originNodeId_; // originator node id: used in acknowledging
+
+	OspfMessage() : messageId_(LS_INVALID_NODE_ID)	{}
+
+	union {
+		HelloPacket* HelloPacketPtr_;
+		DDPacket* DDPacketPtr_;
+                UpdatePacket* UpdatePacketPtr_; 
+                RequestPacket* RequestPacketPtr_;
+		AckPacket* AckPacketPtr_;	
+	};
+
+};
+
+//******************************************************************************
+// OspfMessageCenter:  Global storage of Message's for retrieval
+//****************************************************************************** 
+
+class OspfMessageCenter {
+public:
+	typedef LsMap <u_int32_t, OspfMessage> baseMap;
+	// constructor
+	OspfMessageCenter () 
+		: current_hello_id(LS_INVALID_MESSAGE_ID), 
+		current_dd_id(LS_INVALID_MESSAGE_ID),
+		current_request_id(LS_INVALID_MESSAGE_ID),
+		current_update_id(LS_INVALID_MESSAGE_ID),
+		current_ack_id(LS_INVALID_MESSAGE_ID) {}
+  	
+	// set the max size of the structure taking into account the number of nodes of the topology
+	void setNodeNumber (int number_of_nodes) {
+		max_size = number_of_nodes * LS_MESSAGE_CENTER_SIZE_FACTOR;
+	}
+
+	// create and returns a new message
+	OspfMessage* newMessage (int senderNodeId, Ospf_message_type_t type);
+	
+	u_int32_t duplicateMessage( u_int32_t msgId) {
+		return msgId;
+	}
+
+	u_int32_t duplicateMessage(const OspfMessage& msg) {
+		return duplicateMessage(msg.messageId_);
+	}
+
+	// deletes the message and returns true if the deletion is done and false in other case
+	bool deleteMessage(u_int32_t msgId, Ospf_message_type_t type);
+
+	//Returns the ospf message taking into account the type and the id of the 
+	//message 
+	OspfMessage* retrieveMessagePtr(u_int32_t msgId, Ospf_message_type_t type);
+	
+	static OspfMessageCenter& instance() { 
+		return msgctr_;
+	}
+
+private:
+	static OspfMessageCenter msgctr_;	// Singleton class
+	// current number id used for the differents packets.
+	u_int32_t current_hello_id;
+	u_int32_t current_dd_id ;
+	u_int32_t current_request_id;
+	u_int32_t current_update_id;
+	u_int32_t current_ack_id;
+
+	unsigned int max_size; // if size() greater than this number, erase begin().
+	typedef LsMap <u_int32_t, OspfMessage> message_storage;
+	// storage used for the differents packets
+	message_storage hello_messages;
+	message_storage dd_messages;
+	message_storage request_messages;
+	message_storage update_messages;
+	message_storage ack_messages;
+
+	void init();
+};
+
+
+//********************************************************************************
+// OspfRetransTimer: representing the timer retrieval for dd and request packets
+//********************************************************************************
+ 
+
+class OspfRetransmissionManager;
+class OspfRetransTimer : public TimerHandler {
+public:
+	OspfRetransTimer() {}
+	OspfRetransTimer (OspfRetransmissionManager *amp , int nbrId)
+		: ackManagerPtr_(amp), neighbourId_(nbrId) {}
+	virtual void expire(Event *e);
+protected:
+	OspfRetransmissionManager* ackManagerPtr_;
+	int neighbourId_;
+};
+
+//******************************************************************************
+// OspfRetransUpdateTimer: representing the timer retrieval for updates 
+//****************************************************************************** 
+
+class OspfRetransUpdateTimer : public TimerHandler {
+public:
+	OspfRetransUpdateTimer() {}
+	OspfRetransUpdateTimer (OspfRetransmissionManager *amp , int nbrId)
+		: ackManagerPtr_(amp), neighbourId_(nbrId) {}
+	virtual void expire(Event *e);
+protected:
+	OspfRetransmissionManager* ackManagerPtr_;
+	int neighbourId_;
+	
+};
+
+//******************************************************************************
+// OspfIdSeq: representing the id and sequence number of a message 
+//****************************************************************************** 
+
+struct OspfIdSeq {
+	u_int32_t msgId_; //message id
+	double seq_; // sequence number
+	OspfIdSeq():msgId_(LS_INVALID_MESSAGE_ID),seq_(LS_INVALID_MESSAGE_ID) {}
+	OspfIdSeq(u_int32_t id, u_int32_t s) : msgId_(id), seq_(s) {}
+};
+
+//********************************************************************************
+// OspfUnackPeer: used in ackManager to keep record a peer who still haven't ack 
+// some of  its Update or DD packets
+//********************************************************************************
+
+struct OspfUnackPeer {
+	double rtxTimeout_; // time out value for ackTimer
+	OspfRetransTimer ackTimer_;
+	OspfRetransUpdateTimer updateTimer_;
+	OspfIdSeq DdSeq_;  
+	u_int32_t  ReqSeq_; // Request message id
+	LsMap<int, u_int32_t> UpdateMap_; //update messages
+	 
+	// constructor
+	OspfUnackPeer() : DdSeq_(), ReqSeq_(LS_INVALID_MESSAGE_ID), UpdateMap_(){}
+	OspfUnackPeer(OspfRetransmissionManager* amp, int nbrId, 
+		    double timeout = RXMT_INTERVAL) : 
+		rtxTimeout_(timeout), ackTimer_(amp, nbrId),updateTimer_(amp,nbrId), DdSeq_(),
+		ReqSeq_(LS_INVALID_MESSAGE_ID), UpdateMap_(){}
+};
+
+
+//******************************************************************************
+//  OspfRetransmissionManager -- handles retransmission,acknowledgement  
+//******************************************************************************
+class OspfRouting;
+class OspfRetransmissionManager : public LsMap<int, OspfUnackPeer> {
+public:
+	OspfRetransmissionManager(OspfRouting& lsr) : OspfRouting_(lsr) {} 
+
+	void initTimeout(LsDelayMap* delayMapPtr);
+	void cancelTimer(int neighbourId);
+	
+	// Called by OspfRouting when a message is sent out 
+	int messageOut(int peerId, const OspfMessage& msg,Ospf_message_type_t type);
+  
+	// Called by OspfRouting when an message is received
+	int messageIn(int peerId,  const OspfMessage& msg,Ospf_message_type_t type);
+
+	// Called by retransmit timer
+	int resendMessages(int peerId);
+	
+
+private:
+	// data
+	OspfRouting& OspfRouting_;
+};
+
+inline void OspfRetransTimer::expire(Event *e) 
+{ 
+	ackManagerPtr_->resendMessages(neighbourId_); 
+}
+
+
+inline void OspfRetransUpdateTimer::expire(Event *e)
+{
+	ackManagerPtr_->resendMessages(neighbourId_);
+}
+
+//******************************************************************************
+// OspfInactivityTimer: representing the inactivity timer used to detect
+// routers down
+//****************************************************************************** 
+
+class OspfInactivityManager;
+class OspfInactivityTimer : public TimerHandler {
+public:
+	OspfInactivityTimer() {}
+	OspfInactivityTimer (OspfInactivityManager *amp , int nbrId)
+		: inactivityManagerPtr_(amp), neighbourId_(nbrId) {}
+	virtual void expire(Event *e);
+protected:
+	OspfInactivityManager* inactivityManagerPtr_;
+	int neighbourId_;
+};
+
+
+//******************************************************************************
+// OspfHelloPeer: used in inactivityManager to keep record a peer timer
+//******************************************************************************
+
+struct OspfHelloPeer {
+	double routerDeadInterval_; // time out value for inactivity timer
+	OspfInactivityTimer inactivityTimer_;
+	
+	 
+
+	// constructor
+	OspfHelloPeer() {}
+	OspfHelloPeer(OspfInactivityManager* amp, int nbrId, 
+		    double timeout = RXMT_INTERVAL) : 
+		routerDeadInterval_(timeout), inactivityTimer_(amp, nbrId){}
+};
+
+
+//******************************************************************************
+//  OspfInactivityManager: handles inactivity timer  
+//******************************************************************************
+
+class OspfInactivityManager : public LsMap<int, OspfHelloPeer> {
+public:
+	OspfInactivityManager(OspfRouting& lsr) : OspfRouting_(lsr) {} 
+
+	void initTimeout(LsNodeIdList* peerIdListPtr,double router_dead_interval);
+	void cancelTimer(int neighbourId);
+	
+	// Called by OspfRouting when a message is sent out 
+	int messageOut(int peerId, Ospf_message_type_t type);
+  
+	// Called by OspfRouting when an message is received
+	int messageIn(int peerId, Ospf_message_type_t type);
+
+	// Called by inactivity timer
+	int setNeighbourDown(int peerId);
+	
+
+private:
+	// data
+	OspfRouting& OspfRouting_;
+};
+
+inline void OspfInactivityTimer::expire(Event *e) 
+{ 
+	inactivityManagerPtr_->setNeighbourDown(neighbourId_); 
+}
+
+
+//******************************************************************************
+// LsAgingTimer: used to increment the LSAs LSage when they are store in the
+// database
+//****************************************************************************** 
+
+class LsAgingManager;
+class LsAgingTimer : public TimerHandler {
+public:
+	LsAgingTimer() {}
+	LsAgingTimer (LsAgingManager *amp , int nbrId)
+		: LsAgingManagerPtr_(amp), neighbourId_(nbrId) {}
+	virtual void expire(Event *e);
+protected:
+	LsAgingManager* LsAgingManagerPtr_;
+	int neighbourId_;
+};
+
+
+//******************************************************************************
+// LSAPeer: used in LsAgingManager to keep record a peer LSA timer 
+//******************************************************************************
+
+struct LSAPeer {
+	double LsAgingInterval_; // 1 second
+	LsAgingTimer LsTimer_;
+	 
+
+	// constructor
+	LSAPeer () {}
+	LSAPeer (LsAgingManager* amp, int nbrId, 
+		    double timeout = 1) : 
+		LsAgingInterval_(timeout), LsTimer_(amp, nbrId){}
+};
+
+
+//******************************************************************************
+//  LsAgingManager: handles LsAging timer  
+//******************************************************************************
+
+class LsAgingManager : public LsMap<int, LSAPeer> {
+public:
+	LsAgingManager (OspfRouting& lsr) : OspfRouting_(lsr) {} 
+
+	void initTimeout (int nodeId);
+	void cancelTimer(int neighbourId);
+	
+	// Called by OspfRouting when a LSA is created or inserted in the database 
+	int createLSA (int peerId);
+  
+	// Called by LsAging timer
+	int ageLSA(int peerId);
+	
+
+private:
+	// data
+	OspfRouting& OspfRouting_;
+};
+
+inline void LsAgingTimer::expire(Event *e) 
+{ 
+	LsAgingManagerPtr_->ageLSA (neighbourId_); 
+}
+
+
+//**********************************************************************************
+// OspfNeighbour: representing a neighbour data structure 
+//**********************************************************************************
+
+struct OspfNeighbour {
+
+//public data
+StateN_type_t state_; 
+char masterSlave_; // 1-->I'm the master  0--> I'm the slave 
+double  ddSeq_;
+int neighbourId_; // neighbour OSPF Router ID 
+u_int32_t neighbourIpAddr_; // neighbour interface IP address
+options_t options_; // neighbour optional captabilites
+LinkStateHeaderList lsHeaderList_; //link states to send in DD packets to the neighbour
+OspfLinkStateList lsRetransmissionList_; //link states to retransmit to the neighbour
+LinkStateRecordIdList lsRequestList_; // link states to request to the neighbour
+
+//public methods
+ OspfNeighbour (): state_(DOWN), masterSlave_(0),ddSeq_(LS_INVALID_MESSAGE_ID),neighbourId_(LS_INVALID_NODE_ID),options_
+	(options_t(0,0)),lsHeaderList_(),lsRetransmissionList_(),lsRequestList_(){}
+
+ OspfNeighbour (StateN_type_t state,char MS, double ddseq, int nid, options_t op):state_(state),masterSlave_(MS),ddSeq_(ddseq),neighbourId_(nid),options_(op){} 	
+	
+
+};
+
+
+//**********************************************************************************
+// OspfNeighbourMap: representing neighbouring data structures 
+//**********************************************************************************
+
+
+class OspfNeighbourMap : public LsMap<int,OspfNeighbour> {
+public:
+	//public methods
+	OspfNeighbourMap (){}
+	//init Neighbour structure
+	void initNeighbour (LsNodeIdList* peerIdListPtr);
+	// check the state of neighbour nbId
+	bool isState (int nbId,StateN_type_t state);
+	// set the state of neighbour nbId to newState
+	void setState (int nbId, StateN_type_t newState);
+	// get the state of neighbour nbId
+	StateN_type_t getState (int nbId);
+	// set the OSPF router id to nbId
+	void setNeighbourId (int nbId);
+	// get the OSPF router id of nbId
+	int getNeighbourId (int nbId);
+
+	// set the options of neighbour nbId to options_t
+	void setOptions(options_t op,int nbId);
+	// get the options of neighbour nbId
+	options_t getOptions(int nbId);
+	
+	// set the DD sequence number of neighbour nbId to seq
+	void setDDseq (int nbId, double seq);	
+	// increment the DD sequence number of neighbour nbId
+	void incDDseq (int nbId);
+	// get the DD sequence number of neighbour nbId
+	double getDDseq (int nbId);
+	
+	// set the bit masterSlave_ of neighbour nbId to master
+	void setMaster (int nbId);
+	// set the bit masterSlave_ of neighbour nbId to slave
+	void setSlave (int nbId);
+	// get the bit masterSlave of neighbour nbId
+	char getMasterSlave (int nbId);
+
+	// set linkStateHeaderList of neighbour nbId to lshdrl
+	void setLinkStateHeaderList (int nbId,LinkStateHeaderList& lshdrl);
+	// get the linkStateHeaderList of neighbour nbId
+	LinkStateHeaderList getLinkStateHeaderList (int nbId);
+
+	// set linkStateRetransList of neighbour nbId to lsl
+	void setLinkStateRetransList (int nbId,OspfLinkStateList& lsl);
+	// get linkStateRetransList of neighbour nbId
+	OspfLinkStateList getLinkStateRetransList (int nbId);	
+	// lookup the LSA in the linkStateRetransList of the neighbour nbId 
+	// return true if exists and false in other case	
+	bool lookupLSARetrans (int nbId,LinkStateHeader& lshdr);
+	// delete the LSA in the linkStateRetransList of the neighbour nbId
+	bool delLSARetrans (int nbId, LinkStateHeader& lshdr);
+	// add the LSA ls to the linkStateRetransList of the neighbour nbId
+	void addLSARetrans (int nbId, OspfLinkState& ls);
+
+	// set the RequestList of neighbour nbId to lsr
+	void setRequestList (int nbId, LinkStateRecordIdList& lsr);
+	// get the RequestList of neighbour nbId
+	LinkStateRecordIdList getRequestList (int nbId);
+	// del the LSA in the RequestList of neighbour nbId
+	void delLSARequest(int nbId, LinkStateHeader& lshdr);
+	// lookup the LSA in the RequestList of the neighbour nbId 
+	// return true if exists and false in other case
+	bool lookupLSAReq (int nbId, LinkStateHeader& lshdr);
+	
+	// delete all list of neighbour nbId 
+	void delAllLists (int nbId); 
+};
+
+//**********************************************************************************
+//   OspfNode:  represents the node enviroment interface 
+//   It serves as the interface between the Routing class and the actual 
+//   simulation enviroment 
+// rtProtoOSPF will derive from OspfNode as well as Agent
+//**********************************************************************************
+
+class OspfNode {
+public:
+	//constructor
+        virtual ~OspfNode () {}
+	
+	virtual bool sendMessage(int destId, hdr_Ospf hdr) = 0;
+	virtual void receiveMessage(int sender, u_int32_t msgId,Ospf_message_type_t type) = 0;
+	virtual int getNodeId() = 0;
+	virtual RouterLinkStateList* getLinkStateListPtr()=0;
+	virtual LsNodeIdList* getPeerIdListPtr() = 0;
+	virtual LsDelayMap* getDelayMapPtr() = 0;
+	virtual int getNumMtIds() = 0;
+	virtual double getHelloInterval() = 0;
+	virtual double getRouterDeadInterval() = 0;
+	virtual void routeChanged() = 0;
+	virtual void intfChanged()= 0;
+
+	
+};
+
+//******************************************************************************
+//  OspfRouting: The implementation of the Ospf protocol
+//******************************************************************************
+
+class OspfRouting {
+public:
+	static int msgSizes[ OSPF_MESSAGE_TYPES ];
+	friend class OspfRetransmissionManager;
+	friend class OspfInactivityManager;
+	friend class LsAgingManager;
+
+	// constructor 
+	OspfRouting() : myNodePtr_(NULL),  myNodeId_(LS_INVALID_NODE_ID),
+		helloInterval_(LS_INVALID_NODE_ID), routerDeadInterval_(LS_INVALID_NODE_ID), 
+		peerIdListPtr_(NULL), neighbourIdList(), adyacentsIdList(),
+		linkStateListAdvPtr_(NULL),linkStateListPtr_(NULL),messageCenterPtr_(NULL),
+		routingTablePtr_(NULL),	linkStateDatabase_(), AckManager_(*this),neighbourData_(), 			InactivityManager_(*this),AgingManager_(*this),
+		delayMapPtr_(NULL){}
+	
+	// distructor
+	~OspfRouting() {
+		if (routingTablePtr_ != NULL)
+			delete routingTablePtr_;
+	}
+	// initialize the structure
+	bool init(OspfNode* nodePtr);
+	// compute the routing table
+	void computeRoutes() {
+	        if (routingTablePtr_ != NULL)
+	                delete routingTablePtr_;
+	        routingTablePtr_ = _computeRoutes();
+	}
+	// returns the path for destId and Mtid
+	OspfEqualPaths* lookup(int destId,int Mtid) {		
+		if (routingTablePtr_!= NULL){		
+		OspfMTRouterPathsMap* M;
+		M=routingTablePtr_->findPtr(destId);
+		  if (M!=NULL) {		   
+		    OspfEqualPaths* P;
+		    P = M->findPtr(Mtid);
+		    return P;
+		  }
+		}
+	  return (OspfEqualPaths *)NULL;
+	        
+	}
+	// send hellos packets to all active interfaces
+	bool sendHellos();
+	// called by node when one of the link's cost has changed
+	void linkStateChanged();
+	// called by node when one of the interfaces' state has changed
+	void interfaceChanged ();
+	// called by node when messages arrive
+	bool receiveMessage(int senderId , u_int32_t msgId,Ospf_message_type_t type);
+	//increments LSA Lsage field for peer peerId
+	int ageLSA (int peerId);
+	// returns node id
+	int getnodeid();
+	
+
+private:
+	// private data
+	OspfNode * myNodePtr_; // where I am residing in
+	int myNodeId_; // who am I
+	double helloInterval_;  
+	double routerDeadInterval_;
+	LsNodeIdList* peerIdListPtr_; // my ospf peers used to send hello messages
+	LsNodeIdList neighbourIdList; //my neighbours seen in hello protocol
+	LsNodeIdList adyacentsIdList; //my adyacents neighbour's (2-way conectivity)
+	OspfLinkStateList* linkStateListAdvPtr_; // My link state advertisment 
+	RouterLinkStateList* linkStateListPtr_; // My Router links
+	OspfMessageCenter* messageCenterPtr_; // points to static messageCenter
+	OspfPaths* routingTablePtr_; // the routing table
+	OspfTopoMap linkStateDatabase_; // database topology
+	OspfRetransmissionManager AckManager_; // RxmTimeout handler 
+	OspfNeighbourMap neighbourData_; // my neighbours' data structure
+	OspfInactivityManager InactivityManager_; // RouterDeadInterval handler
+	LsAgingManager AgingManager_; // LSA aging timer handler
+	LsDelayMap* delayMapPtr_; //my neighbours delays
+
+
+private:
+	// private methods
+	// get OspfMessageCenter instance
+	OspfMessageCenter& msgctr() { return OspfMessageCenter::instance(); }
+	// compute routing table
+	OspfPaths* _computeRoutes();
+	// get the hello packet 
+	HelloPacket getHelloPkt();
+	// get the Ospf Header
+	hdr_Ospf getOspfHeader ( Ospf_message_type_t type,int msgId);
+	// get the packet length taking into account the type
+	int getLength (Ospf_message_type_t type); 
+	// get the Dd packet for the neighbour nbId
+	DDPacket getDdPkt(int nbId);
+	// get the Request packet for the neighbour nbId
+	RequestPacket getRequestPkt (int nbId);
+
+	// add neighbour nbId to the neighbourIdList
+	void addNeighbourToList (int nbId);
+	// del neighbour nbId from the neighbourIdList
+	void delNeighbourFromList (int nbId);
+	// add neighbour nbId to the adyacentsIdList
+	void addAdyacentToList (int nbId);
+	// del neighbour nbId from adyacentsIdList 
+	void delAdyacentFromList (int nbId);
+
+	// check if there is two way conectivity between the neighbour
+	// from where the message is received and me
+	bool isTwoWayConectivity (OspfMessage* msgPtr);
+	// check if the roles master and slave have been distributed in a correct way
+	bool rolesDistributed(int nbId,OspfMessage* msgPtr);		
+	// check if I am the master
+	bool isSlave(int nbId, OspfMessage* msgPtr);
+	// check if I am the slave
+	bool isMaster(int nbId, OspfMessage* msgPtr);
+	// check if there has been a sequence number mismatch
+	bool isSeqNumberMismatch (int nbId, OspfMessage* msgPtr);
+	// check if the packet received is duplicated
+	bool isPacketDuplicated (int nbId,OspfMessage* msgPtr);
+	// treat the packet duplicated
+	bool managePacketDuplicated(int nbId, OspfMessage* msgPtr);
+	// check if the packet received is the next in the sequence
+	bool isNextPacketSeq(int neighbourId,OspfMessage* msgPtr);
+	// process the packet received
+	bool processPacket(int neighbourId, OspfMessage* msgPtr);
+	// check if the type is valid
+	bool isLsTypeValid (LS_type_t type);
+	// convets an update packet into an ack packet. Used for acknowledging.
+	AckPacket UpdateToAck (UpdatePacket& updpkt);
+	// change the Router LSA's state to st
+	void changeRouterLSAState (int adv_router, int link_id, ls_status_t st);
+	// send the LSA to all adyacents nodes
+	void sendLSAToAdyacents(LS_type_t type, int adv_router, int link_id, int no_dest_node);
+		
+	// receive ospf messages
+	bool receiveHello (int neighbourId, OspfMessage* msgPrt);
+	bool receiveDD (int neighbourId, OspfMessage* msgPtr);
+	bool receiveUpdate (int neighbourId, OspfMessage* msgPtr);
+	bool receiveRequest (int neighbourId, OspfMessage* msgPtr);
+	bool receiveAck (int neighbourId, OspfMessage* msgPtr);
+	
+
+	// send ospf messages
+	void sendDD (int neighbourId);
+	void sendRequest(int neighbourId);
+	void sendUpdate(int originNodeId,int neighbourId,UpdatePacket& updpkt);
+	void sendAck (int nbrId,int originNodeIdAck, LinkStateHeaderList& lshdrl);
+	void resendMessage (int destId, hdr_Ospf hdr) {
+		myNodePtr_->sendMessage(destId,hdr);
+	}
+	//next step in the flooding procedure
+	void sendFlooding (int senderId,OspfLinkState& linkState);
+
+	
+	//neighbour state machine events
+	bool helloReceivedEvent (int nbId);
+	bool twoWayReceivedEvent (int nbId);
+	bool oneWayReceivedEvent (int nbId);
+	void inactivityTimerEvent (int nbId);	
+	bool NegDoneEvent(int nbId);	
+	bool SeqNumberMismatchEvent (int nbId);
+	bool ExchangeDoneEvent(int nbId);
+	bool BadLSReqEvent(int nbId);
+	void LoadingDoneEvent (int nbId);
+
+};
+
+#endif
diff -Naur ns-2.35-orig/ospf/rtProtoOSPF.cc ns-2.35/ospf/rtProtoOSPF.cc
--- ns-2.35-orig/ospf/rtProtoOSPF.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/ospf/rtProtoOSPF.cc	2015-01-24 16:57:49.560073368 +0100
@@ -0,0 +1,473 @@
+/*
+ * rtProtoOSPF.cc
+ * Copyright (C) 2006 by the University of Extremadura
+ * This program is free software: you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public License as published by 
+ * the Free Software Foundation, either version 3 of the License, or 
+ * (at your option) any later version. This program is distributed in the 
+ * hope that it will be useful, but WITHOUT ANY WARRANTY; without 
+ * even the implied warranty of MERCHANTABILITY or FITNESS FOR 
+ * A PARTICULAR PURPOSE. See the GNU General Public License 
+ * for more details. You should have received a copy of the GNU General 
+ * Public License along with this program. If not, see <http://www.gnu.org/licenses/>. 
+ */
+
+// by Inés María Romero Dávila (inroda04@alumnos.unex.es)
+// and Alfonso Gazo Cervero (agazo@unex.es)
+
+
+#include "config.h"
+#ifdef HAVE_STL
+#include "hdr-ospf.h"
+#include "rtProtoOSPF.h"
+#include "agent.h"
+#include "string.h" // for strtok
+
+// Helper classes
+class LsTokenList : public LsList<char *> {
+public:
+	LsTokenList (char * str, const char * delim ) 
+		: LsList<char*> () { 
+		for ( char * token = strtok (str, delim);
+		      token != NULL; token = strtok(NULL, delim) ) {
+			push_back (token);
+		}
+	}
+};
+   
+class LsIntList : public LsList<int> {
+public:
+	LsIntList (const char * str, const char * delim)
+		: LsList<int> () {
+		for ( char * token = strtok ((char *)str, delim);
+		      token != NULL; token = strtok(NULL, delim) ) {
+			push_back ( atoi(token) );
+		}
+	}
+};
+
+/***********************************************************************************
+ Builder: initialize class atributes 
+************************************************************************************/
+
+rtProtoOSPF::rtProtoOSPF(): Agent(PT_RTPROTO_OSPF) {
+OSPF_ready_=0;
+bind("helloInterval",&helloInterval_);
+bind("routerDeadInterval",&routerDeadInterval_);
+
+} 
+
+
+ 
+int rtProtoOSPF::command(int argc, const char*const* argv)
+{
+	Tcl& tcl = Tcl::instance();
+	  char ns_[8];
+ 	 tcl.evalf("Simulator instance");
+  	strcpy(ns_,tcl.result());
+
+
+	if (strcmp(argv[1], "initialize") == 0) {
+		initialize ();
+		return TCL_OK;
+	}
+	if (strcmp(argv[1], "setDelay" ) == 0 ) {
+		if ( argc == 4) {
+			int nbrId = atoi(argv[2]);
+			double delay = strtod ( argv[3], NULL);
+			setDelay(nbrId, delay);
+			return TCL_OK;
+		}
+	}
+	if (strcmp(argv[1], "setNodeNumber" ) == 0 ) {
+		if ( argc == 3 ) {
+			int number_of_nodes = atoi(argv[2]);
+			OspfMessageCenter::instance().setNodeNumber(number_of_nodes);
+		}
+		return TCL_OK;
+	}
+
+	if (strcmp(argv[1], "computeRoutes") == 0) {
+		computeRoutes();
+		return TCL_OK;
+	}
+
+	if (strcmp(argv[1], "intfChanged") == 0) {
+		intfChanged();
+		return TCL_OK;
+	}
+
+	if (strcmp(argv[1], "lookup") == 0) {
+		if (argc == 4) {
+			int dst = atoi(argv[2]);
+			int mtid = atoi(argv[3]);
+			lookup (dst,mtid);
+			/* use tcl.resultf () to return the lookup results */
+			return TCL_OK;
+		}
+	}
+
+	if (strcmp(argv[1], "sendHellos") == 0) {
+		sendHellos ();	
+		return TCL_OK;
+	}
+
+	if (strcmp(argv[1], "interfaceChanged") == 0) {
+		interfaceChanged ();	
+		return TCL_OK;
+	}
+
+
+	return Agent::command(argc, argv);
+}
+
+
+//***********************************************************************************
+// initialize method: init class atributes 
+//***********************************************************************************
+void rtProtoOSPF::initialize() 
+{
+	
+	Tcl & tcl = Tcl::instance();
+
+	// call tcl get-node-id, atoi, set nodeId
+	tcl.evalf("%s get-node-id", name());
+	const char * resultString = tcl.result();
+	nodeId_ = atoi(resultString);
+ 	
+	// call tcl get-peers, strtok, set peerAddrMap, peerIdList;
+	tcl.evalf("%s get-peers", name());
+	resultString = tcl.result();
+	
+	int nodeId;
+	ns_addr_t peer;
+	
+
+	// XXX no error checking for now yet. tcl MUST return pairs of numbers
+	for ( LsIntList intList(resultString, " \t\n");
+	      !intList.empty(); ) {
+		nodeId = intList.front();
+		intList.pop_front();
+		// Agent.addr_
+		peer.addr_ = intList.front();
+		intList.pop_front();
+		peer.port_ = intList.front();
+		intList.pop_front();
+		peerAddrMap_.insert(nodeId, peer);
+		peerIdList_.push_back(nodeId);
+	}
+	
+	//call tcl get-num-mtids
+	tcl.evalf("%s get-num-mtids",name());
+	resultString = tcl.result();
+	numMtIds_ = atoi(resultString);
+	
+	int mtid; 
+	int MT_metric_;
+	RouterLinkState R;
+	
+	// call tcl get-links-status, strtok, set OspfLinkStateList_;
+	tcl.evalf("%s get-links-status", name());
+	resultString = tcl.result();
+
+	for ( LsIntList intList2(resultString, " \t\n");
+	      !intList2.empty(); ) {
+		R.Link_ID_ = (u_int32_t) intList2.front();
+		intList2.pop_front();
+		R.Type_ = (RouterLink_type_t) intList2.front();
+		intList2.pop_front();
+		R.Num_MT_ = (int) intList2.front();
+		intList2.pop_front();
+
+ 		if (!R.MTLinkList_.empty()) {
+		R.MTLinkList_.erase (R.MTLinkList_.begin(),R.MTLinkList_.end());
+		}
+
+		// get the cost for each mtid
+		for (int i=0; i<=R.Num_MT_; i++) {
+			mtid= (int) intList2.front();
+			intList2.pop_front();
+			MT_metric_= (int) intList2.front();
+			intList2.pop_front();	
+				if (mtid==0) {
+				R.MT0_metric_= MT_metric_;
+				}
+		   	R.MTLinkList_.push_back(MTLink (mtid,MT_metric_));
+			}
+		
+   	   OspfLinkStateList_.push_back(R);
+	}
+	
+	// call tcl get-delay-estimates
+	tcl.evalf ("%s get-delay-estimates", name());
+	
+	// call routing.init(this); and computeRoutes
+	routing_.init(this);
+	routing_.computeRoutes();
+	// debug
+	tcl.evalf("%s set OSPF_ready", name());
+	const char* token = strtok((char *)tcl.result(), " \t\n");
+	if (token == NULL) 
+		OSPF_ready_ = 0;
+	else
+		OSPF_ready_ = atoi(token); // buggy
+}
+
+//***********************************************************************************
+// intfChanged method: called when a link cost has changed 
+//***********************************************************************************
+
+void rtProtoOSPF::intfChanged ()
+{
+	// XXX redudant, to be changed later
+	Tcl & tcl = Tcl::instance();
+	// call tcl get-links-status, strtok, set linkStateList;
+	
+	
+	// destroy the old link states
+	OspfLinkStateList_.eraseAll();
+	// XXX no error checking for now. tcl MUST return triplets of numbers
+  	
+	int mtid; 
+	int MT_metric_;
+	RouterLinkState R;
+	
+	// call tcl get-links-status, strtok, set OspfLinkStateList_;
+	tcl.evalf("%s get-links-status", name());
+	const char * resultString = tcl.result();
+	printf("get-link-status %s\n",resultString);
+	
+	for ( LsIntList intList2(resultString, " \t\n");
+	      !intList2.empty(); ) {
+		R.Link_ID_ = (u_int32_t) intList2.front();
+		intList2.pop_front();
+		R.Type_ = (RouterLink_type_t) intList2.front();
+		intList2.pop_front();
+		R.Num_MT_ = (int) intList2.front();
+		intList2.pop_front();
+
+ 		if (!R.MTLinkList_.empty()) {
+		R.MTLinkList_.erase (R.MTLinkList_.begin(),R.MTLinkList_.end());
+		}
+
+		// get the cost for each mtid
+		for (int i=0; i<=R.Num_MT_; i++) {
+			mtid= (int) intList2.front();
+			intList2.pop_front();
+			MT_metric_= (int) intList2.front();
+			intList2.pop_front();	
+				if (mtid==0) {
+				R.MT0_metric_= MT_metric_;
+				}
+		   	R.MTLinkList_.push_back(MTLink (mtid,MT_metric_));
+			}
+		
+   	   OspfLinkStateList_.push_back(R);
+	}
+	
+	// call routing_'s LinkStateChanged() 
+	//   for now, don't compute routes yet (?)
+	routing_.linkStateChanged();
+}
+
+//***********************************************************************************
+// interfaceChanged method: called when a link state has changed 
+//***********************************************************************************
+
+void rtProtoOSPF:: interfaceChanged() {
+
+	//get tcl instance
+	Tcl & tcl = Tcl::instance();
+
+	// destroy the old active interfaces
+	peerIdList_.eraseAll();
+	// call tcl get-peers, strtok, set peerAddrMap, peerIdList;
+	tcl.evalf("%s get-peers", name());
+	const char * resultString = tcl.result();
+	
+	int nodeId;
+	ns_addr_t peer;
+
+	// XXX no error checking for now yet. tcl MUST return pairs of numbers
+	for ( LsIntList intList(resultString, " \t\n");
+	      !intList.empty(); ) {
+		nodeId = intList.front();
+		intList.pop_front();
+		// Agent.addr_
+		peer.addr_ = intList.front();
+		intList.pop_front();
+		peer.port_ = intList.front();
+		intList.pop_front();
+		peerAddrMap_.insert(nodeId, peer);
+		peerIdList_.push_back(nodeId);
+	}
+
+	routing_.interfaceChanged();
+	
+}
+
+
+void rtProtoOSPF::recv(Packet* p, Handler*)
+{   
+	hdr_Ospf* rh = hdr_Ospf::access(p);
+	hdr_ip* ih = hdr_ip::access(p);
+	// -- OSPF stuffs --
+
+
+	printf("Destination Node  %d:receive message\n",nodeId_);
+	Tcl& tcl = Tcl::instance();
+	char ns_[8];
+ 	tcl.evalf("Simulator instance");
+  	strcpy(ns_,tcl.result());
+
+	switch(rh->type()) {
+		case OSPF_MSG_HELLO:
+			tcl.evalf("%s trace-annotate \"Agente OSPF %d.Reciviendo un HELLO de %d msgid %d\"",ns_,nodeId_,ih->src(),rh->msgId());			
+			break;
+		case OSPF_MSG_DD:
+			tcl.evalf("%s trace-annotate \"Agente OSPF %d.Reciviendo un DD de %d msgid %d\"",ns_,nodeId_,ih->src(),rh->msgId());
+			break;
+		case OSPF_MSG_UPDATE:
+			tcl.evalf("%s trace-annotate \"Agente OSPF %d.Reciviendo un UPDATE de %d msgid %d\"",ns_,
+                  nodeId_,ih->src(),rh->msgId());
+			break;
+		case OSPF_MSG_REQUEST:
+			tcl.evalf("%s trace-annotate \"Agente OSPF %d.Reciviendo un REQUEST de %d msgid %d\"",ns_,nodeId_,ih->src(),rh->msgId());
+			break;
+		case OSPF_MSG_ACK:
+			tcl.evalf("%s trace-annotate \"Agente OSPF %d.Reciviendo un ACK de %d msgid %d\"",
+			ns_,nodeId_,ih->src(),rh->msgId());
+		default:
+			break;
+		};
+
+		receiveMessage(findPeerNodeId(ih->src()), rh->msgId(),rh->type());
+
+	Packet::free(p);
+}
+
+//***********************************************************************************
+// receiveMessage method: called by node when a message is received 
+//***********************************************************************************
+
+void rtProtoOSPF::receiveMessage(int sender, u_int32_t msgId,Ospf_message_type_t type)
+{
+
+	if (routing_.receiveMessage(sender, msgId,type)){
+	
+	  installRoutes();
+	}
+}
+
+//***********************************************************************************
+// sendMessage method: called by node when a message is sent 
+//***********************************************************************************
+
+bool rtProtoOSPF::sendMessage(int destId, hdr_Ospf hdr) 
+{
+	printf("sendMessage: Destination Node %d\n",destId);
+	
+	Tcl& tcl = Tcl::instance();
+	char ns_[8];
+ 	tcl.evalf("Simulator instance");
+  	strcpy(ns_,tcl.result());
+
+	switch(hdr.type_) {
+		case OSPF_MSG_HELLO:
+			tcl.evalf("%s hello-colour", name());
+			tcl.evalf("%s trace-annotate \"Agente OSPF %d.Enviando un HELLO a %d msgid %d\"",
+			ns_,nodeId_,destId,hdr.msgId_);			
+			break;
+		case OSPF_MSG_DD:
+			tcl.evalf("%s dd-colour", name());
+			tcl.evalf("%s trace-annotate \"Agente OSPF %d.Enviando un DD a %d msgid %d\"",ns_,
+                  nodeId_,destId,hdr.msgId_);
+			break;
+		case OSPF_MSG_UPDATE:
+			tcl.evalf("%s update-colour", name());
+		tcl.evalf("%s trace-annotate \"Agente OSPF %d.Enviando un UPDATE a %d msgid %d\"",ns_,
+                  nodeId_,destId,hdr.msgId_);
+			break;
+		case OSPF_MSG_REQUEST:
+			tcl.evalf("%s request-colour", name());
+			tcl.evalf("%s trace-annotate \"Agente OSPF %d.Enviando un REQUEST a %d msgid %d\"",
+			ns_,nodeId_,destId,hdr.msgId_);
+			break;
+		case OSPF_MSG_ACK:
+			tcl.evalf("%s ack-colour", name());
+			tcl.evalf("%s trace-annotate \"Agente OSPF %d.Enviando un ACK a %d msgid %d\"",
+			ns_,nodeId_,destId,hdr.msgId_);
+		default:
+			break;
+		};
+
+	ns_addr_t* agentAddrPtr = peerAddrMap_.findPtr(destId);
+	if (agentAddrPtr == NULL) 
+		return false;
+	dst_ = *agentAddrPtr;
+	size_ = hdr.packet_len_;
+	
+	
+	Packet* p = Agent::allocpkt();
+	hdr_Ospf *rh = hdr_Ospf::access(p);
+	rh->version() = hdr.version_;
+	rh->type() = hdr.type_;
+	rh->packet_len() = hdr.packet_len_;
+	rh->router_id() = hdr.router_id_;
+	rh->msgId() = hdr.msgId_;
+
+	
+	target_->recv(p);
+	return true;
+}
+
+//***********************************************************************************
+// lookup method: called when looking for the path of destId and mtid 
+//***********************************************************************************
+
+void rtProtoOSPF::lookup(int destId, int mtid) 
+{
+	
+	// Call routing_'s lookup
+	
+	OspfEqualPaths* EPptr = routing_.lookup(destId,mtid);
+		
+	// then use tcl.resultf() to return the results
+	if (EPptr == NULL) {
+		
+		Tcl::instance().resultf( "%s",  "");
+		return;
+	}
+	char resultBuf[64]; // XXX buggy;
+	sprintf(resultBuf, "%d" , EPptr->cost);
+	
+	char tmpBuf[16]; // XXX
+ 
+	for (LsNodeIdList::iterator itr = (EPptr->nextHopList).begin();
+	     itr != (EPptr->nextHopList).end(); itr++) {
+		sprintf(tmpBuf, " %d", (*itr) );		
+		strcat (resultBuf, tmpBuf); // strcat (dest, src);
+	}
+
+	Tcl::instance().resultf("%s", resultBuf);
+}
+
+ 
+//***********************************************************************************
+// findPeerNodeId method: find the int value mapped by the agentAddr 
+//***********************************************************************************
+
+int rtProtoOSPF::findPeerNodeId (ns_addr_t agentAddr) 
+{
+	// because the agentAddr is the value, not the key of the map
+	for (PeerAddrMap::iterator itr = peerAddrMap_.begin();
+	     itr != peerAddrMap_.end(); itr++) {
+		if ((*itr).second.isEqual (agentAddr)) {
+			return (*itr).first;
+		}
+	}
+	return LS_INVALID_NODE_ID;
+}
+
+
+#endif // HAVE_STL
diff -Naur ns-2.35-orig/ospf/rtProtoOSPF.h ns-2.35/ospf/rtProtoOSPF.h
--- ns-2.35-orig/ospf/rtProtoOSPF.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/ospf/rtProtoOSPF.h	2015-01-24 16:57:49.560073368 +0100
@@ -0,0 +1,139 @@
+/*
+ * rtProtoOSPF.h
+ * Copyright (C) 2006 by the University of Extremadura
+ * This program is free software: you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public License as published by 
+ * the Free Software Foundation, either version 3 of the License, or 
+ * (at your option) any later version. This program is distributed in the 
+ * hope that it will be useful, but WITHOUT ANY WARRANTY; without 
+ * even the implied warranty of MERCHANTABILITY or FITNESS FOR 
+ * A PARTICULAR PURPOSE. See the GNU General Public License 
+ * for more details. You should have received a copy of the GNU General 
+ * Public License along with this program. If not, see <http://www.gnu.org/licenses/>. 
+ */
+
+// by Inés María Romero Dávila (inroda04@alumnos.unex.es)
+// and Alfonso Gazo Cervero (agazo@unex.es)
+
+/***********************************************************************************
+ Módulo en el que se define el agente para protocolo OSPF
+************************************************************************************/
+
+
+#ifndef ns_rtprotoospf_h
+#define ns_rtprotoospf_h
+
+#include "packet.h"
+#include "agent.h"
+#include "ip.h"
+#include "ospf.h"
+#include "hdr-ospf.h"
+#include "utils.h"
+
+
+extern OspfMessageCenter messageCenter;
+
+
+
+//**********************************************************************************
+// rtProtoOSPF: OSPF Agent class definition  
+//**********************************************************************************
+
+class rtProtoOSPF : public Agent , public OspfNode {
+public:
+	// constructor
+	rtProtoOSPF();
+	int command(int argc, const char*const* argv);
+        void recv(Packet* p, Handler*);
+
+	
+
+protected:
+	// protected methods
+	
+	// set routing_ structure
+	void initialize(); 		
+	// set delayMap structure	
+	void setDelay(int nbrId, double delay) {
+		delayMap_.insert(nbrId, delay);
+	}
+	// call to computeRoutes in routing_ structure
+	void computeRoutes() { routing_.computeRoutes(); }
+	// called by tcl ospf agent when a link cost has changed
+	void intfChanged();
+	// called by tcl ospf agent to look for the path to reach to destinationNodeId for mtid
+	void lookup(int destinationNodeId, int mtid);
+	// called by tcl ospf agent when sending hello packets
+	void sendHellos() { routing_.sendHellos(); }
+	// called by tcl ospf agent when a link state has changed
+	void interfaceChanged ();	
+
+public:
+	// public methods
+	
+	bool sendMessage(int destId, hdr_Ospf hdr);
+	void receiveMessage(int sender, u_int32_t msgId,Ospf_message_type_t type);
+	int getNodeId() { return nodeId_; }
+	RouterLinkStateList* getLinkStateListPtr()  { return &OspfLinkStateList_; }
+	LsNodeIdList* getPeerIdListPtr() { return &peerIdList_; }
+	LsDelayMap* getDelayMapPtr() { 
+		return delayMap_.empty() ? (LsDelayMap *)NULL : &delayMap_;
+	}
+	int getNumMtIds() { return numMtIds_;}
+	double getHelloInterval() { return helloInterval_;}
+	double getRouterDeadInterval() { return routerDeadInterval_;}
+	
+	void installRoutes() {
+		Tcl::instance().evalf("%s route-changed", name());
+	}
+	// called by node when is necessary to re-calculate routing table in tcl
+	void routeChanged() { installRoutes();}
+	
+
+private:
+	// private data
+	typedef LsMap<int, ns_addr_t> PeerAddrMap; 
+	// peer address map
+	PeerAddrMap peerAddrMap_;
+	// node id	 
+	int nodeId_;
+	// ospf link state
+	RouterLinkStateList OspfLinkStateList_;
+	// peer Id list
+	LsNodeIdList peerIdList_;
+	// to differentiate fake and real OSPF. Needed in recv and sendMessage; 
+	int OSPF_ready_;
+	// The length of time, in seconds, between the Hello Packets the router sends on the interface
+	double helloInterval_; 
+	// After ceasing to hear a router's Hello Packets, the number of seconds before its neighbors 	//declare the router down
+	double routerDeadInterval_; 
+	//store the estimated one-way total delay for each neighbor, in second
+	LsDelayMap delayMap_;
+	// Ospf ruting protocol instance
+	OspfRouting routing_;
+	//store the number of Multitopology identifiers defined
+	int numMtIds_;
+
+	// private methods
+	int findPeerNodeId(ns_addr_t agentAddr);
+
+};// ns_rtprotols_h
+
+
+//**********************************************************************************
+// Linkage class definition
+//**********************************************************************************
+
+
+static class rtProtoOSPFclass : public TclClass {
+public:
+	rtProtoOSPFclass() : TclClass("Agent/rtProto/OSPF") {}
+	TclObject* create(int, const char*const*) {
+		return (new rtProtoOSPF());
+	}
+} class_rtProtoOSPF;
+    
+
+
+
+#endif // ns_rtprotoospf_h
diff -Naur ns-2.35-orig/ospf/utils.h ns-2.35/ospf/utils.h
--- ns-2.35-orig/ospf/utils.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/ospf/utils.h	2015-01-24 16:57:49.560073368 +0100
@@ -0,0 +1,160 @@
+/*
+ * hdp-ospf.h
+ * Copyright (C) 2006 by the University of Extremadura
+ * This program is free software: you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public License as published by 
+ * the Free Software Foundation, either version 3 of the License, or 
+ * (at your option) any later version. This program is distributed in the 
+ * hope that it will be useful, but WITHOUT ANY WARRANTY; without 
+ * even the implied warranty of MERCHANTABILITY or FITNESS FOR 
+ * A PARTICULAR PURPOSE. See the GNU General Public License 
+ * for more details. You should have received a copy of the GNU General 
+ * Public License along with this program. If not, see <http://www.gnu.org/licenses/>. 
+ */
+
+// by Inés María Romero Dávila (inroda04@alumnos.unex.es)
+// and Alfonso Gazo Cervero (agazo@unex.es)
+
+//****************************************************************************************************
+// Módulo en el que se definen las constantes y tipos.
+//****************************************************************************************************
+
+#ifndef ns_utils_h
+#define ns_utils_h
+
+
+//**********************************************************************************
+// constants definitions
+//**********************************************************************************
+
+const int OSPF_MESSAGE_CENTER_SIZE_FACTOR = 4; // times the number of nodes 
+// Sizes definition
+const int OSPF_HEADER_SIZE= 24; // in bytes
+const int OSPF_DEFAULT_MESSAGE_SIZE = 100; // in bytes
+const int OSPF_HELLO_MESSAGE_SIZE = 100; // in bytes
+const int OSPF_DD_MESSAGE_SIZE = 200; // (in bytes) Description Database packet
+const int OSPF_REQUEST_MESSAGE_SIZE = 100; // in bytes
+const int OSPF_UPDATE_MESSAGE_SIZE = 100; // in bytes
+const int OSPF_ACK_MESSAGE_SIZE = 20; // in bytes
+const int LINKSTATE_HEADER_SIZE = 20; // in bytes
+const unsigned int OSPF_WRAPAROUND_THRESHOLD = 2147483646; // 2^31-2
+
+const int OSPF_MESSAGE_TYPES = 6;
+
+//Network mask definition
+const int NETWORKA_MASK=((u_int32_t) 0xff000000);
+const int NETWORKB_MASK=((u_int32_t) 0xffff0000);
+const int NETWORKC_MASK=((u_int32_t) 0xffffff00);
+const int NETWORK_MASK_DEFAULT=((u_int32_t) 0x00000000);
+
+// Timers definition
+const int MAX_AGE= 3600; // in seconds 3600
+const int LS_REFRESH_TIME= 1800; // in seconds 1800 
+const int MAX_AGE_DIFF= 900; // 900 in seconds
+const double RXMT_INTERVAL= 0.002; // in seconds
+const int OSPF_TIMEOUT_FACTOR = 3;   // x times of one-way total delay
+
+
+//**********************************************************************************
+// OSPF packets definition
+//**********************************************************************************
+
+enum Ospf_message_type_t { 
+	OSPF_MSG_INVALID=0, 
+	OSPF_MSG_HELLO=1, 	// Hello message
+	OSPF_MSG_DD=2,		// Description DataBase message	
+	OSPF_MSG_REQUEST=3,	// Request message
+	OSPF_MSG_UPDATE=4,	// Update message
+	OSPF_MSG_ACK=5,		// Update's ACK
+};
+
+//**********************************************************************************
+// LS type definition
+//**********************************************************************************
+
+enum LS_type_t {
+	LS_INVALID = 0,
+	LS_ROUTER = 1, //router links
+	LS_NETWORK = 2, // network links
+	LS_SUMMARY = 3, // summary links
+	LS_EXTERNAL = 4 // external links
+};
+
+
+//**********************************************************************************
+// OPTIONS field definition
+//**********************************************************************************
+struct options_t {
+	char bit_T;
+	char bit_E;
+	options_t(): bit_T(0),bit_E(0) {}
+	options_t(char bitT, char bitE): bit_T(bitT), bit_E(bitE){}
+};
+
+
+//**********************************************************************************
+// Router Link Types definition
+//**********************************************************************************
+
+enum RouterLink_type_t {
+
+	routerLink_type_default=0,
+	point_to_point=1,
+	connection_to_transit_net=2,
+	connection_to_stub_net=3,
+	virtual_link=4
+};
+
+//**********************************************************************************
+// VEB_t: representing bits V,E,B (not used in this implementation)
+//**********************************************************************************
+struct VEB_t{
+	char bit_V;
+	char bit_E;
+	char bit_B;
+	VEB_t():bit_V(0),bit_E(0),bit_B(0){}
+	VEB_t(char bitV,char bitE,char bitB):bit_V(bitV),bit_E(bitE),bit_B(bitB){}
+};
+
+//**********************************************************************************
+// retCode type definition
+//**********************************************************************************
+
+enum retCode_t {
+	NO_EXIST = 0, //lsa doesn't exists in the database
+	EQUALS = 1, // lsa is equal to the copy in the database
+	OLDER = 2, // lsa is older than the copy in the database
+	NEWER = 3 // lsa is newer than the copy in the database
+	
+};
+
+//******************************************************************************
+// TMMS_t: representig T,M,MS bits for OspfLinksState 
+//****************************************************************************** 
+struct IMMS_t {
+	char bit_I; //Initialize bit
+	char bit_M; // More bit
+	char bit_MS; // Master Slave bit
+	IMMS_t():bit_I(0),bit_M(0),bit_MS(0){}
+	IMMS_t(char bitI,char bitM,char bitMS):bit_I(bitI),bit_M(bitM),bit_MS(bitMS){}
+};
+
+
+
+//**********************************************************************************
+//  StateN type definition: representing neighbour's states
+//**********************************************************************************
+
+enum StateN_type_t {
+	DOWN= 0,
+	ATTEMPT = 1, 
+	INIT = 2,
+	TWO_WAY = 3, 
+	EX_START = 4,
+	EXCHANGE = 5,
+	LOADING = 6,
+	FULL = 7
+};
+
+
+#endif
diff -Naur ns-2.35-orig/tcl/ex/ospf/COPYING ns-2.35/tcl/ex/ospf/COPYING
--- ns-2.35-orig/tcl/ex/ospf/COPYING	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/tcl/ex/ospf/COPYING	2015-01-24 17:02:08.948147192 +0100
@@ -0,0 +1,674 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
diff -Naur ns-2.35-orig/tcl/ex/ospf/ospf0.tcl ns-2.35/tcl/ex/ospf/ospf0.tcl
--- ns-2.35-orig/tcl/ex/ospf/ospf0.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/tcl/ex/ospf/ospf0.tcl	2015-01-24 17:02:08.948147192 +0100
@@ -0,0 +1,152 @@
+
+# AUTORA: Inés María Romero Dávia
+
+# OBJETIVO
+#   	PRTOCOLO DE ENCAMINAMIENTO OSPF
+#
+# 	Escenario inicial para probar el protocolo de routing OSPF sobre network simulator. 
+#	Las conexiones lógicas son:
+#
+#			n0 ->n4
+#			
+
+# TOPOLOGIA
+#
+#		$n0       $n3
+#		   \     /   \
+#		    \   /     \
+#		     $n2	$n4
+#		    /	\      / 
+#		   /     \    / 	 
+#		$n1       $n5
+#
+#       6 nodos 0 - 5
+#       Links entre 0-2, 1-2
+#               bandwith 2 Mbps    delay 2ms      DropTail
+#	Links restantes
+#		bandwith 1.5Mbps    delay  10ms	    DropTail
+
+# AGENTES DE TRÁFICO
+#       Agente TCP
+#               Nodo 0
+#       Agente null/Sink
+#               Nodo 4
+#       Un agente Traffic CBR para generar el trafico
+#               Nodo 0 Packetsize 60    Interval 0.02      
+#
+
+# AGENTES DE ROUTING
+#	Agente OSPF
+#		Todos los nodos	
+
+# COSTE ENLACES:
+#		todos= 1
+######################################################################################
+
+
+remove-all-packet-headers       ; # removes all except common
+add-packet-header Flags IP TCP rtProtoOSPF ; # hdrs reqd for validation test
+ 
+puts "(TCL) Creating simulator & trace files..."
+set dir "./out_ospf0"
+
+set ns [new Simulator]
+set vj_ss true
+
+
+set f [eval open $dir/ospf0.tr w]
+set nf [open $dir/ospf0.nam w]
+$ns trace-all $f
+$ns namtrace-all $nf
+
+proc finish {} {
+	global ns f nf dir
+	$ns flush-trace
+	close $f
+	close $nf
+	eval exec nam $dir/ospf0.nam 
+  puts "(TCL) Finishing..."
+	exit 0
+}
+
+
+
+#################################################
+#  NODES
+#################################################
+puts "(TCL) Setting up nodes and links..."
+set n0 [$ns node]
+set n1 [$ns node]
+set n2 [$ns node]
+set n3 [$ns node]
+set n4 [$ns node]
+set n5 [$ns node]
+
+#################################################
+# LINKS
+#################################################
+
+$ns duplex-link $n0 $n2 2Mb 2ms DropTail
+$ns duplex-link $n1 $n2 2Mb 2ms DropTail
+
+$ns duplex-link $n2 $n3 1.5Mb 10ms DropTail
+$ns duplex-link $n3 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n3 5
+$ns duplex-link-op $n2 $n3 queuePos 0
+
+
+$ns duplex-link $n2 $n5 1.5Mb 10ms DropTail
+$ns duplex-link $n5 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n5 5
+$ns duplex-link-op $n2 $n5 queuePos 0
+$ns duplex-link-op $n5 $n4 queuePos 0
+
+
+#################################################
+# Configuring TRAFFIC objects
+#################################################
+puts "(TCL) Configuring traffic objects..."
+
+set tcp1 [new Agent/TCP]
+$ns attach-agent $n0 $tcp1
+$n0 label "agent TCP"
+set snk1 [new Agent/TCPSink]
+$ns attach-agent $n4 $snk1
+$n4 label "agent TCPSink"
+$ns connect $tcp1 $snk1
+
+set cbr1 [new Application/Traffic/CBR]
+$cbr1 attach-agent $tcp1
+$cbr1 set packetSize_ 60
+$cbr1 set interval_ 0.01
+$tcp1 set fid_ 1
+$ns color 1 magenta
+
+
+#################################################
+# Configuring ROUTING objects
+#################################################
+puts "(TCL) Configuring routing protocol..."
+
+# set OSPF paremeters
+Agent/rtProto/OSPF set helloInterval 1
+Agent/rtProto/OSPF set routerDeadInterval 4  
+
+# set OSPF's packets colours
+$ns setup-ospf-colors
+# Set the routing protocol to OSPF
+$ns rtproto OSPF 
+
+#################################################
+# Scheduling simulation
+#################################################
+
+$ns at 1 "$cbr1 start"
+$ns at 2 "$cbr1 stop"
+$ns at 2 "finish"
+
+
+puts "(TCL) Starting simulation..."
+puts ""
+$ns run
+
diff -Naur ns-2.35-orig/tcl/ex/ospf/ospf1.tcl ns-2.35/tcl/ex/ospf/ospf1.tcl
--- ns-2.35-orig/tcl/ex/ospf/ospf1.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/tcl/ex/ospf/ospf1.tcl	2015-01-24 17:02:08.948147192 +0100
@@ -0,0 +1,180 @@
+
+# AUTORA: Inés María Romero Dávia
+
+# OBJETIVO
+#   	PRTOCOLO DE ENCAMINAMIENTO OSPF
+#
+# 	Escenario para probar el protocolo de routing OSPF sobre network simulator. 
+#	Las conexiones lógicas son:
+#
+#			n0 ->n4
+#			
+
+# TOPOLOGIA
+#
+#		$n0       $n3
+#		   \     /   \
+#		    \   /     \
+#		     $n2	$n4
+#		    /	\      / 
+#		   /     \    / 	 
+#		$n1       $n5
+#
+#       6 nodos 0 - 5
+#       Links entre 0-2, 1-2
+#               bandwith 2 Mbps    delay 2ms      DropTail
+#	Links restantes
+#		bandwith 1.5Mbps    delay  10ms	    DropTail
+
+# AGENTES DE TRÁFICO
+#       Agente TCP
+#               Nodo 0
+#       Agente null/Sink
+#               Nodo 4
+#       Un agente Traffic CBR para generar el trafico
+#               Nodo 0 Packetsize 60    Interval 0.02      
+#
+
+# AGENTES DE ROUTING
+#	Agente OSPF
+#		Todos los nodos	
+
+# COSTE ENLACES:
+#  Topologia por defecto:	
+#		2-5:5-2 = 2
+#		5-4:4-5 = 2
+#		resto = 1
+#  Resto de topologías:
+#		todos   = 1
+#
+######################################################################################
+Agent/TCP set syn_ false
+Agent/TCP set delay_growth_ false
+# In preparation for changing the default values for syn_ and delay_growth_.
+
+remove-all-packet-headers       ; # removes all except common
+add-packet-header Flags IP TCP rtProtoOSPF ; # hdrs reqd for validation test
+ 
+puts "(TCL) Creating simulator & trace files..."
+set dir "./out_ospf1"
+
+set ns [new Simulator]
+set vj_ss true
+
+
+
+set f [eval open $dir/ospf1.tr w]
+set nf [open $dir/ospf1.nam w]
+$ns trace-all $f
+$ns namtrace-all $nf
+
+proc finish {} {
+	global ns f nf dir
+	$ns flush-trace
+	close $f
+	close $nf
+	eval exec nam $dir/ospf1.nam 
+  puts "(TCL) Finishing..."
+	exit 0
+}
+
+
+
+#################################################
+#  NODES
+#################################################
+puts "(TCL) Setting up nodes and links..."
+set n0 [$ns node]
+set n1 [$ns node]
+set n2 [$ns node]
+set n3 [$ns node]
+set n4 [$ns node]
+set n5 [$ns node]
+
+$n0 shape circle
+$n1 shape hexagon
+$n2 shape hexagon
+$n3 shape hexagon
+$n4 shape circle
+$n5 shape hexagon
+
+$n0 color red
+$n1 color blue
+$n2 color blue
+$n3 color blue
+$n4 color red
+$n5 color blue
+
+#################################################
+# LINKS
+#################################################
+
+$ns duplex-link $n0 $n2 2Mb 2ms DropTail
+$ns duplex-link $n1 $n2 2Mb 2ms DropTail
+
+$ns duplex-link $n2 $n3 1.5Mb 10ms DropTail
+$ns duplex-link $n3 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n3 5
+$ns duplex-link-op $n2 $n3 queuePos 0
+
+
+$ns duplex-link $n2 $n5 1.5Mb 10ms DropTail
+$ns duplex-link $n5 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n5 5
+$ns duplex-link-op $n2 $n5 queuePos 0
+$ns duplex-link-op $n5 $n4 queuePos 0
+
+
+# Assigning link costs	
+$ns duplex-cost $n2 $n5 2
+$ns duplex-cost $n5 $n2 2
+
+
+#################################################
+# Configuring TRAFFIC objects
+#################################################
+puts "(TCL) Configuring traffic objects..."
+
+set tcp1 [new Agent/TCP]
+$ns attach-agent $n0 $tcp1
+$n0 label "agent TCP"
+set snk1 [new Agent/TCPSink]
+$ns attach-agent $n4 $snk1
+$n4 label "agent TCPSink"
+$ns connect $tcp1 $snk1
+
+set cbr1 [new Application/Traffic/CBR]
+$cbr1 attach-agent $tcp1
+$cbr1 set packetSize_ 60
+$cbr1 set interval_ 0.01
+$tcp1 set fid_ 1
+$ns color 1 magenta
+
+
+#################################################
+# Configuring ROUTING objects
+#################################################
+puts "(TCL) Configuring routing protocol..."
+
+# set OSPF paremeters
+Agent/rtProto/OSPF set helloInterval 1
+Agent/rtProto/OSPF set routerDeadInterval 4  
+
+# set OSPF's packets colours
+$ns setup-ospf-colors
+# Set the routing protocol to OSPF
+$ns rtproto OSPF 
+
+#################################################
+# Scheduling simulation
+#################################################
+
+$ns at 1 "$cbr1 start"
+$ns at 2 "$cbr1 stop"
+$ns at 2 "finish"
+
+
+puts "(TCL) Starting simulation..."
+puts ""
+$ns run
+
diff -Naur ns-2.35-orig/tcl/ex/ospf/ospf2.tcl ns-2.35/tcl/ex/ospf/ospf2.tcl
--- ns-2.35-orig/tcl/ex/ospf/ospf2.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/tcl/ex/ospf/ospf2.tcl	2015-01-24 17:02:08.948147192 +0100
@@ -0,0 +1,203 @@
+
+# AUTORA: Inés María Romero Dávia
+
+# OBJETIVO
+#   	PRTOCOLO DE ENCAMINAMIENTO OSPF
+#
+# 	Escenario para probar el protocolo de routing OSPF sobre network simulator. 
+#	Las conexiones lógicas son:
+#
+#			n0 ->n4
+#			n1 ->n4
+
+# TOPOLOGIA
+#
+#		$n0       $n3
+#		   \     /   \
+#		    \   /     \
+#		     $n2	$n4
+#		    /	\      / 
+#		   /     \    / 	 
+#		$n1       $n5
+#
+#       6 nodos 0 - 5
+#       Links entre 0-2, 1-2
+#               bandwith 10 Mbps    delay 2ms      DropTail
+#	Links restantes
+#		bandwith 1.5Mbps    delay  10ms	    DropTail
+
+# AGENTES DE TRÁFICO
+#       Agente TCP
+#               Nodo 0
+#       Agente null/Sink
+#               Nodo 4
+#       Un agente Traffic CBR para generar el trafico
+#               Nodo 0 Packetsize 60    Interval 0.04      
+#
+#       Agente TCP
+#               Nodo 1
+#       Agente null/Sink
+#               Nodo 4
+#       Un agente Traffic CBR para generar el trafico
+#               Nodo 1 Packetsize 60    Interval 0.04      
+
+# AGENTES DE ROUTING
+#	Agente OSPF
+#		Todos los nodos	
+
+# COSTE ENLACES:
+# Todas las topologías
+#	todos enlaces  = 1
+#
+# MULTIPATH
+#		Activado	
+######################################################################################
+
+Agent/TCP set syn_ false
+Agent/TCP set delay_growth_ false
+# In preparation for changing the default values for syn_ and delay_growth_.
+
+remove-all-packet-headers       ; # removes all except common
+add-packet-header Flags IP TCP rtProtoOSPF ; # hdrs reqd for validation test
+ 
+
+# Enable multiPath routing
+Node set multiPath_ 1
+
+puts "(TCL) Creating simulator & trace files..."
+set dir "./out_ospf2"
+
+set ns [new Simulator]
+set vj_ss true
+
+
+set f [eval open $dir/ospf2.tr w]
+set nf [open $dir/ospf2.nam w]
+$ns trace-all $f
+$ns namtrace-all $nf
+
+proc finish {} {
+	global ns f nf dir
+	$ns flush-trace
+	close $f
+	close $nf
+	eval exec nam $dir/ospf2.nam 
+  puts "(TCL) Finishing..."
+	exit 0
+}
+
+
+
+#################################################
+#  NODES
+#################################################
+puts "(TCL) Setting up nodes and links..."
+set n0 [$ns node]
+set n1 [$ns node]
+set n2 [$ns node]
+set n3 [$ns node]
+set n4 [$ns node]
+set n5 [$ns node]
+
+$n0 shape circle
+$n1 shape circle
+$n2 shape hexagon
+$n3 shape hexagon
+$n4 shape circle
+$n5 shape hexagon
+
+$n0 color red
+$n1 color red
+$n2 color blue
+$n3 color blue
+$n4 color red
+$n5 color blue
+
+#################################################
+# LINKS
+#################################################
+
+$ns duplex-link $n0 $n2 10Mb 2ms DropTail
+$ns duplex-link $n1 $n2 10Mb 2ms DropTail
+
+$ns duplex-link $n2 $n3 1.5Mb 10ms DropTail
+$ns duplex-link $n3 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n3 5
+$ns duplex-link-op $n2 $n3 queuePos 0
+
+
+$ns duplex-link $n2 $n5 1.5Mb 10ms DropTail
+$ns duplex-link $n5 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n5 5
+$ns duplex-link-op $n2 $n5 queuePos 0
+$ns duplex-link-op $n5 $n4 queuePos 0
+
+
+
+#################################################
+# Configuring TRAFFIC objects
+#################################################
+puts "(TCL) Configuring traffic objects..."
+
+set tcp1 [new Agent/TCP]
+$ns attach-agent $n0 $tcp1
+$n0 label "agent TCP"
+set snk1 [new Agent/TCPSink]
+$ns attach-agent $n4 $snk1
+$n4 label "agent TCPSink"
+$ns connect $tcp1 $snk1
+
+set cbr1 [new Application/Traffic/CBR]
+$cbr1 attach-agent $tcp1
+$cbr1 set packetSize_ 60
+$cbr1 set interval_ 0.04
+$tcp1 set fid_ 1
+$ns color 1 magenta
+
+
+set tcp2 [new Agent/TCP]
+$ns attach-agent $n1 $tcp2
+$n1 label "agent TCP"
+set snk2 [new Agent/TCPSink]
+$ns attach-agent $n4 $snk2
+
+$ns connect $tcp2 $snk2
+
+set cbr2 [new Application/Traffic/CBR]
+$cbr2 attach-agent $tcp2
+$cbr2 set packetSize_ 60
+$cbr2 set interval_ 0.04
+$tcp2 set fid_ 2
+$ns color 2 cyan
+
+
+#################################################
+# Configuring ROUTING objects
+#################################################
+puts "(TCL) Configuring routing protocol..."
+
+
+# set OSPF paremeters
+Agent/rtProto/OSPF set helloInterval 1
+Agent/rtProto/OSPF set routerDeadInterval 4  
+# set OSPF's packets colours
+$ns setup-ospf-colors
+# Set the routing protocol to OSPF
+$ns rtproto OSPF 
+
+#################################################
+# Scheduling simulation
+#################################################
+
+
+$ns at 1 "$cbr1 start"
+$ns at 1 "$cbr2 start"
+$ns at 2 "$cbr1 stop"
+$ns at 2 "$cbr2 stop"
+$ns at 2 "finish"
+
+
+puts "(TCL) Starting simulation..."
+puts ""
+$ns run
+
diff -Naur ns-2.35-orig/tcl/ex/ospf/ospf3.tcl ns-2.35/tcl/ex/ospf/ospf3.tcl
--- ns-2.35-orig/tcl/ex/ospf/ospf3.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/tcl/ex/ospf/ospf3.tcl	2015-01-24 17:02:08.974148063 +0100
@@ -0,0 +1,217 @@
+
+# AUTORA: Inés María Romero Dávia
+
+# OBJETIVO
+#   	PRTOCOLO DE ENCAMINAMIENTO OSPF
+#
+# 	Escenario para probar el protocolo de routing OSPF sobre network simulator.
+# 	Se simula la modificación del coste del enlace 2-3, 3-2 que pasa a ser 4.
+# 	Se comprueba como el tráfico se reencamina por el enlace 2-5.
+ 
+#	Las conexiones lógicas son:
+#
+#			n0 ->n4
+#			n1 ->n4
+
+# TOPOLOGIA
+#
+#		$n0       $n3
+#		   \     /   \
+#		    \   /     \
+#		     $n2	$n4
+#		    /	\      / 
+#		   /     \    / 	 
+#		$n1       $n5
+#
+#       6 nodos 0 - 5
+#       Links entre 0-2, 1-2
+#               bandwith 10 Mbps    delay 2ms      DropTail
+#	Links restantes
+#		bandwith 1.5Mbps    delay  10ms	    DropTail
+
+# AGENTES DE TRÁFICO
+#       Agente TCP
+#               Nodo 0
+#       Agente null/Sink
+#               Nodo 4
+#       Un agente Traffic CBR para generar el trafico
+#               Nodo 0 Packetsize 60    Interval 0.04      
+#
+#       Agente TCP
+#               Nodo 1
+#       Agente null/Sink
+#               Nodo 4
+#       Un agente Traffic CBR para generar el trafico
+#               Nodo 1 Packetsize 60    Interval 0.04      
+
+# AGENTES DE ROUTING
+#	Agente OSPF
+#		Todos los nodos	
+
+# COSTE ENLACES:
+# Topología por defecto
+#	Enlace 5-4:4-5  = 2
+#	resto = 1
+# Resto de topologías
+#	todos = 1
+#
+# MODIFICACIÓN COSTE ENLACES
+#  Topología por defecto
+#	Enlace 2-3:3-2 = 4
+#
+######################################################################################
+
+
+Agent/TCP set syn_ false
+Agent/TCP set delay_growth_ false
+# In preparation for changing the default values for syn_ and delay_growth_.
+
+remove-all-packet-headers       ; # removes all except common
+add-packet-header Flags IP TCP rtProtoOSPF ; # hdrs reqd for validation test
+ 
+
+puts "(TCL) Creating simulator & trace files..."
+set dir "./out_ospf3"
+
+set ns [new Simulator]
+set vj_ss true
+
+
+set f [eval open $dir/ospf3.tr w]
+set nf [open $dir/ospf3.nam w]
+$ns trace-all $f
+$ns namtrace-all $nf
+
+proc finish {} {
+	global ns f nf dir
+	$ns flush-trace
+	close $f
+	close $nf
+	eval exec nam $dir/ospf3.nam 
+  puts "(TCL) Finishing..."
+	exit 0
+}
+
+
+
+#################################################
+#  NODES
+#################################################
+puts "(TCL) Setting up nodes and links..."
+set n0 [$ns node]
+set n1 [$ns node]
+set n2 [$ns node]
+set n3 [$ns node]
+set n4 [$ns node]
+set n5 [$ns node]
+
+$n0 shape circle
+$n1 shape circle
+$n2 shape hexagon
+$n3 shape hexagon
+$n4 shape circle
+$n5 shape hexagon
+
+$n0 color red
+$n1 color red
+$n2 color blue
+$n3 color blue
+$n4 color red
+$n5 color blue
+
+#################################################
+# LINKS
+#################################################
+
+$ns duplex-link $n0 $n2 10Mb 2ms DropTail
+$ns duplex-link $n1 $n2 10Mb 2ms DropTail
+
+$ns duplex-link $n2 $n3 1.5Mb 10ms DropTail
+$ns duplex-link $n3 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n3 5
+$ns duplex-link-op $n2 $n3 queuePos 0
+
+
+$ns duplex-link $n2 $n5 1.5Mb 10ms DropTail
+$ns duplex-link $n5 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n5 5
+$ns duplex-link-op $n2 $n5 queuePos 0
+$ns duplex-link-op $n5 $n4 queuePos 0
+
+#set initial costs (default 1)
+$ns init-links-cost
+
+# Assigning link costs	
+$ns cost  $n5 $n4 2 
+$ns cost  $n4 $n5 2
+
+
+#################################################
+# Configuring TRAFFIC objects
+#################################################
+puts "(TCL) Configuring traffic objects..."
+
+set tcp1 [new Agent/TCP]
+$ns attach-agent $n0 $tcp1
+$n0 label "agent TCP"
+set snk1 [new Agent/TCPSink]
+$ns attach-agent $n4 $snk1
+$n4 label "agent TCPSink"
+$ns connect $tcp1 $snk1
+
+set cbr1 [new Application/Traffic/CBR]
+$cbr1 attach-agent $tcp1
+$cbr1 set packetSize_ 60
+$cbr1 set interval_ 0.04
+$tcp1 set fid_ 1
+$ns color 1 magenta
+
+
+set tcp2 [new Agent/TCP]
+$ns attach-agent $n1 $tcp2
+$n1 label "agent TCP"
+set snk2 [new Agent/TCPSink]
+$ns attach-agent $n4 $snk2
+
+$ns connect $tcp2 $snk2
+
+set cbr2 [new Application/Traffic/CBR]
+$cbr2 attach-agent $tcp2
+$cbr2 set packetSize_ 60
+$cbr2 set interval_ 0.04
+$tcp2 set fid_ 2
+$ns color 2 cyan
+
+#################################################
+# Configuring ROUTING objects
+#################################################
+puts "(TCL) Configuring routing protocol..."
+
+# set OSPF paremeters
+Agent/rtProto/OSPF set helloInterval 1
+Agent/rtProto/OSPF set routerDeadInterval 4 
+
+# set OSPF's packets colours
+$ns setup-ospf-colors
+# Set the routing protocol to OSPF
+$ns rtproto OSPF 
+
+#################################################
+# Scheduling simulation
+#################################################
+puts "(TCL) Configuring routing protocol..."
+$ns changed-cost-at 3 4 $n2 $n3
+$ns changed-cost-at 3 4 $n3 $n2
+
+
+$ns at 1 "$cbr1 start"
+$ns at 2 "$cbr2 start"
+$ns at 4 "$cbr1 stop"
+$ns at 5 "$cbr2 stop"
+$ns at 5 "finish"
+
+
+puts "(TCL) Starting simulation..."
+puts ""
+$ns run
+
diff -Naur ns-2.35-orig/tcl/ex/ospf/ospf4.tcl ns-2.35/tcl/ex/ospf/ospf4.tcl
--- ns-2.35-orig/tcl/ex/ospf/ospf4.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/tcl/ex/ospf/ospf4.tcl	2015-01-24 17:02:08.974148063 +0100
@@ -0,0 +1,209 @@
+
+# AUTORA: Inés María Romero Dávia
+
+# OBJETIVO
+#   	PRTOCOLO DE ENCAMINAMIENTO OSPF
+#
+# 	Escenario para probar el protocolo de routing OSPF sobre network simulator. 
+#	Se simula la modificación del estado del enlace 2-3.
+# 	Se comprueba como el tráfico  se reencamina por el enlace 2-5.
+
+#	Las conexiones lógicas son:
+#
+#			n0 ->n4
+#			n1 ->n4
+
+# TOPOLOGIA
+#
+#		$n0       $n3
+#		   \     /   \
+#		    \   /     \
+#		     $n2	$n4
+#		    /	\      / 
+#		   /     \    / 	 
+#		$n1       $n5
+#
+#       6 nodos 0 - 5
+#       Links entre 0-2, 1-2
+#               bandwith 10 Mbps    delay 2ms      DropTail
+#	Links restantes
+#		bandwith 1.5Mbps    delay  10ms	    DropTail
+
+# AGENTES DE TRÁFICO
+#       Agente TCP
+#               Nodo 0
+#       Agente null/Sink
+#               Nodo 4
+#       Un agente Traffic CBR para generar el trafico
+#               Nodo 0 Packetsize 60    Interval 0.04      
+#
+#       Agente TCP
+#               Nodo 1
+#       Agente null/Sink
+#               Nodo 4
+#       Un agente Traffic CBR para generar el trafico
+#               Nodo 1 Packetsize 60    Interval 0.04      
+
+# AGENTES DE ROUTING
+#	Agente OSPF
+#		Todos los nodos	
+#
+# COSTE ENLACES:
+# Todas las topologías
+#		todos enlaces  = 1
+#
+# MODIFICACIÓN ESTADO ENLACES (Modelo Manual)
+#	Enlace 2-3 
+#
+#
+# MULTIPATH
+#	 NO Activado	
+######################################################################################
+
+
+Agent/TCP set syn_ false
+Agent/TCP set delay_growth_ false
+# In preparation for changing the default values for syn_ and delay_growth_.
+
+remove-all-packet-headers       ; # removes all except common
+add-packet-header Flags IP TCP rtProtoOSPF ; # hdrs reqd for validation test
+ 
+
+puts "(TCL) Creating simulator & trace files..."
+set dir "./out_ospf4"
+
+set ns [new Simulator]
+set vj_ss true
+
+
+set f [eval open $dir/ospf4.tr w]
+set nf [open $dir/ospf4.nam w]
+$ns trace-all $f
+$ns namtrace-all $nf
+
+proc finish {} {
+	global ns f nf dir
+	$ns flush-trace
+	close $f
+	close $nf
+	eval exec nam $dir/ospf4.nam 
+  puts "(TCL) Finishing..."
+	exit 0
+}
+
+
+
+#################################################
+#  NODES
+#################################################
+puts "(TCL) Setting up nodes and links..."
+set n0 [$ns node]
+set n1 [$ns node]
+set n2 [$ns node]
+set n3 [$ns node]
+set n4 [$ns node]
+set n5 [$ns node]
+
+$n0 shape circle
+$n1 shape circle
+$n2 shape hexagon
+$n3 shape hexagon
+$n4 shape circle
+$n5 shape hexagon
+
+$n0 color red
+$n1 color red
+$n2 color blue
+$n3 color blue
+$n4 color red
+$n5 color blue
+
+#################################################
+# LINKS
+#################################################
+
+$ns duplex-link $n0 $n2 10Mb 2ms DropTail
+$ns duplex-link $n1 $n2 10Mb 2ms DropTail
+
+$ns duplex-link $n2 $n3 1.5Mb 10ms DropTail
+$ns duplex-link $n3 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n3 5
+$ns duplex-link-op $n2 $n3 queuePos 0
+
+
+$ns duplex-link $n2 $n5 1.5Mb 10ms DropTail
+$ns duplex-link $n5 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n5 5
+$ns duplex-link-op $n2 $n5 queuePos 0
+$ns duplex-link-op $n5 $n4 queuePos 0
+
+
+
+#################################################
+# Configuring TRAFFIC objects
+#################################################
+puts "(TCL) Configuring traffic objects..."
+
+set tcp1 [new Agent/TCP]
+$ns attach-agent $n0 $tcp1
+$n0 label "agent TCP"
+set snk1 [new Agent/TCPSink]
+$ns attach-agent $n4 $snk1
+$n4 label "agent TCPSink"
+$ns connect $tcp1 $snk1
+
+set cbr1 [new Application/Traffic/CBR]
+$cbr1 attach-agent $tcp1
+$cbr1 set packetSize_ 60
+$cbr1 set interval_ 0.04
+$tcp1 set fid_ 1
+$ns color 1 magenta
+
+
+set tcp2 [new Agent/TCP]
+$ns attach-agent $n1 $tcp2
+$n1 label "agent TCP"
+set snk2 [new Agent/TCPSink]
+$ns attach-agent $n4 $snk2
+
+$ns connect $tcp2 $snk2
+
+set cbr2 [new Application/Traffic/CBR]
+$cbr2 attach-agent $tcp2
+$cbr2 set packetSize_ 60
+$cbr2 set interval_ 0.04
+$tcp2 set fid_ 2
+$ns color 2 cyan
+
+#################################################
+# Configuring ROUTING objects
+#################################################
+puts "(TCL) Configuring routing protocol..."
+
+# set OSPF paremeters
+Agent/rtProto/OSPF set helloInterval 1
+Agent/rtProto/OSPF set routerDeadInterval 4 
+
+# set OSPF's packets colours
+$ns setup-ospf-colors
+# Set the routing protocol to OSPF
+$ns rtproto OSPF 
+
+#################################################
+# Scheduling simulation
+#################################################
+
+#modifying link state
+$ns rtmodel-at 2 down $n2 $n3
+
+$ns at 1 "$cbr1 start"
+$ns at 2 "$cbr2 start"
+$ns at 10 "$cbr1 stop"
+$ns at 20 "$cbr2 stop"
+$ns at 20 "finish"
+
+
+puts "(TCL) Starting simulation..."
+puts ""
+$ns run
+
diff -Naur ns-2.35-orig/tcl/ex/ospf/ospf5.tcl ns-2.35/tcl/ex/ospf/ospf5.tcl
--- ns-2.35-orig/tcl/ex/ospf/ospf5.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/tcl/ex/ospf/ospf5.tcl	2015-01-24 17:02:08.974148063 +0100
@@ -0,0 +1,220 @@
+
+# AUTORA: Inés María Romero Dávia
+
+# OBJETIVO
+#   	PRTOCOLO DE ENCAMINAMIENTO OSPF
+#
+# 	Escenario para probar el protocolo de routing OSPF sobre network simulator. 
+# 	Se simula la caida del enlace 2-3 y su posterior reactivación (depués de RouterDeadInterval)
+# 	Se comprueba como el tráfico se reencamina por el enlace 2-5 inmediatamente (camino alternativo).
+
+#	Las conexiones lógicas son:
+#
+#			n0 ->n4
+#			n1 ->n4
+
+# TOPOLOGIA
+#
+#		$n0       $n3
+#		   \     /   \
+#		    \   /     \
+#		     $n2	$n4
+#		    /	\      / 
+#		   /     \    / 	 
+#		$n1       $n5
+#
+#       6 nodos 0 - 5
+#       Links entre 0-2, 1-2
+#               bandwith 10 Mbps    delay 2ms      DropTail
+#	Links restantes
+#		bandwith 1.5Mbps    delay  10ms	    DropTail
+
+# AGENTES DE TRÁFICO
+#       Agente TCP
+#               Nodo 0
+#       Agente null/Sink
+#               Nodo 4
+#       Un agente Traffic CBR para generar el trafico
+#               Nodo 0 Packetsize 60    Interval 0.04      
+#
+#       Agente TCP
+#               Nodo 1
+#       Agente null/Sink
+#               Nodo 4
+#       Un agente Traffic CBR para generar el trafico
+#               Nodo 1 Packetsize 60    Interval 0.04      
+
+# AGENTES DE ROUTING
+#	Agente OSPF
+#		Todos los nodos	
+#
+# COSTE ENLACES:
+# Todas las topologías
+#	todos enlaces  = 1
+#
+# MODIFICACIÓN ESTADO ENLACES (Modelo Manual)
+#	Enlace 2-3 
+#
+#
+# MULTIPATH
+#	Activado	
+#
+######################################################################################
+
+
+
+Agent/TCP set syn_ false
+Agent/TCP set delay_growth_ false
+# In preparation for changing the default values for syn_ and delay_growth_.
+
+remove-all-packet-headers       ; # removes all except common
+add-packet-header Flags IP TCP rtProtoOSPF ; # hdrs reqd for validation test
+ 
+
+puts "(TCL) Creating simulator & trace files..."
+set dir "./out_ospf5"
+
+set ns [new Simulator]
+set vj_ss true
+
+# Enable multiPath routing
+Node set multiPath_ 1
+
+set f [eval open $dir/ospf5.tr w]
+set nf [open $dir/ospf5.nam w]
+$ns trace-all $f
+$ns namtrace-all $nf
+
+proc finish {} {
+	global ns f nf dir
+	$ns flush-trace
+	close $f
+	close $nf
+	eval exec nam $dir/ospf5.nam 
+  puts "(TCL) Finishing..."
+	exit 0
+}
+
+
+
+#################################################
+#  NODES
+#################################################
+puts "(TCL) Setting up nodes and links..."
+set n0 [$ns node]
+set n1 [$ns node]
+set n2 [$ns node]
+set n3 [$ns node]
+set n4 [$ns node]
+set n5 [$ns node]
+
+$n0 shape circle
+$n1 shape circle
+$n2 shape hexagon
+$n3 shape hexagon
+$n4 shape circle
+$n5 shape hexagon
+
+$n0 color red
+$n1 color red
+$n2 color blue
+$n3 color blue
+$n4 color red
+$n5 color blue
+
+#################################################
+# LINKS
+#################################################
+
+$ns duplex-link $n0 $n2 10Mb 2ms DropTail
+$ns duplex-link $n1 $n2 10Mb 2ms DropTail
+
+$ns duplex-link $n2 $n3 1.5Mb 10ms DropTail
+$ns duplex-link $n3 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n3 5
+$ns duplex-link-op $n2 $n3 queuePos 0
+
+
+$ns duplex-link $n2 $n5 1.5Mb 10ms DropTail
+$ns duplex-link $n5 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n5 5
+$ns duplex-link-op $n2 $n5 queuePos 0
+$ns duplex-link-op $n5 $n4 queuePos 0
+
+
+#################################################
+# Configuring TRAFFIC objects
+#################################################
+puts "(TCL) Configuring traffic objects..."
+
+set tcp1 [new Agent/TCP]
+$ns attach-agent $n0 $tcp1
+$n0 label "agent TCP"
+set snk1 [new Agent/TCPSink]
+$n4 label "agent TCPSink"
+$ns attach-agent $n4 $snk1
+
+$ns connect $tcp1 $snk1
+
+set cbr1 [new Application/Traffic/CBR]
+$cbr1 attach-agent $tcp1
+$cbr1 set packetSize_ 60
+$cbr1 set interval_ 0.04
+$tcp1 set fid_ 1
+$ns color 1 magenta
+
+
+set tcp2 [new Agent/TCP]
+$ns attach-agent $n1 $tcp2
+$n1 label "agent TCP"
+set snk2 [new Agent/TCPSink]
+$ns attach-agent $n4 $snk2
+
+$ns connect $tcp2 $snk2
+
+set cbr2 [new Application/Traffic/CBR]
+$cbr2 attach-agent $tcp2
+$cbr2 set packetSize_ 60
+$cbr2 set interval_ 0.04
+$tcp2 set fid_ 2
+$ns color 2 cyan
+
+
+#################################################
+# Configuring ROUTING objects
+#################################################
+puts "(TCL) Configuring routing protocol..."
+
+# set OSPF paremeters
+Agent/rtProto/OSPF set helloInterval 1
+Agent/rtProto/OSPF set routerDeadInterval 4 
+
+# set OSPF's packets colours
+$ns setup-ospf-colors
+# Set the routing protocol to OSPF
+$ns rtproto OSPF 
+
+
+#################################################
+# Scheduling simulation
+#################################################
+puts "(TCL) Configuring routing protocol..."
+
+#modifying link state
+$ns rtmodel-at 1 down $n2 $n3
+$ns rtmodel-at 6 up $n2 $n3
+
+$ns setup-ospf-colors
+$ns rtproto OSPF 
+
+$ns at 0.8 "$cbr1 start"
+$ns at 0.8 "$cbr2 start"
+$ns at 10 "$cbr1 stop"
+$ns at 20 "$cbr2 stop"
+$ns at 20 "finish"
+
+
+puts "(TCL) Starting simulation..."
+puts ""
+$ns run
+
diff -Naur ns-2.35-orig/tcl/ex/ospf/ospf6.tcl ns-2.35/tcl/ex/ospf/ospf6.tcl
--- ns-2.35-orig/tcl/ex/ospf/ospf6.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/tcl/ex/ospf/ospf6.tcl	2015-01-24 17:02:08.974148063 +0100
@@ -0,0 +1,215 @@
+
+# AUTORA: Inés María Romero Dávia
+
+# OBJETIVO
+#   	PRTOCOLO DE ENCAMINAMIENTO OSPF
+#
+# 	Escenario para probar el protocolo de routing OSPF sobre network simulator. 
+# 	Se simula la caida del enlace 2-3 y su posterior reactivación (antes de RouterDeadInterval)
+# 	Se comprueba como el tráfico se reencamina por el enlace 2-5 inmediatamente (camino alternativo).
+
+#	Las conexiones lógicas son:
+#
+#			n0 ->n4
+#			n1 ->n4
+
+# TOPOLOGIA
+#
+#		$n0       $n3
+#		   \     /   \
+#		    \   /     \
+#		     $n2	$n4
+#		    /	\      / 
+#		   /     \    / 	 
+#		$n1       $n5
+#
+#       6 nodos 0 - 5
+#       Links entre 0-2, 1-2
+#               bandwith 10 Mbps    delay 2ms      DropTail
+#	Links restantes
+#		bandwith 1.5Mbps    delay  10ms	    DropTail
+
+# AGENTES DE TRÁFICO
+#       Agente TCP
+#               Nodo 0
+#       Agente null/Sink
+#               Nodo 4
+#       Un agente Traffic CBR para generar el trafico
+#               Nodo 0 Packetsize 60    Interval 0.04      
+#
+#       Agente TCP
+#               Nodo 1
+#       Agente null/Sink
+#               Nodo 4
+#       Un agente Traffic CBR para generar el trafico
+#               Nodo 1 Packetsize 60    Interval 0.04      
+
+# AGENTES DE ROUTING
+#	Agente OSPF
+#		Todos los nodos	
+#
+# COSTE ENLACES:
+# Todas las topologías
+#	todos enlaces  = 1
+#
+# MODIFICACIÓN ESTADO ENLACES (Modelo Manual)
+#	Enlace 2-3 
+#
+#
+# MULTIPATH
+#	Activado	
+#
+######################################################################################
+
+Agent/TCP set syn_ false
+Agent/TCP set delay_growth_ false
+# In preparation for changing the default values for syn_ and delay_growth_.
+
+remove-all-packet-headers       ; # removes all except common
+add-packet-header Flags IP TCP rtProtoOSPF ; # hdrs reqd for validation test
+ 
+
+puts "(TCL) Creating simulator & trace files..."
+set dir "./out_ospf6"
+
+set ns [new Simulator]
+set vj_ss true
+
+# Enable multiPath routing
+Node set multiPath_ 1
+
+set f [eval open $dir/ospf6.tr w]
+set nf [open $dir/ospf6.nam w]
+$ns trace-all $f
+$ns namtrace-all $nf
+
+proc finish {} {
+	global ns f nf dir
+	$ns flush-trace
+	close $f
+	close $nf
+	eval exec nam $dir/ospf6.nam 
+  puts "(TCL) Finishing..."
+	exit 0
+}
+
+
+
+#################################################
+#  NODES
+#################################################
+puts "(TCL) Setting up nodes and links..."
+set n0 [$ns node]
+set n1 [$ns node]
+set n2 [$ns node]
+set n3 [$ns node]
+set n4 [$ns node]
+set n5 [$ns node]
+
+$n0 shape circle
+$n1 shape circle
+$n2 shape hexagon
+$n3 shape hexagon
+$n4 shape circle
+$n5 shape hexagon
+
+$n0 color red
+$n1 color red
+$n2 color blue
+$n3 color blue
+$n4 color red
+$n5 color blue
+
+#################################################
+# LINKS
+#################################################
+
+$ns duplex-link $n0 $n2 10Mb 2ms DropTail
+$ns duplex-link $n1 $n2 10Mb 2ms DropTail
+
+$ns duplex-link $n2 $n3 1.5Mb 10ms DropTail
+$ns duplex-link $n3 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n3 5
+$ns duplex-link-op $n2 $n3 queuePos 0
+
+
+$ns duplex-link $n2 $n5 1.5Mb 10ms DropTail
+$ns duplex-link $n5 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n5 5
+$ns duplex-link-op $n2 $n5 queuePos 0
+$ns duplex-link-op $n5 $n4 queuePos 0
+
+
+#################################################
+# Configuring TRAFFIC objects
+#################################################
+puts "(TCL) Configuring traffic objects..."
+
+set tcp1 [new Agent/TCP]
+$ns attach-agent $n0 $tcp1
+$n0 label "agent TCP"
+set snk1 [new Agent/TCPSink]
+$ns attach-agent $n4 $snk1
+$n4 label "agent TCPSink"
+$ns connect $tcp1 $snk1
+
+set cbr1 [new Application/Traffic/CBR]
+$cbr1 attach-agent $tcp1
+$cbr1 set packetSize_ 60
+$cbr1 set interval_ 0.04
+$tcp1 set fid_ 1
+$ns color 1 magenta
+
+
+set tcp2 [new Agent/TCP]
+$ns attach-agent $n1 $tcp2
+$n1 label "agent TCP"	
+set snk2 [new Agent/TCPSink]
+$ns attach-agent $n4 $snk2
+
+$ns connect $tcp2 $snk2
+
+set cbr2 [new Application/Traffic/CBR]
+$cbr2 attach-agent $tcp2
+$cbr2 set packetSize_ 60
+$cbr2 set interval_ 0.04
+$tcp2 set fid_ 2
+$ns color 2 cyan
+
+
+#################################################
+# Configuring ROUTING objects
+#################################################
+puts "(TCL) Configuring routing protocol..."
+
+# set OSPF paremeters
+Agent/rtProto/OSPF set helloInterval 1
+Agent/rtProto/OSPF set routerDeadInterval 4 
+
+# set OSPF's packets colours
+$ns setup-ospf-colors
+# Set the routing protocol to OSPF
+$ns rtproto OSPF 
+
+
+#################################################
+# Scheduling simulation
+#################################################
+puts "(TCL) Configuring routing protocol..."
+
+#modifying link state
+$ns rtmodel-at 1 down $n2 $n3
+$ns rtmodel-at 3 up $n2 $n3
+
+$ns at 0.8 "$cbr1 start"
+$ns at 0.8 "$cbr2 start"
+$ns at 10 "$cbr1 stop"
+$ns at 20 "$cbr2 stop"
+$ns at 20 "finish"
+
+
+
+puts "(TCL) Starting simulation..."
+puts ""
+$ns run
+
diff -Naur ns-2.35-orig/tcl/ex/ospf/ospf7.tcl ns-2.35/tcl/ex/ospf/ospf7.tcl
--- ns-2.35-orig/tcl/ex/ospf/ospf7.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/tcl/ex/ospf/ospf7.tcl	2015-01-24 17:02:08.975148097 +0100
@@ -0,0 +1,239 @@
+
+# AUTORA: Inés María Romero Dávia
+
+# OBJETIVO
+#   	PRTOCOLO DE ENCAMINAMIENTO OSPF
+#
+# 	Escenario para probar el protocolo de routing OSPF sobre network simulator . 
+#	Se utiliza en encaminamiento multitopologia: MTRouting
+#	Las conexiones lógicas son:
+#
+#			n0 ->n4
+#
+# TOPOLOGIA
+#
+#		$n0       $n3 _ _ $n6  
+#		   \     /   	      \ 
+#		    \   /     	       \	
+#		     $n2	       $n4
+#		    /	\              / 
+#		   /     \            /  	 
+#		$n1       \          / 
+#			      $n5	
+#
+#       7 nodos 0 - 6
+#       Links entre 0-2, 1-2
+#               bandwith 10 Mbps    delay 2ms      DropTail
+#	Links restantes
+#		bandwith 1.5Mbps    delay  10ms	    DropTail
+
+# AGENTES DE TRÁFICO
+#       Agente TCP
+#               Nodo 0
+#       Agente null/Sink
+#               Nodo 4
+#       Un agente Traffic CBR para generar el trafico
+#               Nodo 0 Packetsize 60    Interval 0.01      
+#
+#       Agente TCP
+#               Nodo 1
+#       Agente null/Sink
+#               Nodo 4
+#       Un agente Traffic CBR para generar el trafico
+#               Nodo 1 Packetsize 60    Interval 0.01      
+#
+
+# AGENTES DE ROUTING
+#	Agente OSPF
+#		Todos los nodos	
+#
+# COSTE ENLACES:
+# Topología mtid 1
+#	Enlace 2-5:5-2  = 2
+#	Resto = 1
+# Resto topologías
+#	Todos = 1
+#
+# MULTIPATH
+#	Activado	
+#
+# MTROUTING
+#	Activado	
+#
+# NUMERO DE IDENTIFICADORES MULTITOPOLOGIAS
+#	NumMtIds = 2 ==> 0,1,2	
+#
+# IDENTIFICADOR MULTITOPOLOGIA
+#	Agente TCP 0: mtid = 1	
+#	Agente TCP 1: mtid = 0
+
+######################################################################################
+
+
+Agent/TCP set syn_ false
+Agent/TCP set delay_growth_ false
+# In preparation for changing the default values for syn_ and delay_growth_.
+
+remove-all-packet-headers       ; # removes all except common
+add-packet-header Flags IP TCP rtProtoOSPF ; # hdrs reqd for validation test
+ 
+puts "(TCL) Creating simulator & trace files..."
+set dir "./out_ospf7"
+
+set ns [new Simulator]
+set vj_ss true
+
+set f [eval open $dir/ospf7.tr w]
+set nf [open $dir/ospf7.nam w]
+$ns trace-all $f
+$ns namtrace-all $nf
+
+proc finish {} {
+	global ns f nf dir
+	$ns flush-trace
+	close $f
+	close $nf
+	eval exec nam $dir/ospf7.nam 
+  puts "(TCL) Finishing..."
+	exit 0
+}
+
+
+# Enable multiPath routing
+Node set multiPath_ 1
+# Enable mtrouting
+Node set mtRouting_ 1
+
+#################################################
+#  NODES
+#################################################
+puts "(TCL) Setting up nodes and links..."
+set n0 [$ns node]
+set n1 [$ns node]
+set n2 [$ns node]
+set n3 [$ns node]
+set n4 [$ns node]
+set n5 [$ns node]
+set n6 [$ns node]
+
+$n0 shape circle
+$n1 shape circle
+$n2 shape hexagon
+$n3 shape hexagon
+$n4 shape circle
+$n5 shape hexagon
+$n6 shape hexagon
+
+$n0 color red
+$n1 color red
+$n2 color blue
+$n3 color blue
+$n4 color red
+$n5 color blue
+$n6 color blue
+
+#################################################
+# LINKS
+#################################################
+
+$ns duplex-link $n0 $n2 10Mb 2ms DropTail
+$ns duplex-link $n1 $n2 10Mb 2ms DropTail
+
+$ns duplex-link $n2 $n3 1.5Mb 10ms DropTail
+$ns duplex-link $n3 $n6 1.5Mb 10ms DropTail
+$ns duplex-link $n6 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n3 5
+$ns duplex-link-op $n2 $n3 queuePos 0
+
+
+$ns duplex-link $n2 $n5 1.5Mb 10ms DropTail
+$ns duplex-link $n5 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n5 5
+$ns duplex-link-op $n2 $n5 queuePos 0
+$ns duplex-link-op $n5 $n4 queuePos 0
+
+
+# Assigning link costs	
+$ns duplex-cost-mt $n2 $n5 2 1
+
+
+#################################################
+# Configuring TRAFFIC objects
+#################################################
+puts "(TCL) Configuring traffic objects..."
+
+set tcp1 [new Agent/TCP]
+$ns attach-agent $n0 $tcp1
+$n0 label "agent TCP"
+set snk1 [new Agent/TCPSink]
+$ns attach-agent $n4 $snk1
+$n4 label "agent TCPSink"
+$ns connect $tcp1 $snk1
+
+
+set cbr1 [new Application/Traffic/CBR]
+$cbr1 attach-agent $tcp1
+$cbr1 set packetSize_ 60
+$cbr1 set interval_ 0.01
+$tcp1 set fid_ 1
+$ns color 1 magenta
+
+
+
+set tcp2 [new Agent/TCP]
+$ns attach-agent $n1 $tcp2
+$n1 label "agent TCP"	
+set snk2 [new Agent/TCPSink]
+$ns attach-agent $n4 $snk2
+
+$ns connect $tcp2 $snk2
+
+set cbr2 [new Application/Traffic/CBR]
+$cbr2 attach-agent $tcp2
+$cbr2 set packetSize_ 60
+$cbr2 set interval_ 0.01
+$tcp2 set fid_ 2
+$ns color 2 cyan
+
+# configure mtid in packets
+$ns configure-mtid $tcp1 1
+$ns configure-mtid $tcp2 0
+$ns configure-mtid $snk1 1
+$ns configure-mtid $snk2 0
+
+
+#################################################
+# Configuring ROUTING objects
+#################################################
+puts "(TCL) Configuring routing protocol..."
+
+# set OSPF paremeters
+Agent/rtProto/OSPF set helloInterval 1
+Agent/rtProto/OSPF set routerDeadInterval 4 
+
+
+# set number of MT ids
+Simulator  set numMtIds 2
+
+# set OSPF's packets colours
+$ns setup-ospf-colors
+# Set the routing protocol to OSPF
+$ns rtproto OSPF 
+
+
+#################################################
+# Scheduling simulation
+#################################################
+puts "(TCL) Configuring routing protocol..."
+
+$ns at 0.8 "$cbr1 start"
+$ns at 0.8 "$cbr2 start"
+$ns at 10 "$cbr1 stop"
+$ns at 10 "$cbr2 stop"
+$ns at 10 "finish"
+
+
+puts "(TCL) Starting simulation..."
+puts ""
+$ns run
+
diff -Naur ns-2.35-orig/tcl/ex/ospf/ospf8.tcl ns-2.35/tcl/ex/ospf/ospf8.tcl
--- ns-2.35-orig/tcl/ex/ospf/ospf8.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/tcl/ex/ospf/ospf8.tcl	2015-01-24 17:02:08.975148097 +0100
@@ -0,0 +1,306 @@
+
+# AUTORA: Inés María Romero Dávia
+
+# OBJETIVO
+#   	PRTOCOLO DE ENCAMINAMIENTO OSPF
+#
+# 	Escenario para probar el protocolo de routing OSPF sobre network simulator . 
+#	Se utiliza en encaminamiento multitopologia: MTRouting
+# 	Se simula la modificación del estado de un enlace y la modificación del coste
+#	Las conexiones lógicas son:
+#
+#			n0 ->n4
+#			n1 ->n4
+#			n7 ->n4
+# TOPOLOGIA
+#
+#		$n0       $n3 _ _ $n6  
+#		   \     /   	      \ 
+#		    \   /     	       \	
+#	       $n1 --$n2	       $n4
+#		    /	\              / 
+#		   /     \            /  	 
+#		$n7       \          / 
+#			      $n5	
+#
+#       8 nodos 0 - 7
+#       Links entre 0-2, 1-2,  7-2
+#               bandwith 10 Mbps    delay 2ms      DropTail
+#	Links restantes
+#		bandwith 1.5Mbps    delay  10ms	    DropTail
+
+# AGENTES DE TRÁFICO
+#       Agente TCP
+#               Nodo 0
+#       Agente null/Sink
+#               Nodo 4
+#       Un agente Traffic CBR para generar el trafico
+#               Nodo 0 Packetsize 60    Interval 0.01      
+#
+#       Agente TCP
+#               Nodo 1
+#       Agente null/Sink
+#               Nodo 4
+#       Un agente Traffic CBR para generar el trafico
+#               Nodo 1 Packetsize 60    Interval 0.01      
+#
+#       Agente TCP
+#               Nodo 7
+#       Agente null/Sink
+#               Nodo 4
+#       Un agente Traffic CBR para generar el trafico
+#               Nodo 7 Packetsize 60    Interval 0.01      
+#
+
+# AGENTES DE ROUTING
+#	Agente OSPF
+#		Todos los nodos	
+#
+# COSTE ENLACES:
+# Topología mtid 0
+#	Todos=1
+# Topología mtid 1
+#	Enlace 2-5:5-2  = 2
+#	Resto = 1
+# Topología mtid 2
+#	Enlace 2-5:5-2  = 2
+#	Enlace 5-4:4-5  = 2
+#	Resto = 1
+#
+# MODIFICACIÓN ESTADO ENLACES (Modelo Manual)
+#	Enlace 2-5 
+#
+# MODIFICACIÓN COSTE ENLACES
+# Topología mtid 0
+#	Enlace 5-4:4-5  = 7
+#	Resto =1
+# Topología mtid 1
+#	Enlace 3-6:6-3 = 2
+#	Enlace 2-5:5-2  = 2
+#	Resto = 1
+# Topología mtid 2
+#	Enlace 2-5:5-2  = 2
+#	Enlace 5-4:4-5  = 1
+#	Resto = 1
+#
+# MULTIPATH
+#	Activado	
+#
+# MTROUTING
+#	Activado	
+#
+# IDENTIFICADOR MULTITOPOLOGIA
+#	MtId = 0	
+#
+# NUMERO DE IDENTIFICADORES MULTITOPOLOGIAS
+#	NumMtIds = 2 ==> 0,1,2	
+#
+# IDENTIFICADOR MULTITOPOLOGIA
+#	Agente TCP 0: mtid = 1	
+#	Agente TCP 1: mtid = 0
+#	Agente TCP 2: mtid = 2
+#
+######################################################################################
+
+
+Agent/TCP set syn_ false
+Agent/TCP set delay_growth_ false
+# In preparation for changing the default values for syn_ and delay_growth_.
+
+remove-all-packet-headers       ; # removes all except common
+add-packet-header Flags IP TCP rtProtoOSPF ; # hdrs reqd for validation test
+
+
+puts "(TCL) Creating simulator & trace files..."
+set dir "./out_ospf8"
+
+set ns [new Simulator]
+set vj_ss true
+
+set f [eval open $dir/ospf8.tr w]
+set nf [open $dir/ospf8.nam w]
+$ns trace-all $f
+$ns namtrace-all $nf
+
+proc finish {} {
+	global ns f nf dir
+	$ns flush-trace
+	close $f
+	close $nf
+	eval exec nam $dir/ospf8.nam 
+  puts "(TCL) Finishing..."
+	exit 0
+}
+
+# Enable multiPath routing
+Node set multiPath_ 1
+# Enable mtrouting
+Node set mtRouting_ 1
+
+
+#################################################
+#  NODES
+#################################################
+puts "(TCL) Setting up nodes and links..."
+set n0 [$ns node]
+set n1 [$ns node]
+set n2 [$ns node]
+set n3 [$ns node]
+set n4 [$ns node]
+set n5 [$ns node]
+set n6 [$ns node]
+set n7 [$ns node]
+
+$n0 shape circle
+$n1 shape circle
+$n2 shape hexagon
+$n3 shape hexagon
+$n4 shape circle
+$n5 shape hexagon
+$n6 shape hexagon
+$n7 shape circle
+
+$n0 color red
+$n1 color red
+$n2 color blue
+$n3 color blue
+$n4 color red
+$n5 color blue
+$n6 color blue
+$n7 color red
+
+#################################################
+# LINKS
+#################################################
+
+$ns duplex-link $n0 $n2 10Mb 2ms DropTail
+$ns duplex-link $n1 $n2 10Mb 2ms DropTail
+$ns duplex-link $n7 $n2 10Mb 2ms DropTail
+
+$ns duplex-link $n2 $n3 1.5Mb 10ms DropTail
+$ns duplex-link $n3 $n6 1.5Mb 10ms DropTail
+$ns duplex-link $n6 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n3 5
+$ns duplex-link-op $n2 $n3 queuePos 0
+
+
+$ns duplex-link $n2 $n5 1.5Mb 10ms DropTail
+$ns duplex-link $n5 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n5 5
+$ns duplex-link-op $n2 $n5 queuePos 0
+$ns duplex-link-op $n5 $n4 queuePos 0
+
+# Assigning link costs	
+$ns duplex-cost-mt $n2 $n5 2 1
+$ns duplex-cost-mt $n2 $n5 2 2
+$ns duplex-cost-mt $n5 $n4 2 2
+
+#################################################
+# Configuring TRAFFIC objects
+#################################################
+puts "(TCL) Configuring traffic objects..."
+
+set tcp1 [new Agent/TCP]
+$ns attach-agent $n0 $tcp1
+$n0 label "agent TCP"
+set snk1 [new Agent/TCPSink]
+$ns attach-agent $n4 $snk1
+$n4 label "agent TCPSink"
+$ns connect $tcp1 $snk1
+
+set cbr1 [new Application/Traffic/CBR]
+$cbr1 attach-agent $tcp1
+$cbr1 set packetSize_ 60
+$cbr1 set interval_ 0.01
+$tcp1 set fid_ 1
+$ns color 1 magenta
+
+
+set tcp2 [new Agent/TCP]
+$ns attach-agent $n1 $tcp2
+$n1 label "agent TCP"
+set snk2 [new Agent/TCPSink]
+$ns attach-agent $n4 $snk2
+$ns connect $tcp2 $snk2
+
+set cbr2 [new Application/Traffic/CBR]
+$cbr2 attach-agent $tcp2
+$cbr2 set packetSize_ 60
+$cbr2 set interval_ 0.01
+$tcp2 set fid_ 2
+$ns color 2 cyan
+
+set tcp3 [new Agent/TCP]
+$ns attach-agent $n7 $tcp3
+$n7 label "agent TCP"
+set snk3 [new Agent/TCPSink]
+$ns attach-agent $n4 $snk3
+$ns connect $tcp3 $snk3
+
+set cbr3 [new Application/Traffic/CBR]
+$cbr3 attach-agent $tcp3
+$cbr3 set packetSize_ 60
+$cbr3 set interval_ 0.01
+$tcp3 set fid_ 3
+$ns color 3 orange
+
+# configure mtid in packets
+$ns configure-mtid $tcp1 0
+$ns configure-mtid $snk1 0
+$ns configure-mtid $tcp2 1
+$ns configure-mtid $snk2 1
+$ns configure-mtid $tcp3 2
+$ns configure-mtid $snk3 2
+
+
+#################################################
+# Configuring ROUTING objects
+#################################################
+puts "(TCL) Configuring routing protocol..."
+
+# set OSPF parameters
+Agent/rtProto/OSPF set helloInterval 1
+Agent/rtProto/OSPF set routerDeadInterval 4 
+
+
+# set number of MT ids
+Simulator  set numMtIds 2
+
+# set OSPF's packets colours
+$ns setup-ospf-colors
+# Set the routing protocol to OSPF
+$ns rtproto OSPF 
+
+#################################################
+# Scheduling simulation
+#################################################
+puts "(TCL) Configuring routing protocol..."
+#modifying link state
+$ns rtmodel-at 1.5 down $n2 $n5
+$ns rtmodel-at 16 up $n2 $n5
+
+#modifiyin link cost
+
+$ns changed-cost-at-mt 20 7 0 $n5 $n4
+$ns changed-cost-at-mt 20 7 0 $n4 $n5
+
+$ns changed-cost-at-mt 21 2 1 $n3 $n6
+$ns changed-cost-at-mt 21 2 1 $n6 $n3
+
+$ns changed-cost-at-mt 22 1 2 $n2 $n5
+$ns changed-cost-at-mt 22 1 2 $n5 $n2
+
+$ns at 0.8 "$cbr1 start"
+$ns at 0.8 "$cbr2 start"
+$ns at 0.8 "$cbr3 start"
+$ns at 40 "$cbr1 stop"
+$ns at 40 "$cbr2 stop"
+$ns at 40 "$cbr3 stop"
+$ns at 40 "finish"
+
+
+
+puts "(TCL) Starting simulation..."
+puts ""
+$ns run
+
diff -Naur ns-2.35-orig/tcl/ex/ospf/ospf9.tcl ns-2.35/tcl/ex/ospf/ospf9.tcl
--- ns-2.35-orig/tcl/ex/ospf/ospf9.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/tcl/ex/ospf/ospf9.tcl	2015-01-24 17:02:08.975148097 +0100
@@ -0,0 +1,234 @@
+
+# AUTORA: Inés María Romero Dávia
+
+# OBJETIVO
+#   	PRTOCOLO DE ENCAMINAMIENTO OSPF
+#
+# 	Escenario para probar el protocolo de routing OSPF sobre network simulator .
+# 	No se configura el protocolo OSPF en todos los nodos de la topología
+#	Las conexiones lógicas son:
+#
+#			n0 ->n4
+#			n1 ->n4
+# TOPOLOGIA
+#
+#		$n0       $n3 _ _ $n6  
+#		   \     /   	      \ 
+#		    \   /     	       \	
+#		     $n2	       $n4
+#		    /	\              / 
+#		   /     \            /  	 
+#		$n1       \          / 
+#			      $n5	
+#
+#       7 nodos 0 - 6
+#       Links entre 0-2, 1-2
+#               bandwith 10 Mbps    delay 2ms      DropTail
+#	Links restantes
+#		bandwith 1.5Mbps    delay  10ms	    DropTail
+
+# AGENTES DE TRÁFICO
+#       Agente TCP
+#               Nodo 0
+#       Agente null/Sink
+#               Nodo 4
+#       Un agente Traffic CBR para generar el trafico
+#               Nodo 0 Packetsize 60    Interval 0.02      
+#
+#       Agente TCP
+#               Nodo 1
+#       Agente null/Sink
+#               Nodo 4
+#       Un agente Traffic CBR para generar el trafico
+#               Nodo 1 Packetsize 60    Interval 0.02      
+#
+
+# AGENTES DE ROUTING
+#	Agente OSPF
+#		Nodos: 0,1,2,3,4,6
+#
+# COSTE ENLACES:
+# Topologia mtid 0
+#	Todos = 1
+# Topologia mtid 1
+#	Todos = 2
+# Topologia mtid 2
+#	Todos = 3
+
+# MULTIPATH
+#	Activado	
+#
+# MTROUTING
+#	Activado	
+#
+# IDENTIFICADOR MULTITOPOLOGIA
+#	MtId = 0	
+#
+# NUMERO DE IDENTIFICADORES MULTITOPOLOGIAS
+#	Agente TCP 0: mtid = 0	
+#	Agente TCP 1: mtid = 1
+
+######################################################################################
+
+
+Agent/TCP set syn_ false
+Agent/TCP set delay_growth_ false
+# In preparation for changing the default values for syn_ and delay_growth_.
+
+remove-all-packet-headers       ; # removes all except common
+add-packet-header Flags IP TCP rtProtoOSPF ; # hdrs reqd for validation test
+
+
+puts "(TCL) Creating simulator & trace files..."
+set dir "./out_ospf9"
+
+set ns [new Simulator]
+set vj_ss true
+
+set f [eval open $dir/ospf9.tr w]
+set nf [open $dir/ospf9.nam w]
+$ns trace-all $f
+$ns namtrace-all $nf
+
+proc finish {} {
+	global ns f nf dir
+	$ns flush-trace
+	close $f
+	close $nf
+	eval exec nam $dir/ospf9.nam 
+  puts "(TCL) Finishing..."
+	exit 0
+}
+
+# Enable multiPath routing
+Node set multiPath_ 1
+# Enable mtrouting
+Node set mtRouting_ 1
+
+
+#################################################
+#  NODES
+#################################################
+puts "(TCL) Setting up nodes and links..."
+set n0 [$ns node]
+set n1 [$ns node]
+set n2 [$ns node]
+set n3 [$ns node]
+set n4 [$ns node]
+set n5 [$ns node]
+set n6 [$ns node]
+
+$n0 shape circle
+$n1 shape circle
+$n2 shape hexagon
+$n3 shape hexagon
+$n4 shape circle
+$n5 shape hexagon
+$n6 shape hexagon
+
+$n0 color red
+$n1 color red
+$n2 color blue
+$n3 color blue
+$n4 color red
+$n5 color blue
+$n6 color blue
+
+#################################################
+# LINKS
+#################################################
+
+$ns duplex-link $n0 $n2 10Mb 2ms DropTail
+$ns duplex-link $n1 $n2 10Mb 2ms DropTail
+
+$ns duplex-link $n2 $n3 1.5Mb 10ms DropTail
+$ns duplex-link $n3 $n6 1.5Mb 10ms DropTail
+$ns duplex-link $n6 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n3 5
+$ns duplex-link-op $n2 $n3 queuePos 0
+
+
+$ns duplex-link $n2 $n5 1.5Mb 10ms DropTail
+$ns duplex-link $n5 $n4 1.5Mb 10ms DropTail
+$ns queue-limit $n2 $n5 5
+$ns duplex-link-op $n2 $n5 queuePos 0
+$ns duplex-link-op $n5 $n4 queuePos 0
+
+#set initial costs 
+$ns init-links-cost
+
+#################################################
+# Configuring TRAFFIC objects
+#################################################
+puts "(TCL) Configuring traffic objects..."
+
+set tcp1 [new Agent/TCP]
+$ns attach-agent $n0 $tcp1
+$n0 label "agent TCP"
+set snk1 [new Agent/TCPSink]
+$ns attach-agent $n4 $snk1
+$n4 label "agent TCPSink"
+$ns connect $tcp1 $snk1
+
+set cbr1 [new Application/Traffic/CBR]
+$cbr1 attach-agent $tcp1
+$cbr1 set packetSize_ 60
+$cbr1 set interval_ 0.02
+$tcp1 set fid_ 1
+$ns color 1 magenta
+
+
+set tcp2 [new Agent/TCP]
+$ns attach-agent $n1 $tcp2
+$n1 label "agent TCP"
+set snk2 [new Agent/TCPSink]
+$ns attach-agent $n4 $snk2
+$ns connect $tcp2 $snk2
+
+set cbr2 [new Application/Traffic/CBR]
+$cbr2 attach-agent $tcp2
+$cbr2 set packetSize_ 60
+$cbr2 set interval_ 0.02
+$tcp2 set fid_ 2
+$ns color 2 cyan
+
+# configure mtid in packets
+$ns configure-mtid $tcp1 0
+$ns configure-mtid $snk1 0
+$ns configure-mtid $tcp2 1
+$ns configure-mtid $snk2 1
+
+#################################################
+# Configuring ROUTING objects
+#################################################
+puts "(TCL) Configuring routing protocol..."
+
+# set OSPF paremeters
+Agent/rtProto/OSPF set helloInterval 1
+Agent/rtProto/OSPF set routerDeadInterval 4 
+
+
+# set number of MT ids
+Simulator  set numMtIds 2
+
+# set OSPF's packets colours
+$ns setup-ospf-colors
+# Set the routing protocol to OSPF
+$ns rtproto OSPF [list $n0 $n1 $n2 $n3 $n4 $n6]
+
+#################################################
+# Scheduling simulation
+#################################################
+puts "(TCL) Configuring routing protocol..."
+
+$ns at 0.8 "$cbr1 start"
+$ns at 0.8 "$cbr2 start"
+$ns at 20 "$cbr1 stop"
+$ns at 20 "$cbr2 stop"
+$ns at 20 "finish"
+
+
+puts "(TCL) Starting simulation..."
+puts ""
+$ns run
+
diff -Naur ns-2.35-orig/tcl/lib/ns-default.tcl ns-2.35/tcl/lib/ns-default.tcl
--- ns-2.35-orig/tcl/lib/ns-default.tcl	2010-07-04 00:45:45.000000000 +0200
+++ ns-2.35/tcl/lib/ns-default.tcl	2015-01-24 16:57:49.561073404 +0100
@@ -365,6 +365,7 @@
 DynamicLink set status_ 1
 DynamicLink set debug_ false
 
+
 Filter set debug_ false
 Filter/Field set offset_ 0
 Filter/Field set match_  -1
@@ -549,7 +550,11 @@
 #
 
 Node set multiPath_ 0
-Node set rtagent_port_ 255
+Node set rt_port_ 255
+
+# MODIFICADO: 30-10-06
+Node set mtRouting_ 0
+# FIN MODIFICADO: 30-10-06
 
 # setting port for diffusion application agent
 Node set DIFFUSION_APP_PORT 254
@@ -823,6 +828,10 @@
 Agent set ttl_ 32 ; # arbitrary choice here
 Agent set debug_ false
 Agent set class_ 0
+# MODIFICADO: 20-01-07
+Agent set mtid_ 0
+# FIN MODIFICADO: 20-01-07
+
 
 ##Agent set seqno_ 0 now is gone
 ##Agent set class_ 0 now is gone
@@ -1350,6 +1359,18 @@
 Agent/rtProto/DV set INFINITY		 [Agent set ttl_]
 Agent/rtProto/DV set advertInterval	  2
 
+# MODIFICADO: 17-10-06
+Agent/rtProto/OSPF set helloInterval 10
+Agent/rtProto/OSPF set routerDeadInterval 40
+# FIN MODIFICADO: 17-10-06
+
+
+# MODIFICADO: 30-10-06
+# default number of MT id's: decided by the admistrator 
+Simulator set numMtIds  5
+# FIN MODIFICADO: 30-10-06
+
+
 Agent/Encapsulator set status_ 1
 Agent/Encapsulator set overhead_ 20
 
@@ -1388,6 +1409,8 @@
 Simulator set nix-routing 0
 #Node/NixNode set id_ 0
 
+
+
 #Routing Module variable setting
 RtModule set classifier_ ""
 RtModule/Base set classifier_ ""
diff -Naur ns-2.35-orig/tcl/lib/ns-lib.tcl ns-2.35/tcl/lib/ns-lib.tcl
--- ns-2.35-orig/tcl/lib/ns-lib.tcl	2010-05-10 00:28:41.000000000 +0200
+++ ns-2.35/tcl/lib/ns-lib.tcl	2015-01-24 16:57:49.562073440 +0100
@@ -224,6 +224,16 @@
 source ns-nix.tcl
 source ../pgm/ns-pgm.tcl
 source ../rtglib/ns-rtProtoLS.tcl
+
+# OSPF
+# MODIFICADO: 17-10-2006
+source ../rtglib/ns-rtProtoOSPF.tcl
+# FIN MODIFICADO 17-10-2006
+
+# MODIFICADO: 23-10-2006
+source ../rtglib/dynamicsCost.tcl
+# FIN MODIFICADO 23-10-2006
+
 source ../delaybox/delaybox.tcl
 source ../packmime/packmime.tcl
 }
@@ -973,6 +983,11 @@
 	$self check-smac                      ;# print warning if in sleep/wakeup cycle
 	$self check-node-num
 	$self rtmodel-configure			;# in case there are any
+	
+	# MODIFICADO: 23-10-06
+	$self cost-configure			;# in case there are any change of costs
+	# FIN MODIFICADO 23-10-06
+	
 	[$self get-routelogic] configure
 	$self instvar scheduler_ Node_ link_ started_ 
 	
@@ -1244,7 +1259,7 @@
 	set i1 [$n1 id]
 	set i2 [$n2 id]
 	if [info exists link_($i1:$i2)] {
-		$self remove-nam-linkconfig $i1 $i2
+		$self remove-nam-linkconfig $iF1 $i2
 	}
 	eval $self simplex-link $n1 $n2 $bw $delay $type $args
 	eval $self simplex-link $n2 $n1 $bw $delay $type $args
@@ -1534,16 +1549,30 @@
 
 Simulator instproc cost {n1 n2 c} {
 	$self instvar link_
+	# MODIFICADO: 3-11-06
+	 $link_([$n1 id]:[$n2 id]) cost-mt 0 $c 	 	 
+	# FIN MODIFICADO: 3-11-06
+
 	$link_([$n1 id]:[$n2 id]) cost $c
+	
 }
 
+# MODIFICADO: 2-1-06
+Simulator instproc duplex-cost {n1 n2 c} {
+
+	$self cost $n1 $n2 $c
+	$self cost $n2 $n1 $c
+}
+# FIN MODIFICADO: 2-1-06
+
+
 # Armando L. Caro Jr. <acaro@@cis,udel,edu> 10/22/2001
 Simulator instproc multihome-attach-agent { core agent } {
       	$agent set-multihome-core [$core entry]
 
       	foreach interface [$core set multihome_interfaces_] {
   		set ifNode [lindex $interface 0]
-		set coreLink [lindex $interface 1]
+	set coreLink [lindex $interface 1]
 
       		# attach agent to the node for each interface
       		$ifNode attach $agent
@@ -1766,7 +1795,7 @@
 	set n [Node set nn_]
 	for {set q 0} {$q < $n} {incr q} {
 		set nq $Node_($q)
-		if {[string compare [$nq node-addr] $address] == 0} {
+		if {[string compare rtmodel-configure[$nq node-addr] $address] == 0} {
 			return $q
 		}
 	}
@@ -1882,6 +1911,7 @@
 # and return the installed objects.
 #
 Classifier instproc install {slot val} {
+	
 	$self set slots_($slot) $val
 	$self cmd install $slot $val
 }
@@ -1904,6 +1934,31 @@
 	}
 	set ret
 }
+
+Classifier/MT instproc install {slot val} {
+	
+	$self set slots_($slot) $val
+	$self cmd install $slot $val
+}
+
+Classifier/MT instproc installNext val {
+	set slot [$self cmd installNext $val]
+	$self set slots_($slot) $val
+	set slot
+}
+
+Classifier/MT instproc adjacents {} {
+	$self array get slots_
+}
+
+Classifier/MT instproc in-slot? slot {
+	$self instvar slots_
+	set ret ""
+	if {[array size slots_] < $slot} {
+		set ret slots_($slot)
+	}
+	set ret
+}
 
 # For debugging
 Classifier instproc dump {} {
diff -Naur ns-2.35-orig/tcl/lib/ns-link.tcl ns-2.35/tcl/lib/ns-link.tcl
--- ns-2.35-orig/tcl/lib/ns-link.tcl	2009-01-15 07:14:27.000000000 +0100
+++ ns-2.35/tcl/lib/ns-link.tcl	2015-01-24 16:57:49.562073440 +0100
@@ -38,7 +38,7 @@
 Link set nl_ 0
 
 Link instproc init { src dst } {
-	$self next
+	$self next 
 
 	# Debo
 	$self instvar id_
@@ -91,6 +91,28 @@
 	set cost_
 }
 
+# MODIFICADO: 21-12-06
+Link instproc cost-mt {mtid c} {
+ $self instvar MtCost_ 	
+	$self cost $c
+	set MtCost_($mtid) $c
+	puts "cost-mt: mtid: $mtid coste: $c"
+	  	         
+}
+
+Link instproc cost-mt? {mtid} {
+$self instvar MtCost_ cost_
+
+	if ![info exists MtCost_($mtid)] {
+	puts "No existe MtCost_"
+	set MtCost_($mtid) 1
+	}
+
+	puts "cost-mt?: mtid:$mtid coste:$MtCost_($mtid)"
+	set MtCost_($mtid) 	
+}
+# FIN MODIFICADO: 25-10-06
+
 # Debo
 Link instproc id {} 	{ $self set id_ }
 Link instproc setid { x } { $self set id_ $x }
@@ -111,8 +133,16 @@
 			set ns [Simulator instance]
 			$self instvar fromNode_ toNode_
 			$tr ntrace "l -t [$ns now] -s [$fromNode_ id] -d [$toNode_ id] -S UP"
-			$tr ntrace "v -t [$ns now] link-up [$ns now] [$fromNode_ id] [$toNode_ id]"
+			# MODIFICADO: 31-10-06
+			#$tr ntrace "v -t [$ns now] link-up [$ns now] [$fromNode_ id] [$toNode_ id]"
+			$tr ntrace "v -t [$ns now] -e link-up [$ns now] [$fromNode_ id] [$toNode_ id]"
+			# FIN MODIFICADO: 31-10-06
 		}
+	# MODIFICADO: 2-11-06
+	set ns [Simulator instance]
+	$self instvar fromNode_ toNode_
+	$ns trace-annotate "Enlace [$fromNode_ id]:[$toNode_ id]: UP"
+	# FIN MODIFICADO: 2-11-06
 	}
 }
 
@@ -130,8 +160,17 @@
 			set ns [Simulator instance]
 			$self instvar fromNode_ toNode_
 			$tr ntrace "l -t [$ns now] -s [$fromNode_ id] -d [$toNode_ id] -S DOWN"
-			$tr ntrace "v -t [$ns now] link-down [$ns now] [$fromNode_ id] [$toNode_ id]"
+			# MODIFICADO: 31-10-06
+			#$tr ntrace "v -t [$ns now] link-down [$ns now] [$fromNode_ id] [$toNode_ id]"
+			$tr ntrace "v -t [$ns now] -e link-down [$ns now] [$fromNode_ id] [$toNode_ id]"
+			# FIN MODIFICADO: 31-10-06
 		}
+
+	# MODIFICADO: 2-11-06
+	set ns [Simulator instance]
+	$self instvar fromNode_ toNode_
+	$ns trace-annotate "Enlace [$fromNode_ id]:[$toNode_ id]: DOWN"
+	# FIN MODIFICADO: 2-11-06
 	}
 }
 
@@ -537,6 +576,7 @@
 	$self all-connectors isDynamic
 }
 
+
 #
 # insert an "error module" BEFORE the queue
 # point the em's drop-target to the drophead
diff -Naur ns-2.35-orig/tcl/lib/ns-node.tcl ns-2.35/tcl/lib/ns-node.tcl
--- ns-2.35-orig/tcl/lib/ns-node.tcl	2001-11-06 07:16:21.000000000 +0100
+++ ns-2.35/tcl/lib/ns-node.tcl	2015-01-24 16:57:49.562073440 +0100
@@ -66,7 +66,7 @@
 	eval $self next $args
 
         $self instvar id_ agents_ dmux_ neighbor_ rtsize_ address_ \
-			nodetype_ multiPath_ ns_ rtnotif_ ptnotif_
+			nodetype_ multiPath_ ns_ rtnotif_ ptnotif_ mtRouting_
 
 	set ns_ [Simulator instance]
 	set id_ [Node getid]
@@ -91,6 +91,9 @@
 
 	# XXX Eventually these two should also be converted to modules
 	set multiPath_ [$class set multiPath_]
+	# MODIFICADO: 28-12-06
+	set mtRouting_ [$class set mtRouting_]
+	# FIN MODIFICADO: 28-12-06
 }
 
 # XXX This instproc is backward compatibility; when satellite node, mobile
@@ -296,10 +299,25 @@
 #
 Node instproc init-routing rtObject {
 	$self instvar multiPath_ routes_ rtObject_
-	set nn [$class set nn_]
+	# MODIFICADO:24-01-07
+	$self instvar ns_ routesMt_
+	# FIN MODIFICADO:24-01-07 
+
+
+	set nn [$class set nn_]	
 	for {set i 0} {$i < $nn} {incr i} {
 		set routes_($i) 0
 	}
+
+	# MODIFICADO:24-01-07 
+	set nmtids [$ns_ get-num-mtids]	
+	for {set i 0} {$i < $nn} {incr i} {
+		for { set j 0 } {$j <= $nmtids} {incr j} {
+		set routesMt_($i:$j) 0
+		}
+	}
+	# FIN MODIFICADO:24-01-07 
+
 	if ![info exists rtObject_] {
 		$self set rtObject_ $rtObject
 	}
@@ -322,7 +340,16 @@
 	}
 }
 
+# MODIFICADO: 23-10-06
 
+Node instproc cost-changed {} {
+	$self instvar rtObject_
+	if [info exists rtObject_] {	;# i.e. detailed dynamic routing
+		$rtObject_ cost-changed
+	}
+}
+# FIN MODIFICADO: 23-10-06
+
 #----------------------------------------------------------------------
 
 # XXX Eventually add-routes{} and delete-routes{} should be 
@@ -331,7 +358,9 @@
 # Node support for equal cost multi path routing
 Node instproc add-routes {id ifs} {
 	$self instvar classifier_ multiPath_ routes_ mpathClsfr_
+	
 	if !$multiPath_ {
+	
 		if {[llength $ifs] > 1} {
 			warn "$class::$proc cannot install multiple routes"
 			set ifs [lindex $ifs 0]
@@ -344,19 +373,26 @@
 			![info exists mpathClsfr_($id)]} {
 		$self add-route $id [$ifs head]
 		set routes_($id) 1
+		
+		
 	} else {
 		if ![info exists mpathClsfr_($id)] {
+			
 			#
 			# 1. get new MultiPathClassifier,
 			# 2. migrate existing routes to that mclassifier
 			# 3. install the mclassifier in the node classifier_
 			#
 			set mpathClsfr_($id) [new Classifier/MultiPath]
+			
 			if {$routes_($id) > 0} {
+				
 				assert "$routes_($id) == 1"
 				$mpathClsfr_($id) installNext \
 						[$classifier_ in-slot? $id]
+				
 			}
+			
 			$classifier_ install $id $mpathClsfr_($id)
 		}
 		foreach L $ifs {
@@ -366,8 +402,12 @@
 	}
 }
 
+
 Node instproc delete-routes {id ifs nullagent} {
 	$self instvar mpathClsfr_ routes_
+	$self instvar mtRouting_
+	
+	
 	if [info exists mpathClsfr_($id)] {
 		foreach L $ifs {
 			set nonLink([$L head]) 1
@@ -384,7 +424,88 @@
 		# Notice that after this operation routes_($id) may not 
 		# necessarily be 0.
 	}
+  }
+
+
+# MODIFICADO:22-01-07
+# Node support for multi topology routing
+Node instproc add-routes-mt {id ifs mtid} {
+$self instvar classifier_ multiPath_ routesMt_  mtopoClsfr_ mpathClsfr_
+puts "add-routes-mt"	
+puts "Destino: $id"
+puts "Mtid: $mtid"
+
+
+
+	if ![info exists mtopoClsfr_($id)] {
+		puts "no existe mtopoclasifier"
+		# 1. get new MTopolClassifier	
+		# 2. install the mtclassifier in the node classifier_
+		set mtopoClsfr_($id) [new Classifier/MT]
+		$classifier_ install $id $mtopoClsfr_($id)
+
+	}
+	
+	if !$multiPath_ {
+	
+		if {[llength $ifs] > 1} {
+			warn "$class::$proc cannot install multiple routes"
+			set ifs [lindex $ifs 0]
+		}
+		$mtopoClsfr_($id) install $mtid [$ifs head]
+		set routesMt_($id:$mtid) 1
+		return
+	}
+	
+	if ![info exists mpathClsfr_($id:$mtid)] {
+			
+			#
+			# 1. get new MultiPathClassifier,
+			# 2. migrate existing routes to that mclassifier
+			# 3. install the mpathclassifier in the node mtopoClsfr_
+			#
+			set mpathClsfr_($id:$mtid) [new Classifier/MultiPath]
+									
+			$mtopoClsfr_($id) install $mtid $mpathClsfr_($id:$mtid)
+		}
+		foreach L $ifs {
+			$mpathClsfr_($id:$mtid) installNext [$L head]
+			incr routesMt_($id:$mtid)
+		}
+	
+
+	
+}
+
+
+Node instproc delete-routes-mt {id ifs nullagent mtid} {
+$self instvar mpathClsfr_ routesMt_ mtopoClsfr_ routes_
+	puts "delte-routes-mt"
+	if [info exists mpathClsfr_($id:$mtid)] {
+		foreach L $ifs {
+			set nonLink([$L head]) 1
+		}
+		foreach {slot link} [$mpathClsfr_($id:$mtid) adjacents] {
+			if [info exists nonLink($link)] {
+				$mpathClsfr_($id:$mtid) clear $slot
+				set routesMt_($id:$mtid) -1
+			}
+		}	
+	} 
+
+	if [info exists mtopoClsfr_($id)] {
+		foreach L $ifs {
+			set nonLink([$L head]) 1
+		}
+		foreach {slot link} [$mtopoClsfr_($id) adjacents] {
+			if [info exists nonLink($link)] {
+				$mtopoClsfr_($id) clear $slot				
+			}
+		}
+	} 	
+
 }
+# FIN MODIFICADO:22-01-07
 
 # Enable multicast routing support in this node. 
 # 
diff -Naur ns-2.35-orig/tcl/lib/ns-packet.tcl ns-2.35/tcl/lib/ns-packet.tcl
--- ns-2.35-orig/tcl/lib/ns-packet.tcl	2011-10-15 00:11:08.000000000 +0200
+++ ns-2.35/tcl/lib/ns-packet.tcl	2015-01-24 16:57:49.562073440 +0100
@@ -121,6 +121,9 @@
 	rtProtoLS 	# link state routing protocol
 	SR 	# source routing, dsr/hdr_sr.cc
 	Src_rt 	# source routing, src_rtg/hdr_src.cc
+	# MODIFICADO 3-10-2006
+	rtProtoOSPF	# Open Shortes Path First
+	# FIN MODIFICADO 3-10-2006
 # Routers:
 	LDP 	# mpls/ldp.cc
 	MPLS 	# MPLS, MultiProtocol Label Switching
diff -Naur ns-2.35-orig/tcl/rtglib/dynamicsCost.tcl ns-2.35/tcl/rtglib/dynamicsCost.tcl
--- ns-2.35-orig/tcl/rtglib/dynamicsCost.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/tcl/rtglib/dynamicsCost.tcl	2015-01-24 16:57:49.563073476 +0100
@@ -0,0 +1,187 @@
+
+Class costQueue
+
+Simulator instproc changed-cost-at { at c args } {
+	set lcost ""
+	$self instvar linkCost_
+		
+	set lcost [eval new linkCost $self]
+	eval $lcost set-elements $args
+	eval $lcost set-parms 0 $at $c 
+
+	if [info exists linkCost_] {
+		lappend linkCost_ $lcost
+	} else {
+		set linkCost_ $lcost
+	}
+	
+	return $lcost
+}
+
+Simulator instproc changed-cost-at-mt { at c mtid args } {
+	set lcost ""
+	$self instvar linkCost_
+	set nMtIds_ [$class set numMtIds]
+	if {$mtid<=$nMtIds_} {
+		set lcost [eval new linkCost $self]
+		eval $lcost set-elements $args
+		eval $lcost set-parms $mtid $at $c 
+
+	if [info exists linkCost_] {
+		lappend linkCost_ $lcost
+	} else {
+		set linkCost_ $lcost
+	}
+	
+	return $lcost
+	}
+	#else
+	 puts "WARNING: changed-cost-at-mt"
+	 puts "Cost not modified. The mtid=$mtid is not defined"
+	 puts "Number of mtids defined is $nMtIds_." 
+	 return
+}
+
+Simulator instproc cost-configure {} {
+    $self instvar cq_ linkCost_
+    if [info exists linkCost_] {
+	set cq_ [new costQueue $self]
+	foreach m $linkCost_ {
+	    $m configure
+	 }
+    }
+}
+
+costQueue instproc init ns {
+    $self next
+    $self instvar ns_
+    set ns_ $ns
+}
+
+
+costQueue instproc insq { at obj iproc args } {
+    $self instvar cq_ ns_
+    if {[$ns_ now] >= $at} {
+	puts stderr "$proc: Cannot set event in the past"
+	set at ""
+    } else {
+	if ![info exists cq_($at)] {
+	    $ns_ at $at "$self runq $at"
+	    
+	}
+	lappend cq_($at) "$obj $iproc $args"
+    }
+    return $at
+}
+
+
+costQueue instproc runq { time } {
+    $self instvar cq_
+    set objects ""
+    foreach event $cq_($time) {
+	set obj   [lindex $event 0]
+	set iproc [lindex $event 1]
+	set args  [lrange $event 2 end]
+	eval $obj $iproc $args 
+	lappend objects $obj
+    }
+    foreach obj $objects {
+	$obj notify-cost
+    }
+    unset cq_($time)
+}
+
+#
+Class linkCost
+
+linkCost set cq_ ""
+
+linkCost instproc init ns {
+    $self next
+    $self instvar ns_ 
+    set ns_ $ns
+    
+}
+
+linkCost instproc set-elements args {
+    $self instvar ns_ links_ nodes_
+    if { [llength $args] == 2 } {
+	set n0 [lindex $args 0]
+	set n1 [lindex $args 1]
+	set n0id [$n0 id]
+	set n1id [$n1 id]
+	
+	set nodes_($n0id) $n0
+	set nodes_($n1id) $n1
+	set links_($n0id:$n1id) [$ns_ link $n0 $n1]
+	
+    } else {
+	puts stderr "changed-cost-at: It's must be indicated two nodes"
+	
+	}
+    	
+    
+}
+
+linkCost instproc set-parms {mtid at c} {
+    $self instvar mt_ at_ c_
+    set mt_ $mtid
+    set at_ $at
+    set c_ $c	   
+}
+
+linkCost instproc configure {} {
+    $self instvar ns_ links_ mt_ at_ c_
+  
+    if { [linkCost set cq_] == "" } {
+	linkCost set cq_ [$ns_ set cq_]	
+    }
+    $self set-event $at_ $mt_ $c_
+}
+
+linkCost instproc set-event {fireTime mtid c} {
+    $self instvar ns_ 
+    [linkCost set cq_] insq $fireTime $self cost $mtid $c
+    
+}
+
+linkCost instproc cost {mtid c} {
+    $self instvar links_ ns_
+    
+    foreach l [array names links_] {
+	set L [split $l :]
+	set src [lindex $L 0]
+	set dest  [lindex $L 1]
+	puts "src: $src"
+	puts "dest: $dest"
+	puts "coste: $c"
+	set nsrc [$ns_ get-node-by-id $src]
+	set ndest [$ns_ get-node-by-id $dest]
+	$ns_ trace-annotate "Enlace $src:$dest: COSTE MODIFICADO antiguo:[$links_($l) cost?] nuevo:$c"
+	if {$mtid==0} {
+		$ns_ cost-mt $nsrc $ndest $c $mtid
+		$ns_ cost $nsrc $ndest $c 
+		continue
+	}
+    
+	$ns_ cost-mt $nsrc $ndest $c $mtid
+   }	
+}
+
+
+linkCost instproc notify-cost {} {
+    $self instvar ns_ links_ nodes_
+	puts "notify cost node"
+	foreach l [array names links_] {
+	set L [split $l :]
+	set src [lindex $L 0]
+	#notify only to the source node
+	set nsrc [$ns_ get-node-by-id $src]
+	puts "NOTIFY COST NODE: $src"
+	$nodes_($src) cost-changed
+	continue
+    }
+    	
+    [$ns_ get-routelogic] notify
+    	
+}
diff -Naur ns-2.35-orig/tcl/rtglib/ns-rtProtoLS.tcl ns-2.35/tcl/rtglib/ns-rtProtoLS.tcl
--- ns-2.35-orig/tcl/rtglib/ns-rtProtoLS.tcl	2005-09-16 05:05:46.000000000 +0200
+++ ns-2.35/tcl/rtglib/ns-rtProtoLS.tcl	2015-01-24 16:57:49.563073476 +0100
@@ -157,15 +157,20 @@
 
 	set updateTime [expr [$ns_ now] + ([$class set advertInterval] * \
 			[$rtglibRNG uniform 0.5 1.5])]
+	
 	$ns_ at $updateTime "$self send-periodic-update"
 }
 
 # like DV's, except cmd computeRoutes
 Agent/rtProto/LS instproc compute-routes {} {
-	$self instvar node_
+	$self instvar node_ rtsChanged_
 	#puts "Node [$node_ id]: Agent/rtProto/LS compute-routes"
+	
 	$self cmd computeRoutes
 	$self install-routes
+	
+
+	
 }
 
 # like DV's, except cmd intfChanged(), comment out DV stuff
@@ -270,8 +275,10 @@
 			lappend linksStatus 0
 		}
 		lappend linksStatus [$ifs_($nbr) cost?]
+		
 	}
 	set linksStatus
+      
 }
 
 Agent/rtProto/LS instproc get-peers {} {
@@ -298,5 +305,19 @@
 		set p_delay [time_parse [ [$intf link ] set delay_] ]
 		set total_delay [expr $q_limit * $packet_size / $bw + $p_delay]
 		$self cmd setDelay [$nbr id] $total_delay
+		
 	}
 }
+
+
+# MODIFICADO: 26-10-06
+Agent/rtProto/LS instproc cost-changed {} {
+    #NOTHING
+}
+# FIN MODIFICADO: 26-10-06
+
+# MODIFICADO: 26-10-06
+Agent/rtProto/LS instproc compute-routes-cost {} {
+    #NOTHING
+}
+# FIN MODIFICADO: 26-10-06
diff -Naur ns-2.35-orig/tcl/rtglib/ns-rtProtoOSPF.tcl ns-2.35/tcl/rtglib/ns-rtProtoOSPF.tcl
--- ns-2.35-orig/tcl/rtglib/ns-rtProtoOSPF.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/tcl/rtglib/ns-rtProtoOSPF.tcl	2015-01-24 16:57:49.563073476 +0100
@@ -0,0 +1,517 @@
+
+Agent/rtProto/OSPF set UNREACHABLE  [rtObject set unreach_]
+Agent/rtProto/OSPF set preference_        120
+Agent/rtProto/OSPF set INFINITY           [Agent set ttl_]
+
+
+Agent/rtProto/OSPF proc init-all args {
+	if { [llength $args] == 0 } {
+		set nodeslist [[Simulator instance] all-nodes-list]
+	} else { 
+		eval "set nodeslist $args"
+	}
+	Agent set-maxttl Agent/rtProto/OSPF INFINITY
+	eval rtObject init-all $nodeslist
+	foreach node $nodeslist {
+		set proto($node) [[$node rtObject?] add-proto OSPF $node]
+		$node add-mark "agent OSPF" black
+		
+		
+	}
+	foreach node $nodeslist {
+		
+		foreach nbr [$node neighbors] {
+			set rtobj [$nbr rtObject?]
+			if { $rtobj == "" } {
+				continue
+			}
+			set rtproto [$rtobj rtProto? OSPF]
+			if { $rtproto == "" } {
+				continue
+			}
+			$proto($node) add-peer $nbr \
+					[$rtproto set agent_addr_] \
+					[$rtproto set agent_port_]
+		}
+	}
+
+	# -- OSPF stuffs --
+	set first_node [lindex $nodeslist 0 ]
+	foreach node $nodeslist {
+		set rtobj [$node rtObject?]
+		if { $rtobj == "" } {
+			continue
+		}
+		set rtproto [$rtobj rtProto? OSPF]
+		if { $rtproto == "" } {
+			continue
+		}
+		$rtproto cmd initialize
+		if { $node == $first_node } {
+			$rtproto cmd setNodeNumber \
+				[[Simulator instance] get-number-of-nodes]
+		}
+	}
+
+}
+
+Agent/rtProto/OSPF instproc init node {
+	global rtglibRNG
+	
+	$self next $node
+	$self instvar ns_ rtObject_ ifsUp_ rtsChanged_ rtpref_ nextHop_ \
+		nextHopPeer_ metric_ multiPath_ 
+	$self instvar mtRouting_ nextHopMt_ numMtIds_ metricMt_
+	Agent/rtProto/OSPF instvar preference_ 
+		
+	set numMtIds_ [$self get-num-mtids]
+
+	;# -- OSPF stuffs -- 
+	$self instvar OSPF_ready
+	set OSPF_ready 0
+	set rtsChanged_ 1
+	
+	
+	set UNREACHABLE [$class set UNREACHABLE]
+	foreach dest [$ns_ all-nodes-list] {
+		set rtpref_($dest) $preference_
+		set nextHop_($dest) ""
+		set nextHopPeer_($dest) ""
+		set metric_($dest)  $UNREACHABLE
+		
+	}
+
+	foreach dest [$ns_ all-nodes-list] {
+		for {set mtId 0} { $mtId <= $numMtIds_ } {incr mtId} {
+		set nextHopMt_([$dest id]:$mtId) ""
+		set metricMt_([$dest id]:$mtId) $UNREACHABLE	
+		}
+	}
+	
+
+	set ifsUp_ ""
+	set multiPath_ [[$rtObject_ set node_] set multiPath_]
+	set mtRouting_ [[$rtObject_ set node_] set mtRouting_]
+	
+	set HelloTime [$rtglibRNG uniform 0.0 0.5]
+	$ns_ at $HelloTime "$self send-periodic-hello"
+}
+
+Agent/rtProto/OSPF instproc add-peer {nbr agentAddr agentPort} {
+	$self instvar peers_
+	$self set peers_($nbr) [new rtPeer $agentAddr $agentPort $class]
+}
+
+Agent/rtProto/OSPF instproc send-periodic-hello {} {
+	global rtglibRNG 
+	$self instvar ns_ node_
+	# -- OSPF stuffs --
+	$self cmd sendHellos
+	set helloTime [expr [$ns_ now] + ([$class set helloInterval])]
+	puts "Nodo: [$node_ id]"
+	puts "HelloTime: $helloTime"
+	$ns_ at $helloTime "$self send-periodic-hello"
+}
+
+
+Agent/rtProto/OSPF instproc get-node-id {} {
+	$self instvar node_
+	return [$node_ id]
+}
+
+
+Agent/rtProto/OSPF instproc get-peers {} {
+	$self instvar peers_ ifs_
+	set peers ""
+	foreach nbr [lsort -dictionary [array names peers_]] {
+
+	  if {[$ifs_($nbr) up?] == "up"} {
+		
+		lappend peers [$nbr id]
+		lappend peers [$peers_($nbr) addr?]
+		lappend peers [$peers_($nbr) port?]
+	  }
+	} 
+	set peers
+}
+
+
+
+# needed to calculate the appropriate timeout value for retransmission 
+# of unack'ed Update,DD, or Request messages
+Agent/rtProto/OSPF instproc get-delay-estimates {} {
+	$self instvar ifs_ ifstat_ 
+	set total_delays ""
+	set packet_size 8000.0 ;# bits
+	foreach nbr [array names ifs_] {
+		set intf $ifs_($nbr)
+		set q_limit [ [$intf queue ] set limit_]
+		set bw [bw_parse [ [$intf link ] set bandwidth_ ] ]
+		set p_delay [time_parse [ [$intf link ] set delay_] ]
+		set total_delay [expr $q_limit * $packet_size / $bw + $p_delay]
+		$self cmd setDelay [$nbr id] $total_delay
+	}
+}
+
+Agent/rtProto/OSPF instproc intf-changed {} {
+
+ $self instvar rtsChanged_ 	
+ set rtsChanged_ 0
+ puts "estado modificado"
+ $self cmd interfaceChanged
+	
+}
+
+Agent/rtProto/OSPF instproc compute-routes {} {
+	$self instvar node_ rtsChanged_
+	puts "Agent OSPF [$node_ id]: compute-routes"
+	if $rtsChanged_ {	
+	puts "rtsChanged activo"
+	$self cmd computeRoutes
+	$self install-routes
+	}
+}
+
+
+Agent/rtProto/OSPF instproc compute-routes-cost {} {
+	$self instvar node_ rtsChanged_
+	puts "Agent OSPF [$node_ id]: compute-routes-cost"
+	$self cmd computeRoutes
+	$self install-routes
+	
+}
+
+Agent/rtProto/OSPF instproc cost-changed {} {
+	$self instvar rtsChanged_
+	set rtsChanged_ 1
+	# -- OSPF stuffs --
+	puts "coste modificado"
+	$self cmd intfChanged
+	$self route-changed
+ 
+}
+
+Agent/rtProto/OSPF instproc route-changed {} {
+	$self instvar node_ 
+	$self instvar rtObject_  rtsChanged_ 
+	set rtsChanged_ 1
+	$self install-routes
+	puts "route-changed"
+	$rtObject_ compute-routes
+    
+}
+
+# put the routes computed in C++ into tcl space
+Agent/rtProto/OSPF instproc install-routes {} {
+
+$self instvar ns_ ifs_ rtpref_ metric_ nextHop_ nextHopPeer_
+$self instvar peers_ rtsChanged_ multiPath_ mtRouting_
+$self instvar node_  preference_ 
+$self instvar numMtIds_ nextHopMt_ metricMt_
+
+    
+	set INFINITY [$class set INFINITY]
+	set MAXPREF  [rtObject set maxpref_]
+	set UNREACH  [rtObject set unreach_]
+	set rtsChanged_ 1 
+	
+	
+	    foreach dst [$ns_ all-nodes-list] {
+		puts "installing routes for [$dst id]"
+
+		if { $dst == $node_ } {
+			set metric_($dst) 32  ;# the magic number
+			continue
+		}
+
+		if {!$mtRouting_} {	
+	
+		puts " [$node_ id] looking for route to [$dst id]"	
+		
+		set path [$self cmd lookup [$dst id] 0]
+		 puts "PATH: $path" ;# debug
+		if { [llength $path ] == 0 } {
+			puts "no path found in OSPF"
+			set rtpref_($dst) $MAXPREF
+			set metric_($dst) $UNREACH
+			set nextHop_($dst) ""
+			continue
+		}
+		
+		set cost [lindex $path 0]
+		set rtpref_($dst) $preference_
+		set metric_($dst) $cost
+		
+		if { ! $multiPath_ } {
+			puts "NO MULTIPATH"
+			set nhNode [$ns_ get-node-by-id [lindex $path 1]]
+			puts "NO MULTIPATH NEXT HOP: [$nhNode id]"
+			set nextHop_($dst) $ifs_($nhNode)
+			continue
+		}
+		
+		#if multiPath
+		set nextHop_($dst) ""
+		set nh ""
+		set count [llength $path]
+		puts "COUNT: $count"
+		
+		foreach nbr [lsort -dictionary [array names peers_]] {
+			puts " PEER: [$nbr id]"
+			foreach nhId [lrange $path 1 $count ] {
+				puts "NEIGHBOURID PATH: $nhId"
+				if { [$nbr id] == $nhId } {
+					lappend nextHop_($dst) $ifs_($nbr)
+					break
+				}
+			}
+		}
+
+	     	continue
+		}
+
+		#if mtrouting
+		puts "MTROUTING"
+		puts " [$node_ id] looking for route to [$dst id]"
+		for {set mtId 0} { $mtId <= $numMtIds_ } {incr mtId} {
+			set path [$self cmd lookup [$dst id] $mtId]
+			puts "MTROUTING PATH MTID $mtId: $path" ;# debug
+			
+			if { [llength $path ] == 0 } {
+			# no path found in LS
+				set nextHopMt_([$dst id]:$mtId) ""				
+				set metricMt_([$dst id]:$mtId) $UNREACH	
+				if {$mtId==0} {
+					set nextHop_($dst) ""
+					set metric_($dst) $UNREACH
+					set rtpref_($dst) $MAXPREF
+				}
+				continue
+			}
+
+			set cost [lindex $path 0]
+			set metricMt_([$dst id]:$mtId) $cost						
+                     	
+			if {$mtId==0} {
+			
+			# we only consider the default topology cost to compare to the rest
+			# of routing protocols 
+			set cost [lindex $path 0]
+			set rtpref_($dst) $preference_
+			set metric_($dst) $cost						
+                     	}
+			
+			
+			if { ! $multiPath_ } {
+				set nhNode [$ns_ get-node-by-id [lindex $path 1]]
+				puts "!MULTIPATH MTID: $mtId [$nhNode id]"
+				set nextHopMt_([$dst id]:$mtId) $ifs_($nhNode)
+				
+				if {$mtId==0} {
+					set nextHop_($dst) $ifs_($nhNode)
+				}
+				continue
+			}
+		
+			#if multiPath
+			set nextHopMt_([$dst id]:$mtId) ""
+			set nh ""
+			if {$mtId==0} {
+			   set nextHop_($dst) ""
+			}
+			set count [llength $path]
+			foreach nbr [lsort -dictionary [array names peers_]] {
+			puts " MTROUTING PEER: [$nbr id]"
+			   foreach nhId [lrange $path 1 $count ] {
+				puts " nhId: $nhId"
+				if { [$nbr id] == $nhId } {
+					puts "MTROUTING NEIGHBOURID PATH: $nhId"
+					lappend nextHopMt_([$dst id]:$mtId) $ifs_($nbr)
+						
+					if {$mtId==0} {
+					   lappend nextHop_($dst) $ifs_($nbr)
+					}
+					
+					break
+				}
+			}
+		}
+		
+ 	   }		
+	
+     }
+
+}
+
+Agent/rtProto/OSPF proc compute-all {} {
+	# Because proc methods are not inherited from the parent class.
+}
+
+# get the number of MtIds configured
+Agent/rtProto/OSPF instproc get-num-mtids {} {
+	$self instvar ns_
+	$ns_ get-num-mtids
+}
+
+Agent/rtProto/OSPF instproc  get-links-status {} {
+
+	$self instvar ifs_ 
+	$self instvar mtRouting_ node_
+	set linksStatus ""
+	set numMtids [$self get-num-mtids]	
+	
+	foreach nbr [array names ifs_] {
+		lappend linksStatus [$nbr id]
+		lappend linksStatus 1 ;# point to point type
+		lappend linksStatus $numMtids
+		
+		for {set i 0} { $i <= $numMtids } {incr i} {
+			lappend linksStatus $i
+			set coste  [$ifs_($nbr) cost-mt? $i]
+			lappend linksStatus $coste
+		}
+	
+	}
+	
+	
+	set linksStatus
+      
+}
+
+Agent/rtProto/OSPF instproc  hello-colour {} {
+	$self set fid_ 991
+}
+
+Agent/rtProto/OSPF instproc  dd-colour {} {
+	$self set fid_ 992
+}
+
+Agent/rtProto/OSPF instproc  update-colour {} {
+	$self set fid_ 993
+}
+
+Agent/rtProto/OSPF instproc  request-colour {} {
+	$self set fid_ 994
+}
+
+Agent/rtProto/OSPF instproc  ack-colour {} {
+	$self set fid_ 995
+}
+
+
+Simulator instproc get-num-mtids {} {
+
+	set numMtids ""
+	set numMtids [$class set numMtIds]
+	set numMtids
+	
+}
+
+Simulator instproc setup-ospf-colors {} {
+	
+	$self ospf-hello-color  blue
+	$self ospf-dd-color  red
+	$self ospf-update-color  green
+	$self ospf-request-color  violet
+	$self ospf-ack-color  yellow
+}
+
+Simulator instproc ospf-hello-color {color} {
+	$self color 991 $color
+}
+
+Simulator instproc ospf-dd-color {color} {
+	$self color 992 $color
+}
+
+Simulator instproc ospf-update-color {color} {
+	$self color 993 $color
+}
+
+Simulator instproc ospf-request-color {color} {
+	$self color 994 $color
+}
+
+Simulator instproc ospf-ack-color {color} {
+	$self color 995 $color
+}
+
+Simulator instproc cost-mt {n1 n2 c mtid} {
+	$self instvar link_ 
+	set nMtIds_ [$class set numMtIds]
+	#for {set i 0} { $i <= $nMtIds_ } {incr i} {
+	#$link_([$n1 id]:[$n2 id]) cost-mt $i $cost
+	#set cost [expr $cost + 1]
+	#}
+	#if {[$n1 set mtRouting_]&& [$n2 set mtRouting_]}  {
+	#puts "WARNING: mtRouting active. Cost set for default topology"
+	# $link_([$n1 id]:[$n2 id]) cost-mt $mtid $c 
+	# return	 
+	#}
+	#puts "WARNING: mtRouting is not active."
+	#$link_([$n1 id]:[$n2 id]) cost $c
+
+	  if {$mtid <= $nMtIds_} {
+	    $link_([$n1 id]:[$n2 id]) cost-mt $mtid $c
+	    return
+	  }  
+	  #else
+	 puts "WARNING: Simulator instproc cost-mt."
+	 puts "Cost not assigned [$n1 id]-->[$n2 id]. The mtid=$mtid is not defined"
+	 puts "Number of topologies defined: $nMtIds_"  
+		
+}
+
+Simulator instproc duplex-cost-mt {n1 n2 c mtid} {
+
+	$self cost-mt $n1 $n2 $c $mtid
+	$self cost-mt $n2 $n1 $c $mtid
+}
+
+Simulator instproc configure-mtid {agent mtid} {
+	
+	set nMtIds_ [$class set numMtIds]
+	
+	  if {$mtid <= $nMtIds_} {
+		$agent set mtid_ $mtid
+		return
+	  } 
+	  #	else 
+	puts "WARNING:Simulator instproc configure-mtid."
+	puts "mtid=$mtid is not valid. Number of topologies defined is $nMtIds_" 
+	  
+}
+
+Simulator instproc init-links-cost {} {
+    $self instvar link_
+    	
+    set nMtIds_ [$class set numMtIds]
+    	
+    foreach l [array names link_] {
+	set cost_ 1
+	set L [split $l :]
+	set src [lindex $L 0]
+	set dest  [lindex $L 1]
+	puts "SRC: $src"
+	puts "DEST: $dest"
+	set nsrc [$self get-node-by-id $src]
+	set ndest [$self get-node-by-id $src]
+	#if {[$nsrc set mtRouting_]&& [$ndest set mtRouting_]}  {
+	
+		for {set i 0} { $i <= $nMtIds_ } {incr i} {
+			$link_($src:$dest) cost-mt $i $cost_
+			puts "COSTE $cost_"
+			set cost_ [expr $cost_ + 1]	
+		}
+	 #continue	
+	#}
+	#else	
+		
+	#	$link_($src:$dest) cost $cost_
+			
+	#	continue
+    }
+
+}
+
+
diff -Naur ns-2.35-orig/tcl/rtglib/route-proto.tcl ns-2.35/tcl/rtglib/route-proto.tcl
--- ns-2.35-orig/tcl/rtglib/route-proto.tcl	2005-09-16 05:05:46.000000000 +0200
+++ ns-2.35/tcl/rtglib/route-proto.tcl	2015-01-24 16:57:49.564073512 +0100
@@ -1,4 +1,4 @@
-#
+
 #  Copyright (c) 1997 by the University of Southern California
 #  All rights reserved.
 #
@@ -65,17 +65,22 @@
 	if { [$node rtObject?] == "" } {
 	    set rtobj($node) [new rtObject $node]
 	}
-    }
-    foreach node $args {	;# XXX
-        $rtobj($node) compute-routes
-    }
+    }   	
+    foreach node $args {
+      $rtobj($node) compute-routes     	
+   }
+     	
 }
 
 rtObject instproc init node {
     $self next
     $self instvar ns_ nullAgent_
     $self instvar nextHop_ rtpref_ metric_ node_ rtVia_ rtProtos_
-
+    
+    # MODIFICADO: 28-01-07 
+    $self instvar nextHopMt_ metricMt_ numMtids_
+    # FIN MODIFICADO: 28-01-07
+	
     set ns_ [Simulator instance]
     set nullAgent_ [$ns_ set nullAgent_]
 
@@ -93,9 +98,25 @@
 	    set rtVia_($dest)    ""
 	    $node add-route [$dest id] $nullAgent_
 	}
-    }
+    }  
+
+    # MODIFICADO: 28-01-07
+   set numMtids_ [$ns_ get-num-mtids]	
+    foreach dest [$ns_ all-nodes-list] {
+	 for {set mtId 0} { $mtId <= $numMtids_ } {incr mtId} {
+	set nextHopMt_([$dest id]:$mtId) ""
+	if {$node == $dest} {
+	    set metricMt_([$dest id]:$mtId) 0
+	} else {
+	    set metricMt_([$dest id]:$mtId) [$class set unreach_]
+	    
+	}
+    }  
+   }
+    # FIN MODIFICADO: 29-01-07
     $self add-proto Direct $node
     $rtProtos_(Direct) compute-routes
+  		
 }
 
 rtObject instproc add-proto {proto node} {
@@ -114,23 +135,39 @@
     }
 }
 
+
+
 rtObject instproc compute-routes {} {
     # choose the best route to each destination from all protocols
     $self instvar ns_ node_ rtProtos_ nullAgent_
     $self instvar nextHop_ rtpref_ metric_ rtVia_
+    # MODIFICADO: 24-01-07
+    $self instvar nextHopMt_ numMtids_ mtRouting_ nameprotos_	
+    set numMtids_ [$ns_ get-num-mtids]   
+    set mtRouting_ [$node_ set mtRouting_]		
+    # FIN MODIFICADO: 24-01-07
+    
     set protos ""
     set changes 0
+            	
+    
     foreach p [array names rtProtos_] {
 	if [$rtProtos_($p) set rtsChanged_] {
 	    incr changes
 	    $rtProtos_($p) set rtsChanged_ 0
 	}
 	lappend protos $rtProtos_($p)
+	set nameprotos_($rtProtos_($p)) $p
+    }
+
+    if !$changes {
+	 return
     }
-    if !$changes return
 
     set changes 0
+    puts "NODO ORIGEN: [$node_ id]"	
     foreach dst [$ns_ all-nodes-list] {
+	puts "NODO DESTINO: [$dst id]"
 	if {$dst == $node_} continue
 	set nh ""
 	set pf [$class set maxpref_]
@@ -138,21 +175,39 @@
 	set rv ""
 	foreach p $protos {
 	    set pnh [$p set nextHop_($dst)]
+	    	
 	    if { $pnh == "" } continue
-
+	    		
 	    set ppf [$p set rtpref_($dst)]
 	    set pmt [$p set metric_($dst)]
-	    if {$ppf < $pf || ($ppf == $pf && $pmt < $mt) || $mt < 0} {
+	    if {$ppf < $pf || ($ppf == $pf && $pmt < $mt) || $mt < 0} {		
 		set nh  $pnh
 		set pf  $ppf
 		set mt  $pmt
 		set rv  $p
+		
 	    }
 	}
+	
 	if { $nh == "" } {
+	    puts "no route.. delete any existing routes"	
 	    # no route...  delete any existing routes
 	    if { $nextHop_($dst) != "" } {
+		
+		# MODIFICADO: 24-01-07
+		if { $nameprotos_($rv)=="OSPF" && $mtRouting_ } {
+			puts "primer delete-routes-mt"
+			for {set mtId 0} { $mtId <= $numMtids_ } {incr mtId} {
+			if {$nextHopMt_([$dst id]:$mtId)!= ""} {
+			#set nh [$rv set nextHopMt_([$dst id]:$mtId)]
+			  set nhaux $nextHopMt_([$dst id]:$mtId)
+			  $node_ delete-routes-mt [$dst id] $nhaux $nullAgent_ $mtId
+			 }	
+			}
+		} else {
 		$node_ delete-routes [$dst id] $nextHop_($dst) $nullAgent_
+		}
+		# FIN MODIFICADO: 24-01-07	
 		set nextHop_($dst) $nh
 		set rtpref_($dst)  $pf
 		set metric_($dst)  $mt
@@ -162,11 +217,43 @@
 	} else {
 	    if { $rv == $rtVia_($dst) } {
 		# Current protocol still has best route.
-		# See if changed
+		# See i
+		puts "current protocol stil has best route"
+
 		if { $nh != $nextHop_($dst) } {
-		    $node_ delete-routes [$dst id] $nextHop_($dst) $nullAgent_
-		    set nextHop_($dst) $nh
+		puts " nh != nextHoop(dst)--> delete"
+
+		# MODIFICADO: 24-01-07
+		if { $nameprotos_($rv)=="OSPF" && $mtRouting_ } {
+			puts "segundo delete-routes-mt"
+			for {set mtId 0} { $mtId <= $numMtids_ } {incr mtId} {
+			if { $nextHopMt_([$dst id]:$mtId) != ""} {			
+ 			  #set nh [$rv set nextHopMt_([$dst id]:$mtId)]			
+			  set nhaux $nextHopMt_([$dst id]:$mtId) 				
+			  $node_ delete-routes-mt [$dst id] $nhaux $nullAgent_ $mtId
+			  }		
+			}
+		} else {
+		$node_ delete-routes [$dst id] $nextHop_($dst) $nullAgent_
+		}
+		# FIN MODIFICADO: 24-01-07	
+		    
+		set nextHop_($dst) $nh
+		puts "ADD ROUTES PRIMERO destino: [$dst id]"
+		# MODIFICADO: 24-01-07
+		if { $nameprotos_($rv)=="OSPF" && $mtRouting_ } {
+			puts "primer add-routes-mt"
+			for {set mtId 0} { $mtId <= $numMtids_ } {incr mtId} {
+			set nhaux [$rv set nextHopMt_([$dst id]:$mtId)]
+			set nextHopMt_([$dst id]:$mtId) $nhaux
+			$node_ add-routes-mt [$dst id] $nhaux $mtId	
+			}
+		} else {
 		    $node_ add-routes [$dst id] $nextHop_($dst)
+		
+		}
+		# FIN MODIFICADO: 24-01-07	
+		 
 		    incr changes
 		}
 		if { $mt != $metric_($dst) } {
@@ -177,20 +264,51 @@
 		    set rtpref_($dst) $pf
 		}
 	    } else {
+		puts " nh=nextHop(dst)"
+ 
 		if { $rtVia_($dst) != "" } {
+		    puts "rtVia(dst)!= vacio"	
 		    set nextHop_($dst) [$rtVia_($dst) set nextHop_($dst)]
 		    set rtpref_($dst)  [$rtVia_($dst) set rtpref_($dst)]
 		    set metric_($dst)  [$rtVia_($dst) set metric_($dst)]
 		}
 		if {$rtpref_($dst) != $pf || $metric_($dst) != $mt} {
-		    # Then new prefs must be better, or
+		    #Then new prefs must be better, or
 		    # new prefs are equal, and new metrics are lower
-		    $node_ delete-routes [$dst id] $nextHop_($dst) $nullAgent_
+		    puts " prefs must be better"	
+		
+		# MODIFICADO: 24-01-07
+		if { $nameprotos_($rv)=="OSPF" && $mtRouting_ } {
+			puts "tercer delete-routes-mt"
+			for {set mtId 0} { $mtId <= $numMtids_ } {incr mtId} {
+			if {$nextHopMt_([$dst id]:$mtId)!=""} {			
+			  set nhaux $nextHopMt_([$dst id]:$mtId) 				
+			  $node_ delete-routes-mt [$dst id] $nhaux $nullAgent_ $mtId
+			  }
+			}
+		} else {
+		$node_ delete-routes [$dst id] $nextHop_($dst) $nullAgent_
+		}
+		# FIN MODIFICADO: 24-01-07
+	
 		    set nextHop_($dst) $nh
 		    set rtpref_($dst)  $pf
 		    set metric_($dst)  $mt
 		    set rtVia_($dst)   $rv
+		    puts "ADD ROUTES SEGUNDO destino: [$dst id]"
+		# MODIFICADO: 24-01-07
+		if { $nameprotos_($rv)=="OSPF" && $mtRouting_ } {
+			puts "segundo add-routes-mt"
+			for {set mtId 0} { $mtId <= $numMtids_ } {incr mtId} {
+ 			set nhaux [$rv set nextHopMt_([$dst id]:$mtId)]
+			set nextHopMt_([$dst id]:$mtId) $nhaux
+			$node_ add-routes-mt [$dst id] $nhaux $mtId	
+			}
+		} else {
 		    $node_ add-routes [$dst id] $nextHop_($dst)
+		}
+		# FIN MODIFICADO: 24-01-07	
+
 		    incr changes
 		}
 	    }
@@ -200,7 +318,156 @@
 	$rtProtos_($proto) send-updates $changes
     }
     #
-    # XXX
+    # XXXcompute-route
+    # detailed multicast routing hooks must come here.
+    # My idea for the hook will be something like:
+    # set mrtObject [$node_ mrtObject?]
+    # if {$mrtObject != ""} {
+    #    $mrtObject recompute-mroutes $changes
+    # }
+    # $changes == 0	if only interfaces changed state.  Look at how
+    #			Agent/rtProto/DV handles ifsUp_
+    # $changes > 0	if new unicast routes were installed.
+    #
+    $self flag-multicast $changes
+}
+ 
+# MODIFICADO: 28-01-07
+
+
+# MODIFICADO: 28-01-07
+rtObject instproc compute-routes-mt {} {
+    puts "compute-routes-mt"	   
+    # choose the best route to each destination from all protocols
+    $self instvar ns_ node_ rtProtos_ nullAgent_
+    $self instvar nextHop_ rtpref_ metric_ rtVia_
+    $self instvar nextHopMt_ numMtids_ mtRouting_ nameprotos_	 metricMt_
+    set numMtids_ [$ns_ get-num-mtids]   
+    
+    set protos ""
+    set changes 0
+            	
+    
+    foreach p [array names rtProtos_] {
+	if [$rtProtos_($p) set rtsChanged_] {
+	    incr changes
+	    $rtProtos_($p) set rtsChanged_ 0
+	    lappend protos $rtProtos_($p)
+	    set nameprotos_($rtProtos_($p)) $p
+	
+	}
+    }
+
+    if !$changes {
+	 return
+    }
+
+    set changes 0
+    puts "NODO ORIGEN: [$node_ id]"
+   for {set mtId 0} { $mtId <= $numMtids_ } {incr mtId} { 
+	puts "MTID: $mtId"
+    foreach dst [$ns_ all-nodes-list] {
+
+	puts "NODO DESTINO: [$dst id]"
+	if {$dst == $node_} continue
+	set nh ""
+	set pf [$class set maxpref_]
+	set mt [$class set unreach_]
+	set rv ""
+	foreach p $protos {
+	    set pnh [$p set nextHopMt_([$dst id]:$mtId)]
+	  	
+	    if { $pnh == "" } continue
+	    set ppf [$p set rtpref_($dst)]
+	    set pmt [$p set metricMt_([$dst id]:$mtId)]
+	    if {$ppf < $pf || ($ppf == $pf && $pmt < $mt) || $mt < 0} {		
+		set nh  $pnh
+		set pf  $ppf
+		set mt  $pmt
+		set rv  $p
+		puts "Protocolo best: $nameprotos_($p)"	
+		   
+	    }
+	}
+	
+	if { $nh == "" } {
+	    puts "no route.. delete any existing routes"	
+	    # no route...  delete any existing routes
+	    if { $nextHopMt_([$dst id]:$mtId) != "" } {
+		
+		set nhaux $nextHopMt_([$dst id]:$mtId)
+		$node_ delete-routes-mt [$dst id] $nhaux $nullAgent_ $mtId	
+		
+		set nextHopMt_([$dst id]:$mtId) $nh
+		set rtpref_($dst)  $pf
+		set metricMt_([$dst id]:$mtId)  $mt
+		set rtVia_($dst)   $rv
+		incr changes
+	    }
+	} else {
+	    if { $rv == $rtVia_($dst) } {
+		# Current protocol still has best route.
+		# See i
+		puts "current protocol stil has best route"
+
+		if { $nh != $nextHopMt_([$dst id]:$mtId) } {
+		puts " nh != nextHoop(dst)--> delete"
+		puts "segundo delete-routes-mt"
+
+		set nhaux $nextHopMt_([$dst id]:$mtId)
+		$node_ delete-routes-mt [$dst id] $nhaux $nullAgent_ $mtId	
+		
+		set nextHopMt_([$dst id]:$mtId) $nh
+		puts "primer add-routes-mt"
+		set nhaux $nextHopMt_([$dst id]:$mtId)
+		$node_ add-routes-mt [$dst id] $nhaux $mtId	
+		
+		    incr changes
+		}
+		if { $mt != $metricMt_([$dst id]:$mtId) } {
+		    set metricMt_([$dst id]:$mtId) $mt
+		    incr changes
+		}
+		if { $pf != $rtpref_($dst) } {
+		    set rtpref_($dst) $pf
+		}
+	    } else {
+
+		if { $rtVia_($dst) != "" } {
+		    puts "rtVia(dst)!= vacio"	
+		    set nextHopMt_([$dst id]:$mtId) [$rtVia_($dst) set nextHopMt_([$dst id]:$mtId)]
+		    set rtpref_($dst)  [$rtVia_($dst) set rtpref_($dst)]
+		    set metricMt_([$dst id]:$mtId)  [$rtVia_($dst) set metricMt_([$dst id]:$mtId)]
+		}
+
+		if {$rtpref_($dst) != $pf || $metricMt_([$dst id]:$mtId) != $mt} {
+		    #Then new prefs mustif new prefs are equal, and new metrics are lower
+		    puts " prefs must be better"	
+		    puts "tercer delete-routes-mt"
+		    set nhaux $nextHopMt_([$dst id]:$mtId)
+		    $node_ delete-routes-mt [$dst id] $nhaux $nullAgent_ $mtId	
+				
+		    set nextHopMt_([$dst id]:$mtId) $nh
+		    set rtpref_($dst)  $pf
+		    set metricMt_([$dst id]:$mtId)  $mt
+		    set rtVia_($dst)   $rv
+		    puts "ADD ROUTES SEGUNDO destino: [$dst id]"
+		    puts "segundo add-routes-mt"
+		    set nhaux $nextHopMt_([$dst id]:$mtId)
+		    $node_ add-routes-mt [$dst id] $nhaux $mtId	
+			
+		    incr changes
+
+		}
+	    }
+	}
+    }
+    }	
+     foreach proto [array names rtProtos_] {
+	$rtProtos_($proto) send-updates $changes
+    }
+    #
+    # XXXcompute-route
     # detailed multicast routing hooks must come here.
     # My idea for the hook will be something like:
     # set mrtObject [$node_ mrtObject?]
@@ -214,6 +481,9 @@
     $self flag-multicast $changes
 }
 
+# MODIFICADO: 28-01-07
+
+
 rtObject instproc flag-multicast changes {
     $self instvar node_
     $node_ notify-mcast $changes
@@ -224,9 +494,29 @@
     foreach p [array names rtProtos_] {
 	$rtProtos_($p) intf-changed
 	$rtProtos_($p) compute-routes
+	
+    }
+
+    $self compute-routes
+  }
+
+# MODIFICADO: 23-10-06
+rtObject instproc cost-changed {} {
+    $self instvar ns_ node_ rtProtos_ rtVia_ nextHop_ rtpref_ metric_
+   
+    foreach p [array names rtProtos_] {
+	$rtProtos_($p) cost-changed
+	$rtProtos_($p) compute-routes-cost
     }
+ 
+   if [$node_ set mtRouting_] {
+   $self compute-routes-mt
+   } else {
     $self compute-routes
+   }
+   
 }
+# FIN MODIFICADO: 23-10-06
 
 rtObject instproc dump-routes chan {
     $self instvar ns_ node_ nextHop_ rtpref_ metric_ rtVia_
@@ -273,6 +563,7 @@
     } else {
 	return ""
     }
+
 }
 
 rtObject instproc nextHop? dest {
@@ -285,6 +576,9 @@
     $self set rtpref_($dest)
 }
 
+
+
+
 rtObject instproc metric? dest {
     $self instvar metric_
     $self set metric_($dest)
@@ -295,12 +589,15 @@
 
 rtPeer instproc init {addr port cls} {
     $self next
-    $self instvar addr_ port_ metric_ rtpref_
+    $self instvar addr_ port_ metric_ rtpref_ 
+   
+		
     set addr_ $addr
     set port_ $port
     foreach dest [[Simulator instance] all-nodes-list] {
 	set metric_($dest) [$cls set INFINITY]
 	set rtpref_($dest) [$cls set preference_]
+	
     }
 }
 
@@ -329,12 +626,12 @@
     set rtpref_($dest) $val
 }
 
+
 rtPeer instproc preference? dest {
     $self instvar rtpref_
     return $rtpref_($dest)
 }
 
-#
 #Class Agent/rtProto -superclass Agent
 
 Agent/rtProto proc pre-init-all args {
@@ -361,6 +658,7 @@
 	set ifstat_($nbr) [$link up?]
     }
     set rtObject_ [$node rtObject?]
+    	
 }
 
 Agent/rtProto instproc compute-routes {} {
@@ -371,6 +669,18 @@
     #NOTHING
 }
 
+# MODIFICADO: 26-10-06
+Agent/rtProto instproc cost-changed {} {
+    #NOTHING
+}
+# FIN MODIFICADO: 26-10-06
+
+# MODIFICADO: 2-11-06
+Agent/rtProto instproc compute-routes-cost {} {
+    #NOTHING
+}
+# FIN MODIFICADO: 2-11-06
+
 Agent/rtProto instproc send-updates args {
     #NOTHING
 }
@@ -415,6 +725,9 @@
 Agent/rtProto/Direct instproc init node {
     $self next $node
     $self instvar ns_ rtpref_ nextHop_ metric_ ifs_
+    # MODIFICADO:28-01-07
+    $self instvar nextHopMt_ metricMt_ numMtids_
+    # FIN MODIFICADO:28-01-07			
 
     foreach node [$ns_ all-nodes-list] {
 	set rtpref_($node) 255
@@ -424,11 +737,26 @@
     foreach node [array names ifs_] {
 	set rtpref_($node) [$class set preference_]
     }
+    # MODIFICADO:28-01-07    
+    set numMtids_ [$ns_ get-num-mtids]  
+   
+  	foreach node [$ns_ all-nodes-list] {
+  		for {set mtId 0} { $mtId <= $numMtids_ } {incr mtId} {
+		set nextHopMt_([$node id]:$mtId) ""
+		set metricMt_([$node id]:$mtId) -1
+        }
+    }
+   # FIN MODIFICADO:20-01-07	
 }
 
 Agent/rtProto/Direct instproc compute-routes {} {
     $self instvar ifs_ ifstat_ nextHop_ metric_ rtsChanged_
     set rtsChanged_ 0
+   # MODIFICADO:28-01-07
+    $self instvar nextHopMt_ metricMt_ numMtids_ ns_
+    set numMtids_ [$ns_ get-num-mtids]	
+    # FIN MODIFICADO:28-01-07			
+
     foreach nbr [array names ifs_] {
 	if {$nextHop_($nbr) == "" && [$ifs_($nbr) up?] == "up"} {
 	    set ifstat_($nbr) 1
@@ -442,8 +770,38 @@
 	    incr rtsChanged_
 	}
     }
+
+ # MODIFICADO:28-01-07	
+    for {set mtId 0} { $mtId <= $numMtids_ } {incr mtId} {
+        foreach nbr [array names ifs_] {
+	   if {$nextHopMt_([$nbr id]:$mtId) == "" && [$ifs_($nbr) up?] == "up"} {
+	    set ifstat_($nbr) 1	
+	    set nextHopMt_([$nbr id]:$mtId) $ifs_($nbr)
+	    set metricMt_([$nbr id]:$mtId) [$ifs_($nbr) cost-mt? $mtId]
+	  
+	} elseif {$nextHopMt_([$nbr id]:$mtId) != "" && [$ifs_($nbr) up?] != "up"} {
+	    set ifstat_($nbr) 0
+	    set nextHopMt_([$nbr id]:$mtId) ""
+	    set metricMt_([$nbr id]:$mtId) -1
+	  
+	}
+        }
+    }
+   # FIN MODIFICADO:20-01-07	
+
 }
 
+# MODIFICADO: 26-10-06
+Agent/rtProto/Direct instproc cost-changed {} {
+  }
+# FIN MODIFICADO: 26-10-06
+
+
+# MODIFICADO: 2-11-06
+Agent/rtProto/Direct instproc compute-routes-cost {} {
+    #NOTHING
+}
+# FIN MODIFICADO: 2-11-06
 #
 # Distance Vector Route Computation
 #
@@ -727,6 +1085,18 @@
     # Because proc methods are not inherited from the parent class.
 }
 
+
+# MODIFICADO: 26-10-06
+Agent/rtProto/DV instproc cost-changed {} {
+    #NOTHING
+}
+# MODIFICADO: 26-10-06
+
+# MODIFICADO: 2-11-06
+Agent/rtProto/DV instproc compute-routes-cost {} {
+    #NOTHING
+}
+# FIN MODIFICADO: 2-11-06
 #
 # Manual routing
 #
@@ -740,6 +1110,7 @@
     # The user will do all routing.
 }
 
+
 ### Local Variables:
 ### mode: tcl
 ### tcl-indent-level: 4

